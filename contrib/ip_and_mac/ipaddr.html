<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE></TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.04Gold (X11; I; FreeBSD 2.2.5-RELEASE i386) [Netscape]">
</HEAD>
<BODY>

<H2>New object class for the IP ADDRESSES manipulations.</H2>

<H3>1. Description:</H3>

<UL>
<P>Type name: <B>ipaddr<BR>
</B>Data lenght: <B>6 bytes<BR>
</B>Data context: <B>ip address and prefix length</B></P>
</UL>

<H3><B>2. How to install:</B></H3>

<UL>
<P>Use script <B>ip.sql </B>to add new type, new functions and operators
to the data base.</P>

<P>Use script <B>ipi.sql </B>to add new type and new operator class ipaddr_ops
to the index system and allow indexing by this new type (with search by
'<B>&gt;</B>', '<B>&gt;=</B>', '<B>&lt;</B>', '<B>&lt;=</B>', '<B>=</B>'
boolean operators).</P>

<P>Use scripts '<B>test1.sql'</B> and '<B>test2.sql'</B> (edit second script
first) to check if indexing work properly.</P>
</UL>

<H3>3. Input / output formsts.</H3>

<P>New type stores IP address and IP prefix in the single data attribute.
To input data, you should use the form</P>

<UL>
<P><B><I>DDD</I>.<I>DDD</I>.<I>DDD</I>.<I>DDD</I>/<I>P</I>P</B></P>
</UL>

<P>for the address <B>DDD.DDD.DDD.DDD</B> and prefix <B>PP</B> (prefix
is len from 0 (for 0.0.0.0) to 32 (for 255.255.255.255)). You can miss
/PP n two cases:</P>

<UL>
<LI>You enter host address (this means /32 prefix) and this is not the
address of the natural class A, B or C network.</LI>

<LI>You enter natural class A, B, C network with the /8, /16 and /24 prefix.</LI>
</UL>

<P>For example, <B>193.124.23.0</B> should be read as '<B>193.124.23.0/24</B>'
network, and '<B>193.124.23.1</B>' should be read as <B>/32 </B>host address.
To enter interface address <B>193.124.23.6/24</B>, you should use exact
form '<B>193.124.23.6/24'</B>.</P>

<P>The address '0.0.0.0' means '0.0.0.0/0', this is <B>default</B> in terms
of routers.</P>

<P><B>ipaddr</B> type data are printed just in the same form (to allow
input/output compatibility) - <B>193.124.23.0/24</B> should be printed
as '<B>193.124.23.0</B>' and '<B>193.124.23.1/32</B>' should be printed
as '<B>193.124.23.1</B>'.</P>

<P>There is special function to convert ipaddr data into string by the
format:</P>

<UL>
<P>char ipaddr_print(ipaddr,format)</P>
</UL>

<P>format consist of plain text and %C special characters:</P>

<UL>
<P><B>%A</B> - address in form ddd.ddd.ddd.ddd,<BR>
<B>%M </B>- network mask in form ddd.ddd.ddd.ddd,<BR>
<B>%B </B>- negated mask ('0.0.0.7' for '/29' prefix, for example),<BR>
<B>%P</B> - prefix (withouth '/' delimiter).</P>
</UL>

<H3>4. Operators.</H3>

<TABLE ALIGN=ABSCENTER BORDER=2 CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>Left argument<BR>
A1</TD>

<TD>Op</TD>

<TD>Right argument<BR>
A2</TD>

<TD>Result<BR>
R</TD>

<TD>Description</TD>
</TR>

<TR>
<TD>ipaddr</TD>

<TD>&lt;</TD>

<TD>ipaddr</TD>

<TD>boolean</TD>

<TD>Compare addresses, if they are equal, compare prefixes,</TD>
</TR>

<TR>
<TD>ipaddr</TD>

<TD>&lt;=</TD>

<TD>ipaddr</TD>

<TD>boolean</TD>

<TD>Compare addresses, if they are equal, compare prefixes,</TD>
</TR>

<TR>
<TD>ipaddr</TD>

<TD>=</TD>

<TD>ipaddr</TD>

<TD>boolean</TD>

<TD>Compare addresses, if they are equal, compare prefixes,</TD>
</TR>

<TR>
<TD>ipaddr</TD>

<TD>&gt;=</TD>

<TD>ipaddr</TD>

<TD>boolean</TD>

<TD>Compare addresses, if they are equal, compare prefixes,</TD>
</TR>

<TR>
<TD>ipaddr</TD>

<TD>&gt;</TD>

<TD>ipaddr</TD>

<TD>boolean</TD>

<TD>Compare addresses, if they are equal, compare prefixes,</TD>
</TR>

<TR>
<TD>ipaddr</TD>

<TD>&lt;&gt;</TD>

<TD>ipaddr</TD>

<TD>boolean</TD>

<TD>Compare addresses, if they are equal, compare prefixes,</TD>
</TR>

<TR>
<TD>ipaddr</TD>

<TD>@</TD>

<TD>ipaddr</TD>

<TD>boolean</TD>

<TD>True if A1 is the part of network (subnetwork) A2 or if A1 = A2</TD>
</TR>

<TR>
<TD>ipaddr</TD>

<TD>+</TD>

<TD>int4</TD>

<TD>ipaddr</TD>

<TD>Increase address A1 on A2 value (A2 is integer).</TD>
</TR>

<TR>
<TD>ipaddr </TD>

<TD>-</TD>

<TD>int4</TD>

<TD>ipaddr</TD>

<TD>Decrease address A1 on A2.</TD>
</TR>
</TABLE>

<H3>5. Functions.</H3>

<P>There is a lot of functions defined for new ipaddr data type. Some of
them are duplicated by operators described above, some are not. </P>

<TABLE ALIGN=ABSCENTER BORDER=2 CELLSPACING=0 CELLPADDING=0 >
<TR>
<TD>Function(arguments)</TD>

<TD>Function type</TD>

<TD>Description</TD>

<TD>Operator</TD>
</TR>

<TR>
<TD>ipaddr_print(ipaddr, text)</TD>

<TD>text</TD>

<TD>Converts ipaddr to the text string by format from the second argument.
Format can contain %A - address, %M - mask, %B - reversed mask, %P - prefix,
and any other characters.</TD>

<TD></TD>
</TR>

<TR>
<TD>ipaddr_lt(ipaddr, ipaddr)</TD>

<TD>boolean</TD>

<TD>Compare by '&lt;'</TD>

<TD>&lt;</TD>
</TR>

<TR>
<TD>ipaddr_le(ipaddr,ipaddr)</TD>

<TD>boolean</TD>

<TD>Compare by '&lt;='</TD>

<TD>&lt;=</TD>
</TR>

<TR>
<TD>ipaddr_eq(ipaddr, ipaddr)</TD>

<TD>boolean</TD>

<TD>Compare by '='</TD>

<TD>=</TD>
</TR>

<TR>
<TD>ipaddr_ne(ipaddr, ipaddr)</TD>

<TD>boolean</TD>

<TD>Compare by '&lt;&gt;'</TD>

<TD>&lt;&gt;</TD>
</TR>

<TR>
<TD>ipaddr_ge(ipaddr, ipaddr)</TD>

<TD>boolean</TD>

<TD>Compare by '&gt;='</TD>

<TD>&gt;=</TD>
</TR>

<TR>
<TD>ipaddr_gt(ipaddr, ipaddr)</TD>

<TD>boolean</TD>

<TD>Compare by '&gt;'</TD>

<TD>&gt;</TD>
</TR>

<TR>
<TD>ipaddr_in_net(ipaddr, ipaddr)</TD>

<TD>boolean</TD>

<TD><B>True</B> if fisrt argument is the host or subnetwork of the second
argument (first address is equal or included into the second one)</TD>

<TD>@</TD>
</TR>

<TR>
<TD>ipaddr_net(ipaddr)</TD>

<TD>ipaddr</TD>

<TD>Return the network (with the 0 in host bits) for the argument; for
example ipaddr_net('193.124.23.1/24') = '193.124.23.0';</TD>

<TD></TD>
</TR>

<TR>
<TD>ipaddr_bcast(ipaddr)</TD>

<TD>ipaddr</TD>

<TD>Return broadcast address (with the /32 prefix) for the network described
by argument.</TD>

<TD></TD>
</TR>

<TR>
<TD>ipaddr_is_net(ipaddr)</TD>

<TD>boolean</TD>

<TD><B>True</B> if ipaddr is network address; <B>false</B> if its' the
host in the network. For the /32 addresses, returns <B>false</B>.</TD>

<TD></TD>
</TR>

<TR>
<TD>ipaddr_mask(ipaddr)</TD>

<TD>ipaddr</TD>

<TD>Return netmask (with /32 prefix) for the network.</TD>

<TD></TD>
</TR>

<TR>
<TD>ipaddr_prefix(ipaddr)</TD>

<TD>int4</TD>

<TD>Return the prefix size (from 0 to 32).</TD>

<TD></TD>
</TR>

<TR>
<TD>ipaddr_len(ipaddr)</TD>

<TD>int4</TD>

<TD>Return the number of addresses in the particular network (for example,
256 for /24 prefix).</TD>

<TD></TD>
</TR>

<TR>
<TD>ipaddr_integer(ipaddr)</TD>

<TD>int4</TD>

<TD>Return IP address (withouth the prefix) as integer.</TD>

<TD></TD>
</TR>

<TR>
<TD>ipaddr_compose(int4,int4)</TD>

<TD>ipaddr</TD>

<TD>Compose ipaddr object from ip address (first argument) and prefix lenght
(second argument). ipaddr_compose(ipaddr_integer(a),ipaddr_prefix(a)) =
a.</TD>

<TD></TD>
</TR>

<TR>
<TD>ipaddr_plus(ipaddr, int4)</TD>

<TD>ipaddr</TD>

<TD>Operator PLUS (addres increased, prefix does not changed)</TD>

<TD>+</TD>
</TR>

<TR>
<TD>ipaddr_minus(ipaddr, int4)</TD>

<TD>ipaddr</TD>

<TD>Operator MINUS (address decreased, prefix does not changed).</TD>

<TD>-</TD>
</TR>

<TR>
<TD>ipaddr_cmp(ipaddr, ipaddr)</TD>

<TD>int4</TD>

<TD>Compare it's arguments and return -1, 0 or +1.</TD>

<TD></TD>
</TR>
</TABLE>

<H3>5. Usage.</H3>

<P>New type opens many interesting futures for the ip routing or ip accounting
networks. For example, you can search all interfaces connected to the same
phisical network by comparing ipaddr_net(interface_address) /if you store
address as address/prefix pair in the single attribute, and so on.</P>

<P>Unfortunately, I had not time (and was not too familiar with RTree ideas
used in Postgres) to check if it's possible to use RTree indexing for the
fast routing lookups by data base. It's important task because usial usage
of this future is _determine the nearest network the particular address
contain to, and link the accounting record to this network_. And so on.</P>

<P>Write any questions or wishes to me by e-mail. This is BETA version
of this package for now, because we are building our IP routing data base
just now and did not tested all this fucntions under heavy conditions;
through I hope this functions are too simple for the hidden bugs, and they
was tested carefully at the simple tests.</P>

<H3>6. Installation.</H3>

<OL>
<LI>Translate shared library ip.so:<BR>
make</LI>

<LI>Install shared library to the proper place (/usr/local/pgsql/contrib/ip_and_macs)<BR>
make install<BR>
(in case if your system is not FreeBSD, it can be nessesary modify 'Makefile'
before).</LI>

<LI>Public to the accessible place scripts ip.sql (installation of data
type), ipi.sql (describing of this data type for the proper indexing),
test1.sql, test2.sql, test.DATA (test and data). Modify test1.sql in accordance
to real location of the data files.</LI>

<LI>To add new data type into your data base, exec scripts in this data
base:<BR>
psql DATA_BASE<BR>
\i ip.sql -- change this to the real location<BR>
\i ipi.sql -- change this to the real location</LI>

<LI>To test this data type, exec test1.sql and test2.sql SQL scripts.</LI>
</OL>

<H3>7. Download.</H3>

<P>You can download this data type from <B>http://relcom.EU.net/ip_class.tar.gz</B></P>

<H3><BR>
</H3>

<P>
<HR WIDTH="100%"></P>

<P>Aleksei Roudnev, The Network Operation Centre, Relcom Network; Moscow,
Russia.</P>

<UL><B></B></UL>

<UL></UL>

</BODY>
</HTML>
