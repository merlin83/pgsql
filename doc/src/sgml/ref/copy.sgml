<!--
$Header: /home/rubik/work/pgcvs/CVSROOT/pgsql/doc/src/sgml/ref/copy.sgml,v 1.10 1999-10-29 23:52:20 momjian Exp $
Postgres documentation
-->

<refentry id="SQL-COPY">
 <refmeta>
  <refentrytitle id="sql-copy-title">
   COPY
  </refentrytitle>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
 <refnamediv>
  <refname>
   COPY
  </refname>
  <refpurpose>
   Copies data between files and tables
  </refpurpose>
 </refnamediv>
 <refsynopsisdiv>
  <refsynopsisdivinfo>
   <date>1999-07-20</date>
  </refsynopsisdivinfo>
  <synopsis>
COPY [ BINARY ] <replaceable class="parameter">table</replaceable> [ WITH OIDS ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | <filename>stdin</filename> }
    [ [USING] DELIMITERS '<replaceable class="parameter">delimiter</replaceable>' ]
COPY [ BINARY ] <replaceable class="parameter">table</replaceable> [ WITH OIDS ]
    TO { '<replaceable class="parameter">filename</replaceable>' | <filename>stdout</filename> }
    [ [USING] DELIMITERS '<replaceable class="parameter">delimiter</replaceable>' ]
  </synopsis>
  
  <refsect2 id="R2-SQL-COPY-1">
   <refsect2info>
    <date>1998-09-08</date>
   </refsect2info>
   <title>
    Inputs
   </title>
   <para>

    <variablelist>
     <varlistentry>
      <term>BINARY</term>
      <listitem>
       <para>
	Changes the behavior of field formatting, forcing all data to be
	stored or read as binary objects rather than as text.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">table</replaceable></term>
      <listitem>
       <para>
	The name of an existing table.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>WITH OIDS</term>
      <listitem>
       <para>
	Copies the internal unique object id (OID) for each row.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">filename</replaceable></term>
      <listitem>
       <para>
	The absolute Unix pathname of the input or output file.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>stdin</filename></term>
      <listitem>
       <para>
	Specifies that input comes from a pipe or terminal.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>stdout</filename></term>
      <listitem>
       <para>
	Specifies that output goes to a pipe or terminal.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">delimiter</replaceable></term>
      <listitem>
       <para>
	A character that delimits the input or output fields.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>
  
  <refsect2 id="R2-SQL-COPY-2">
   <refsect2info>
    <date>1998-09-08</date>
   </refsect2info>
   <title>
    Outputs
   </title>
   <para>

    <variablelist>
     <varlistentry>
      <term><computeroutput>
COPY
       </computeroutput></term>
      <listitem>
       <para>
	The copy completed successfully.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><computeroutput>
ERROR: <replaceable>reason</replaceable>
       </computeroutput></term>
      <listitem>
       <para>
	The copy failed for the reason stated in the error message.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>
 </refsynopsisdiv>
 
 <refsect1 id="R1-SQL-COPY-1">
  <refsect1info>
   <date>1998-09-08</date>
  </refsect1info>
  <title>
   Description
  </title>
  <para>
   <command>COPY</command> moves data between
   <productname>Postgres</productname> tables and
   standard file-system files.

   <command>COPY</command> instructs
   the <productname>Postgres</productname> backend
   to directly read from or write to a file. The file must be directly visible to
   the backend and the name must be specified from the viewpoint of the backend.
   If <filename>stdin</filename> or <filename>stdout</filename> are
   specified, data flows through the client frontend to  the backend.
  </para>

  <refsect2 id="R2-SQL-COPY-3">
   <refsect2info>
    <date>1998-09-08</date>
   </refsect2info>
   <title>
    Notes
   </title>
   <para>
    The BINARY keyword will force all data to be
    stored/read as binary objects rather than as text.  It is
    somewhat faster than the normal copy command, but is not
    generally portable, and the files generated are somewhat larger,
    although this factor is highly dependent on the data itself.  By
    default, a text copy uses a tab ("\t") character as a delimiter.
    The delimiter may also be changed to any other single character
    with the keyword phrase USING DELIMITERS.  Characters
    in data fields which happen to match the delimiter character will
    be quoted.
   </para>
   
   <para>
    You must have <firstterm>select access</firstterm> on any table
    whose values are read by
    <command>COPY</command>, and either
    <firstterm>insert or update access</firstterm> to a
    table into which values are being inserted by <command>COPY</command>.
    The backend also needs appropriate Unix permissions for any file read
    or written by <command>COPY</command>.
   </para>

   <para>
    The keyword phrase USING DELIMITERS specifies a single character
    to be used for all delimiters between columns. If multiple characters
    are specified in the delimiter string,  only the first character is
    used.
    
    <tip>
     <para>
      Do not confuse <command>COPY</command> with the
      <application>psql</application> instruction <command>\copy</command>.
     </para>
    </tip>
   </para>

   <para>
    <command>COPY</command> neither invokes rules nor acts on column defaults.
    It does invoke triggers, however.
   </para>
   <para>
    <command>COPY</command> stops operation at the first error.  This
    should not lead to problems in the event of
    a <command>COPY FROM</command>, but the
    target relation will, of course, be partially modified in a
    <command>COPY TO</command>.
    <command>VACUUM</command> should be used to clean up
    after a failed copy.
   </para>
   <para>
    Because the Postgres backend's current working directory
    is not usually the same as the user's
    working directory, the result of copying to a file
    "<filename>foo</filename>" (without
    additional path information) may yield unexpected results for the
    naive user.  In this case, <filename>foo</filename>
    will wind up in <filename>$PGDATA/foo</filename>.  In
    general, the full pathname as it would appear to the backend server machine
    should be used when specifying files to
    be copied.
   </para>
   <para>
    Files used as arguments to <command>COPY</command>
    must reside on or be
    accessible to the database server machine by being either on
    local disks or on a networked file system.
   </para>
   <para>
    When a TCP/IP connection from one machine to another is used, and a
    target file is specified, the target file will be written on the
    machine where the backend is running rather than the user's
    machine. 
   </para>
  </refsect2>
 </refsect1>
 
 <refsect1 id="R1-SQL-COPY-2">
  <refsect1info>
   <date>1998-05-04</date>
  </refsect1info>
  <title>File Formats</title>
  <refsect2>
   <refsect2info>
    <date>1998-05-04</date>
   </refsect2info>
   <title>Text Format</title>
   <para>
    When <command>COPY TO</command> is used without the BINARY option,
    the file generated will have each row (instance) on a single line, with each
    column (attribute) separated by the delimiter character.  Embedded
    delimiter characters will be preceded by a backslash character
    ("\").  The attribute values themselves are strings generated by the
    output function associated with each attribute type.  The output
    function for a type should not try to generate the backslash
    character; this will be handled by <command>COPY</command> itself.
   </para>
   <para>
    The actual format for each instance is
    <programlisting>
&lt;attr1&gt;&lt;<replaceable class=parameter>separator</replaceable>&gt;&lt;attr2&gt;&lt;<replaceable class=parameter>separator</replaceable>&gt;...&lt;<replaceable class=parameter>separator</replaceable>&gt;&lt;attr<replaceable class="parameter">n</replaceable>&gt;&lt;newline&gt;
    </programlisting>
    The oid is placed on the beginning of the line
    if WITH OIDS is specified.
   </para>
   <para>
    If <command>COPY</command> is sending its output to standard
    output instead of a file, it will send a backslash("\") and a period
    (".")  followed immediately by a newline, on a separate line,
    when it is done.  Similarly, if <command>COPY</command> is reading
    from standard input, it will expect a backslash ("\") and a period
    (".") followed by a newline, as the first three characters on a
    line to denote end-of-file.  However, <command>COPY</command>
    will terminate (followed by the backend itself) if a true EOF is
    encountered before this special end-of-file pattern is found.
   </para>
   <para>
    The backslash character has other special meanings.  NULL attributes are
    represented as "\N".  A literal backslash character is represented as two
    consecutive backslashes ("\\").  A literal tab character is represented
    as a backslash and a tab.  A literal newline character is
    represented as a backslash and a newline.  When loading text data
    not generated by <acronym>Postgres</acronym>,
    you will need to convert backslash
    characters ("\") to double-backslashes ("\\") to ensure that they are loaded
    properly.
   </para>
  </refsect2>

  <refsect2>
   <refsect2info>
    <date>1998-05-04</date>
   </refsect2info>
   <title>Binary Format</title>
   <para>
    In the case of <command>COPY BINARY</command>, the first four
    bytes in the file will be the number of instances in the file.  If
    this number is zero, the <command>COPY BINARY</command> command
    will read until end of file is encountered.  Otherwise, it will
    stop reading when this number of instances has been read.
    Remaining data in the file will be ignored.
   </para>
   <para>
    The format for each instance in the file is as follows.  Note that
    this format must be followed <emphasis>exactly</emphasis>.
    Unsigned four-byte integer quantities are called uint32 in the
    table below.
   </para>
   <table frame="all">
    <title>Contents of a binary copy file</title>
    <tgroup cols="2" colsep="1" rowsep="1" align="center">
     <colspec colname="col1">
     <colspec colname="col2">
     <spanspec namest="col1" nameend="col2" spanname="subhead">
     <tbody>
      <row>
       <entry spanname="subhead" align="center">At the start of the file</entry>
      </row>
      <row>
       <entry>uint32</entry>
       <entry>number of tuples</entry>
      </row>
      <row>
       <entry spanname="subhead" align="center">For each tuple</entry>
      </row>
      <row>
       <entry>uint32</entry>
       <entry>total length of tuple data</entry>
      </row>
      <row>
       <entry>uint32</entry>
       <entry>oid (if specified)</entry>
      </row>
      <row>
       <entry>uint32</entry>
       <entry>number of null attributes</entry>
      </row>
      <row>
       <entry>[uint32,...,uint32]</entry>
       <entry>attribute numbers of attributes, counting from 0</entry>
      </row>
      <row>
       <entry>-</entry>
       <entry>&lt;tuple data&gt;</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
  </refsect2>
  <refsect2>
   <refsect2info>
    <date>1998-05-04</date>
   </refsect2info>
   <title>Alignment of Binary Data</title>
   <para>
    On Sun-3s, 2-byte attributes are aligned on two-byte boundaries,
    and all larger attributes are aligned on four-byte boundaries.
    Character attributes are aligned on single-byte boundaries.  On
    most other machines, all attributes larger than 1 byte are aligned on
    four-byte boundaries.  Note that variable length attributes are
    preceded by the attribute's length; arrays are simply contiguous
    streams of the array element type.
   </para>
  </refsect2>
 </refsect1>

 
 <refsect1 id="R1-SQL-COPY-3">
  <title>
   Usage
  </title>
  <para>
The following example copies a table to standard output,
 using a vertical bar ("|") as the field
 delimiter:
  </para>
  <programlisting>
COPY country TO <filename>stdout</filename> USING DELIMITERS '|';
  </programlisting>
  <para>
   To copy data from a Unix file into a table "country":
  </para>
  <programlisting>
COPY country FROM '/usr1/proj/bray/sql/country_data';
  </programlisting>
  <para>
   Here is a sample of data suitable for copying into a table
 from <filename>stdin</filename> (so it
has the termination sequence on the last line):
  </para>
  <programlisting>
   AF      AFGHANISTAN
   AL      ALBANIA
   DZ      ALGERIA
   ...
   ZM      ZAMBIA
   ZW      ZIMBABWE
   \.
  </programlisting>
  <para>
   The same data, output in binary format on a Linux/i586 machine.
   The data is shown after filtering through
 the Unix utility <command>od -c</command>. The table has
   three fields; the first is <classname>char(2)</classname>
 and the second is <classname>text</classname>. All the
   rows have a null value in the third field.
  Notice how the <classname>char(2)</classname>
   field is padded with nulls to four bytes and the text field is
   preceded by its length:
  </para>
  <programlisting>
   355  \0  \0  \0 027  \0  \0  \0 001  \0  \0  \0 002  \0  \0  \0
   006  \0  \0  \0   A   F  \0  \0 017  \0  \0  \0   A   F   G   H
     A   N   I   S   T   A   N 023  \0  \0  \0 001  \0  \0  \0 002
    \0  \0  \0 006  \0  \0  \0   A   L  \0  \0  \v  \0  \0  \0   A
     L   B   A   N   I   A 023  \0  \0  \0 001  \0  \0  \0 002  \0
    \0  \0 006  \0  \0  \0   D   Z  \0  \0  \v  \0  \0  \0   A   L
     G   E   R   I   A
   ...              \n  \0  \0  \0   Z   A   M   B   I   A 024  \0
    \0  \0 001  \0  \0  \0 002  \0  \0  \0 006  \0  \0  \0   Z   W
    \0  \0  \f  \0  \0  \0   Z   I   M   B   A   B   W   E
  </programlisting>
 </refsect1>
 
 <refsect1 id="R1-SQL-COPY-6">
  <title>
   Compatibility
  </title>
  
  <refsect2 id="R2-SQL-COPY-4">
   <refsect2info>
    <date>1998-09-08</date>
   </refsect2info>
   <title>
    SQL92
   </title>
   <para>
    There is no <command>COPY</command> statement in SQL92.
   </para>
  </refsect2>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
