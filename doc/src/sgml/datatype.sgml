<!--
$Header: /home/rubik/work/pgcvs/CVSROOT/pgsql/doc/src/sgml/datatype.sgml,v 1.108 2002-11-15 03:11:15 momjian Exp $
-->

 <chapter id="datatype">
  <title id="datatype-title">Data Types</title>

  <indexterm zone="datatype">
   <primary>data types</primary>
  </indexterm>

  <indexterm>
   <primary>types</primary>
   <see>data types</see>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> has a rich set of native data 
   types available to users.
   Users may add new types to <productname>PostgreSQL</productname> using the
   <command>CREATE TYPE</command> command.
  </para>

  <para>
   <xref linkend="datatype-table"> shows all general-purpose data types
   included in the standard distribution.  Most of the alternative names
   listed in the 
   <quote>Aliases</quote> column are the names used internally by
   <productname>PostgreSQL</productname> for historical reasons.  In
   addition, some internally used or deprecated types are available,
   but they are not listed here.
  </para>

 <para>
   <table id="datatype-table">
    <title>Data Types</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Type Name</entry>
       <entry>Aliases</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><type>bigint</type></entry>
       <entry><type>int8</type></entry>
       <entry>signed eight-byte integer</entry>
      </row>

      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>serial8</type></entry>
       <entry>autoincrementing eight-byte integer</entry>
      </row>

      <row>
       <entry><type>bit</type></entry>
       <entry></entry>
       <entry>fixed-length bit string</entry>
      </row>

      <row>
       <entry><type>bit varying(<replaceable>n</replaceable>)</type></entry>
       <entry><type>varbit(<replaceable>n</replaceable>)</type></entry>
       <entry>variable-length bit string</entry>
      </row>

      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type></entry>
       <entry>logical Boolean (true/false)</entry>
      </row>

      <row>
       <entry><type>box</type></entry>
       <entry></entry>
       <entry>rectangular box in 2D plane</entry>
      </row>

      <row>
       <entry><type>bytea</type></entry>
       <entry></entry>
       <entry>binary data</entry>
      </row>

      <row>
       <entry><type>character(<replaceable>n</replaceable>)</type></entry>
       <entry><type>char(<replaceable>n</replaceable>)</type></entry>
       <entry>fixed-length character string</entry>
      </row>

      <row>
       <entry><type>character varying(<replaceable>n</replaceable>)</type></entry>
       <entry><type>varchar(<replaceable>n</replaceable>)</type></entry>
       <entry>variable-length character string</entry>
      </row>

      <row>
       <entry><type>cidr</type></entry>
       <entry></entry>
       <entry>IP network address</entry>
      </row>

      <row>
       <entry><type>circle</type></entry>
       <entry></entry>
       <entry>circle in 2D plane</entry>
      </row>

      <row>
       <entry><type>date</type></entry>
       <entry></entry>
       <entry>calendar date (year, month, day)</entry>
      </row>

      <row>
       <entry><type>double precision</type></entry>
       <entry><type>float8</type></entry>
       <entry>double precision floating-point number</entry>
      </row>

      <row>
       <entry><type>inet</type></entry>
       <entry></entry>
       <entry>IP host address</entry>
      </row>

      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type>, <type>int4</type></entry>
       <entry>signed four-byte integer</entry>
      </row>

      <row>
       <entry><type>interval(<replaceable>p</replaceable>)</type></entry>
       <entry></entry>
       <entry>general-use time span</entry>
      </row>

      <row>
       <entry><type>line</type></entry>
       <entry></entry>
       <entry>infinite line in 2D plane (not implemented)</entry>
      </row>

      <row>
       <entry><type>lseg</type></entry>
       <entry></entry>
       <entry>line segment in 2D plane</entry>
      </row>

      <row>
       <entry><type>macaddr</type></entry>
       <entry></entry>
       <entry>MAC address</entry>
      </row>

      <row>
       <entry><type>money</type></entry>
       <entry></entry>
       <entry>currency amount</entry>
      </row>

      <row>
       <entry><type>numeric [ (<replaceable>p</replaceable>,
	 <replaceable>s</replaceable>) ]</type></entry>
       <entry><type>decimal [ (<replaceable>p</replaceable>,
	 <replaceable>s</replaceable>) ]</type></entry>
       <entry>exact numeric with selectable precision</entry>
      </row>

      <row>
       <entry><type>path</type></entry>
       <entry></entry>
       <entry>open and closed geometric path in 2D plane</entry>
      </row>

      <row>
       <entry><type>point</type></entry>
       <entry></entry>
       <entry>geometric point in 2D plane</entry>
      </row>

      <row>
       <entry><type>polygon</type></entry>
       <entry></entry>
       <entry>closed geometric path in 2D plane</entry>
      </row>

      <row>
       <entry><type>real</type></entry>
       <entry><type>float4</type></entry>
       <entry>single precision floating-point number</entry>
      </row>

      <row>
       <entry><type>smallint</type></entry>
       <entry><type>int2</type></entry>
       <entry>signed two-byte integer</entry>
      </row>

      <row>
       <entry><type>serial</type></entry>
       <entry><type>serial4</type></entry>
       <entry>autoincrementing four-byte integer</entry>
      </row>

      <row>
       <entry><type>text</type></entry>
       <entry></entry>
       <entry>variable-length character string</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>time of day</entry>
      </row>

      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timetz</type></entry>
       <entry>time of day, including time zone</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] without time zone</type></entry>
       <entry><type>timestamp</type></entry>
       <entry>date and time</entry>
      </row>

      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ with time zone ]</type></entry>
       <entry><type>timestamptz</type></entry>
       <entry>date and time, including time zone</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <note>
   <title>Compatibility</title>
   <para>
    The following types (or spellings thereof) are specified by
    <acronym>SQL</acronym>: <type>bit</type>, <type>bit
    varying</type>, <type>boolean</type>, <type>char</type>,
    <type>character</type>, <type>character varying</type>,
    <type>varchar</type>, <type>date</type>, <type>double
    precision</type>, <type>integer</type>, <type>interval</type>,
    <type>numeric</type>, <type>decimal</type>, <type>real</type>,
    <type>smallint</type>, <type>time</type>, <type>timestamp</type>
    (both with or without time zone).
   </para>
  </note>

  <para>
   Each data type has an external representation determined by its input
   and output functions.  Many of the built-in types have
   obvious external formats.  However, several types are either unique
   to <productname>PostgreSQL</productname>, such as open and closed
   paths, or have several possibilities for formats, such as the date
   and time types.
   Most of the input and output functions corresponding to the
   base types (e.g., integers and floating-point numbers) do some
   error-checking.
   Some of the input and output functions are not invertible.  That is,
   the result of an output function may lose precision when compared to
   the original input.
  </para>

  <para>
   Some of the operators and functions (e.g.,
   addition and multiplication) do not perform run-time error-checking in the
   interests of improving execution speed.
   On some systems, for example, the numeric operators for some data types may
   silently underflow or overflow.
  </para>

  <sect1 id="datatype-numeric">
   <title>Numeric Types</title>

   <indexterm zone="datatype-numeric">
    <primary>data types</primary>
    <secondary>numeric</secondary>
   </indexterm>

   <indexterm zone="datatype-numeric">
    <primary>integer</primary>
   </indexterm>

   <indexterm zone="datatype-numeric">
    <primary>smallint</primary>
   </indexterm>

   <indexterm zone="datatype-numeric">
    <primary>bigint</primary>
   </indexterm>

   <indexterm>
    <primary>int4</primary>
    <see>integer</see>
   </indexterm>

   <indexterm>
    <primary>int2</primary>
    <see>smallint</see>
   </indexterm>

   <indexterm>
    <primary>int8</primary>
    <see>bigint</see>
   </indexterm>

   <indexterm zone="datatype-numeric">
    <primary>numeric (data type)</primary>
   </indexterm>

   <indexterm>
    <primary>decimal</primary>
    <see>numeric</see>
   </indexterm>

   <indexterm zone="datatype-numeric">
    <primary>real</primary>
   </indexterm>

   <indexterm zone="datatype-numeric">
    <primary>double precision</primary>
   </indexterm>

   <indexterm>
    <primary>float4</primary>
    <see>real</see>
   </indexterm>

   <indexterm>
    <primary>float8</primary>
    <see>double precision</see>
   </indexterm>

   <indexterm zone="datatype-numeric">
    <primary>floating point</primary>
   </indexterm>

   <para>
    Numeric types consist of two-, four-, and eight-byte integers,
    four- and eight-byte floating-point numbers, and fixed-precision
    decimals.  <xref linkend="datatype-numeric-table"> lists the
    available types.
   </para>

    <table id="datatype-numeric-table">
     <title>Numeric Types</title>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Type name</entry>
	<entry>Storage size</entry>
	<entry>Description</entry>
	<entry>Range</entry>
       </row>
      </thead>

      <tbody>
       <row>
	<entry><type>smallint</></entry>
	<entry>2 bytes</entry>
	<entry>small range fixed-precision</entry>
	<entry>-32768 to +32767</entry>
       </row>
       <row>
	<entry><type>integer</></entry>
	<entry>4 bytes</entry>
	<entry>usual choice for fixed-precision</entry>
	<entry>-2147483648 to +2147483647</entry>
       </row>
       <row>
	<entry><type>bigint</></entry>
	<entry>8 bytes</entry>
	<entry>large range fixed-precision</entry>
	<entry>-9223372036854775808 to 9223372036854775807</entry>
       </row>

       <row>
	<entry><type>decimal</></entry>
	<entry>variable</entry>
	<entry>user-specified precision, exact</entry>
	<entry>no limit</entry>
       </row>
       <row>
	<entry><type>numeric</></entry>
	<entry>variable</entry>
	<entry>user-specified precision, exact</entry>
	<entry>no limit</entry>
       </row>

       <row>
	<entry><type>real</></entry>
	<entry>4 bytes</entry>
	<entry>variable-precision, inexact</entry>
	<entry>6 decimal digits precision</entry>
       </row>
       <row>
	<entry><type>double precision</></entry>
	<entry>8 bytes</entry>
	<entry>variable-precision, inexact</entry>
	<entry>15 decimal digits precision</entry>
       </row>

       <row>
	<entry><type>serial</></entry>
	<entry>4 bytes</entry>
	<entry>autoincrementing integer</entry>
	<entry>1 to 2147483647</entry>
       </row>

       <row>
	<entry><type>bigserial</type></entry>
	<entry>8 bytes</entry>
	<entry>large autoincrementing integer</entry>
	<entry>1 to 9223372036854775807</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    The syntax of constants for the numeric types is described in
    <xref linkend="sql-syntax-constants">.  The numeric types have a
    full set of corresponding arithmetic operators and
    functions. Refer to <xref linkend="functions"> for more
    information.  The following sections describe the types in detail.
   </para>

   <sect2 id="datatype-int">
    <title>The Integer Types</title>

    <para>
     The types <type>smallint</type>, <type>integer</type>,
     <type>bigint</type> store whole numbers, that is, numbers without
     fractional components, of various ranges.  Attempts to store
     values outside of the allowed range will result in an error.
    </para>

    <para>
     The type <type>integer</type> is the usual choice, as it offers
     the best balance between range, storage size, and performance.
     The <type>smallint</type> type is generally only used if disk
     space is at a premium.  The <type>bigint</type> type should only
     be used if the <type>integer</type> range is not sufficient,
     because the latter is definitely faster.
    </para>

    <para>
     The <type>bigint</type> type may not function correctly on all
     platforms, since it relies on compiler support for eight-byte
     integers.  On a machine without such support, <type>bigint</type>
     acts the same as <type>integer</type> (but still takes up eight
     bytes of storage).  However, we are not aware of any reasonable
     platform where this is actually the case.
    </para>

    <para>
     <acronym>SQL</acronym> only specifies the integer types
     <type>integer</type> (or <type>int</type>) and
     <type>smallint</type>.  The type <type>bigint</type>, and the
     type names <type>int2</type>, <type>int4</type>, and
     <type>int8</type> are extensions, which are shared with various
     other <acronym>SQL</acronym> database systems.
    </para>

    <note>
     <para>
      If you have a column of type <type>smallint</type> or
      <type>bigint</type> with an index, you may encounter problems
      getting the system to use that index.  For instance, a clause of
      the form
<programlisting>
... WHERE smallint_column = 42
</programlisting>
      will not use an index, because the system assigns type
      <type>integer</type> to the constant 42, and
      <productname>PostgreSQL</productname> currently
      cannot use an index when two different data types are involved.  A
      workaround is to single-quote the constant, thus:
<programlisting>
... WHERE smallint_column = '42'
</programlisting>
      This will cause the system to delay type resolution and will
      assign the right type to the constant.
     </para>
    </note>

   </sect2>

   <sect2 id="datatype-numeric-decimal">
    <title>Arbitrary Precision Numbers</title>

    <para>
     The type <type>numeric</type> can store numbers with up to 1,000
     digits of precision and perform calculations exactly. It is
     especially recommended for storing monetary amounts and other
     quantities where exactness is required. However, the
     <type>numeric</type> type is very slow compared to the
     floating-point types described in the next section.
    </para>

    <para>
     In what follows we use these terms:  The
     <firstterm>scale</firstterm> of a <type>numeric</type> is the
     count of decimal digits in the fractional part, to the right of
     the decimal point.  The <firstterm>precision</firstterm> of a
     <type>numeric</type> is the total count of significant digits in
     the whole number, that is, the number of digits to both sides of
     the decimal point.  So the number 23.5141 has a precision of 6
     and a scale of 4.  Integers can be considered to have a scale of
     zero.
    </para>

    <para>
     Both the precision and the scale of the numeric type can be
     configured.  To declare a column of type <type>numeric</type> use
     the syntax
<programlisting>
NUMERIC(<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)
</programlisting>
     The precision must be positive, the scale zero or positive.
     Alternatively,
<programlisting>
NUMERIC(<replaceable>precision</replaceable>)
</programlisting>
     selects a scale of 0.  Specifying
<programlisting>
NUMERIC
</programlisting>
     without any precision or scale creates a column in which numeric
     values of any precision and scale can be stored, up to the
     implementation limit on precision.  A column of this kind will
     not coerce input values to any particular scale, whereas
     <type>numeric</type> columns with a declared scale will coerce
     input values to that scale.  (The <acronym>SQL</acronym> standard
     requires a default scale of 0, i.e., coercion to integer
     precision.  We find this a bit useless.  If you're concerned
     about portability, always specify the precision and scale
     explicitly.)
    </para>

    <para>
     If the precision or scale of a value is greater than the declared
     precision or scale of a column, the system will attempt to round
     the value.  If the value cannot be rounded so as to satisfy the
     declared limits, an error is raised.
    </para>

    <para>
     The types <type>decimal</type> and <type>numeric</type> are
     equivalent.  Both types are part of the <acronym>SQL</acronym>
     standard.
    </para>
   </sect2>


   <sect2 id="datatype-float">
    <title>Floating-Point Types</title>

    <para>
     The data types <type>real</type> and <type>double
     precision</type> are inexact, variable-precision numeric types.
     In practice, these types are usually implementations of
     <acronym>IEEE</acronym> Standard 754 for Binary Floating-Point
     Arithmetic (single and double precision, respectively), to the
     extent that the underlying processor, operating system, and
     compiler support it.
    </para>

    <para>
     Inexact means that some values cannot be converted exactly to the
     internal format and are stored as approximations, so that storing
     and printing back out a value may show slight discrepancies.
     Managing these errors and how they propagate through calculations
     is the subject of an entire branch of mathematics and computer
     science and will not be discussed further here, except for the
     following points:
     <itemizedlist>
      <listitem>
       <para>
        If you require exact storage and calculations (such as for
        monetary amounts), use the <type>numeric</type> type instead.
       </para>
      </listitem>

      <listitem>
       <para>
        If you want to do complicated calculations with these types
        for anything important, especially if you rely on certain
        behavior in boundary cases (infinity, underflow), you should
        evaluate the implementation carefully.
       </para>
      </listitem>

      <listitem>
       <para>
        Comparing two floating-point values for equality may or may
        not work as expected.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Normally, the <type>real</type> type has a range of at least
     -1E+37 to +1E+37 with a precision of at least 6 decimal digits.  The
     <type>double precision</type> type normally has a range of around
     -1E+308 to +1E+308 with a precision of at least 15 digits.  Values that
     are too large or too small will cause an error.  Rounding may
     take place if the precision of an input number is too high.
     Numbers too close to zero that are not representable as distinct
     from zero will cause an underflow error.
    </para>

   </sect2>

   <sect2 id="datatype-serial">
    <title>The Serial Types</title>

    <indexterm zone="datatype-serial">
     <primary>serial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>bigserial</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial4</primary>
    </indexterm>

    <indexterm zone="datatype-serial">
     <primary>serial8</primary>
    </indexterm>

    <indexterm>
     <primary>auto-increment</primary>
     <see>serial</see>
    </indexterm>

    <indexterm>
     <primary>sequences</primary>
     <secondary>and serial type</secondary>
    </indexterm>

    <para>
     The <type>serial</type> data types are not truly types, but are a
     notational convenience for setting up unique identifier columns
     in tables.
     In the current implementation, specifying

<programlisting>
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> SERIAL
);
</programlisting>

     is equivalent to specifying:

<programlisting>
CREATE SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq;
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> integer DEFAULT nextval('<replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq') NOT NULL
);
</programlisting>

     Thus, we have created an integer column and arranged for its default
     values to be assigned from a sequence generator.  A <literal>NOT NULL</>
     constraint is applied to ensure that a null value cannot be explicitly
     inserted, either.  In most cases you would also want to attach a
     <literal>UNIQUE</> or <literal>PRIMARY KEY</> constraint to prevent
     duplicate values from being inserted by accident, but this is
     not automatic.
    </para>

    <para>
     The type names <type>serial</type> and <type>serial4</type> are
     equivalent: both create <type>integer</type> columns.  The type
     names <type>bigserial</type> and <type>serial8</type> work just
     the same way, except that they create a <type>bigint</type>
     column.  <type>bigserial</type> should be used if you anticipate
     the use of more than 2<superscript>31</> identifiers over the lifetime of the table.
    </para>

    <para>
     The sequence created by a <type>serial</type> type is automatically
     dropped when
     the owning column is dropped, and cannot be dropped otherwise.
     (This was not true in <productname>PostgreSQL</productname> releases
     before 7.3.  Note that this automatic drop linkage will not occur for a
     sequence created by reloading a dump from a pre-7.3 database; the dump
     file does not contain the information needed to establish the dependency
     link.)
    </para>

    <note><para>
     Prior to <productname>PostgreSQL</productname> 7.3, <type>serial</type>
     implied <literal>UNIQUE</literal>.  This is no longer automatic.  If
     you wish a serial column to be <literal>UNIQUE</literal> or a 
     <literal>PRIMARY KEY</literal> it must now be specified, same as with
     any other data type.
    </para></note>
   </sect2>
  </sect1>

  <sect1 id="datatype-money">
   <title>Monetary Type</title>

   <note>
    <title>Note</title>
    <para>
     The <type>money</type> type is deprecated. Use
     <type>numeric</type> or <type>decimal</type> instead, in
     combination with the <function>to_char</function> function.  The
     money type may become a locale-aware layer over the
     <type>numeric</type> type in a future release.
    </para>
   </note>

   <para>
    The <type>money</type> type stores a currency amount with fixed
    decimal point representation; see <xref
    linkend="datatype-money-table">.  The output format is
    locale-specific.
   </para>

   <para>
    Input is accepted in a variety of formats, including integer and
    floating-point literals, as well as <quote>typical</quote>
    currency formatting, such as <literal>'$1,000.00'</literal>.
    Output is in the latter form.
   </para>

    <table id="datatype-money-table">
     <title>Monetary Types</title>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Type Name</entry>
	<entry>Storage</entry>
	<entry>Description</entry>
	<entry>Range</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry>money</entry>
	<entry>4 bytes</entry>
	<entry>currency amount</entry>
	<entry>-21474836.48 to +21474836.47</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
  </sect1>


  <sect1 id="datatype-character">
   <title>Character Types</title>

   <indexterm zone="datatype-character">
    <primary>character strings</primary>
    <secondary>data types</secondary>
   </indexterm>

   <indexterm>
    <primary>strings</primary>
    <see>character strings</see>
   </indexterm>

   <indexterm>
    <primary>text</primary>
    <see>character strings</see>
   </indexterm>

    <table id="datatype-character-table">
     <title>Character Types</title>
     <tgroup cols="2">
      <thead>
       <row>
	<entry>Type name</entry>
	<entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry><type>character(<replaceable>n</>)</type>, <type>char(<replaceable>n</>)</type></entry>
	<entry>fixed-length, blank padded</entry>
       </row>
       <row>
	<entry><type>character varying(<replaceable>n</>)</type>, <type>varchar(<replaceable>n</>)</type></entry>
	<entry>variable-length with limit</entry>
       </row>
       <row>
	<entry><type>text</type></entry>
	<entry>variable unlimited length</entry>
       </row>
     </tbody>
     </tgroup>
    </table>

   <para>
    <xref linkend="datatype-character-table"> shows the
    general-purpose character types available in
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    <acronym>SQL</acronym> defines two primary character types:
    <type>character(<replaceable>n</>)</type> and <type>character
    varying(<replaceable>n</>)</type>, where <replaceable>n</> is a
    positive integer.  Both of these types can store strings up to
    <replaceable>n</> characters in length.  An attempt to store a
    longer string into a column of these types will result in an
    error, unless the excess characters are all spaces, in which case
    the string will be truncated to the maximum length.  (This
    somewhat bizarre exception is required by the
    <acronym>SQL</acronym> standard.)  If the string to be stored is
    shorter than the declared length, values of type
    <type>character</type> will be space-padded; values of type
    <type>character varying</type> will simply store the shorter
    string.
   </para>

   <note>
    <para>
     If one explicitly casts a value to
     <type>character(<replaceable>n</>)</type> or <type>character
     varying(<replaceable>n</>)</type>, then an overlength value will
     be truncated to <replaceable>n</> characters without raising an
     error.  (This too is required by the <acronym>SQL</acronym>
     standard.)
    </para>
   </note>

   <note>
    <para>
     Prior to <productname>PostgreSQL</> 7.2, strings that were too long were
     always truncated without raising an error, in either explicit or
     implicit casting contexts.
    </para>
   </note>

   <para>
    The notations <type>char(<replaceable>n</>)</type> and
    <type>varchar(<replaceable>n</>)</type> are aliases for
    <type>character(<replaceable>n</>)</type> and <type>character
    varying(<replaceable>n</>)</type>,
    respectively. <type>character</type> without length specifier is
    equivalent to <type>character(1)</type>; if <type>character
    varying</type> is used without length specifier, the type accepts
    strings of any size.  The latter is a <productname>PostgreSQL</> extension.
   </para>

   <para>
    In addition, <productname>PostgreSQL</productname> supports the
    more general <type>text</type> type, which stores strings of any
    length.  Unlike <type>character varying</type>, <type>text</type>
    does not require an explicit declared upper limit on the size of
    the string.  Although the type <type>text</type> is not in the
    <acronym>SQL</acronym> standard, many other RDBMS packages have it
    as well.
   </para>

   <para>
    The storage requirement for data of these types is 4 bytes plus the
    actual string, and in case of <type>character</type> plus the
    padding. Long strings are compressed by the system automatically, so
    the physical requirement on disk may be less. Long values are also
    stored in background tables so they don't interfere with rapid
    access to the shorter column values. In any case, the longest
    possible character string that can be stored is about 1 GB. (The
    maximum value that will be allowed for <replaceable>n</> in the data
    type declaration is less than that. It wouldn't be very useful to
    change this because with multibyte character encodings the number of
    characters and bytes can be quite different anyway. If you desire to
    store long strings with no specific upper limit, use
    <type>text</type> or <type>character varying</type> without a length
    specifier, rather than making up an arbitrary length limit.)
   </para>

   <tip>
    <para>
     There are no performance differences between these three types,
     apart from the increased storage size when using the blank-padded
     type.
    </para>
   </tip>

   <para>
    Refer to <xref linkend="sql-syntax-strings"> for information about
    the syntax of string literals, and to <xref linkend="functions">
    for information about available operators and functions.
   </para>

   <example>
    <title>Using the character types</title>

<programlisting>
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -- <co id="co.datatype-char">
<computeroutput>
  a   | char_length
------+-------------
 ok   |           4
</computeroutput>

CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('good      ');
INSERT INTO test2 VALUES ('too long');
<computeroutput>ERROR:  value too long for type character varying(5)</computeroutput>
INSERT INTO test2 VALUES ('too long'::varchar(5)); -- explicit truncation
SELECT b, char_length(b) FROM test2;
<computeroutput>
   b   | char_length
-------+-------------
 ok    |           2
 good  |           5
 too l |           5
</computeroutput>
</programlisting>
    <calloutlist>
     <callout arearefs="co.datatype-char">
      <para>
       The <function>char_length</function> function is discussed in
       <xref linkend="functions-string">.
      </para>
     </callout>
    </calloutlist>
   </example>

   <para>
    There are two other fixed-length character types in
    <productname>PostgreSQL</productname>, shown in <xref linkend="datatype-character-special-table">.
    The <type>name</type> type
    exists <emphasis>only</emphasis> for storage of internal catalog
    names and is not intended for use by the general user.  Its length
    is currently defined as 64 bytes (63 usable characters plus terminator)
    but should be referenced using the constant
    <symbol>NAMEDATALEN</symbol>.  The length is set at compile time
    (and is therefore adjustable for special uses); the default
    maximum length may change in a future release.  The type
    <type>"char"</type> (note the quotes) is different from
    <type>char(1)</type> in that it only uses one byte of storage.  It
    is internally used in the system catalogs as a poor-man's
    enumeration type.
   </para>

    <table id="datatype-character-special-table">
     <title>Specialty Character Types</title>
     <tgroup cols="3">
      <thead>
       <row>
	<entry>Type Name</entry>
	<entry>Storage</entry>
	<entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry><type>"char"</type></entry>
	<entry>1 byte</entry>
	<entry>single character internal type</entry>
       </row>
       <row>
	<entry><type>name</type></entry>
	<entry>64 bytes</entry>
	<entry>sixty-three character internal type</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>

 <sect1 id="datatype-binary">
  <title>Binary Strings</title>
   <para>
    The <type>bytea</type> data type allows storage of binary strings;
    see <xref linkend="datatype-binary-table">.
   </para>

   <table id="datatype-binary-table">
    <title>Binary String Types</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Type Name</entry>
       <entry>Storage</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>bytea</type></entry>
       <entry>4 bytes plus the actual binary string</entry>
       <entry>Variable (not specifically limited)
              length binary string</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    A binary string is a sequence of octets (or bytes).  Binary
    strings are distinguished from characters strings by two
    characteristics: First, binary strings specifically allow storing
    octets of zero value and other <quote>non-printable</quote>
    octets.  Second, operations on binary strings process the actual
    bytes, whereas the encoding and processing of character strings
    depends on locale settings.
   </para>

   <para>
    When entering <type>bytea</type> values, octets of certain values
    <emphasis>must</emphasis> be escaped (but all octet values
    <emphasis>may</emphasis> be escaped) when used as part of a string
    literal in an <acronym>SQL</acronym> statement. In general, to
    escape an octet, it is converted into the three-digit octal number
    equivalent of its decimal octet value, and preceded by two
    backslashes. Some octet values have alternate escape sequences, as
    shown in <xref linkend="datatype-binary-sqlesc">.
   </para>

   <table id="datatype-binary-sqlesc">
    <title><type>bytea</> Literal Escaped Octets</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Decimal Octet Value</entry>
       <entry>Description</entry>
       <entry>Input Escaped Representation</entry>
       <entry>Example</entry>
       <entry>Printed Result</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>0</entry>
       <entry>zero octet</entry>
       <entry><literal>'\\000'</literal></entry>
       <entry><literal>SELECT '\\000'::bytea;</literal></entry>
       <entry><literal>\000</literal></entry>
      </row>

      <row>
       <entry>39</entry>
       <entry>single quote</entry>
       <entry><literal>'\''</literal> or <literal>'\\047'</literal></entry>
       <entry><literal>SELECT '\''::bytea;</literal></entry>
       <entry><literal>'</literal></entry>
      </row>

      <row>
       <entry>92</entry>
       <entry>backslash</entry>
       <entry><literal>'\\\\'</literal> or <literal>'\\134'</literal></entry>
       <entry><literal>SELECT '\\\\'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    Note that the result in each of the examples in <xref linkend="datatype-binary-sqlesc"> was exactly one
    octet in length, even though the output representation of the zero
    octet and backslash are more than one character. <type>Bytea</type>
    output octets are also escaped. In general, each
    <quote>non-printable</quote> octet decimal value is converted into
    its equivalent three digit octal value, and preceded by one backslash.
    Most <quote>printable</quote> octets are represented by their standard
    representation in the client character set. The octet with decimal
    value 92 (backslash) has a special alternate output representation.
    Details are in <xref linkend="datatype-binary-resesc">.
   </para>

   <table id="datatype-binary-resesc">
    <title><type>bytea</> Output Escaped Octets</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Decimal Octet Value</entry>
       <entry>Description</entry>
       <entry>Output Escaped Representation</entry>
       <entry>Example</entry>
       <entry>Printed Result</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry>92</entry>
       <entry>backslash</entry>
       <entry><literal>\\</literal></entry>
       <entry><literal>SELECT '\\134'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

      <row>
       <entry>0 to 31 and 127 to 255</entry>
       <entry><quote>non-printable</quote> octets</entry>
       <entry><literal>\### (octal value)</literal></entry>
       <entry><literal>SELECT '\\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

      <row>
       <entry>32 to 126</entry>
       <entry><quote>printable</quote> octets</entry>
       <entry>ASCII representation</entry>
       <entry><literal>SELECT '\\176'::bytea;</literal></entry>
       <entry><literal>~</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    To use the <type>bytea</type> escaped octet notation, string
    literals (input strings) must contain two backslashes because they
    must pass through two parsers in the <productname>PostgreSQL</>
    server. The first backslash is interpreted as an escape character
    by the string-literal parser, and therefore is consumed, leaving
    the characters that follow.  The remaining backslash is recognized
    by the <type>bytea</type> input function as the prefix of a three
    digit octal value. For example, a string literal passed to the
    backend as <literal>'\\001'</literal> becomes
    <literal>'\001'</literal> after passing through the string-literal
    parser. The <literal>'\001'</literal> is then sent to the
    <type>bytea</type> input function, where it is converted to a
    single octet with a decimal value of 1.
   </para>

   <para>
    For a similar reason, a backslash must be input as
    <literal>'\\\\'</literal> (or <literal>'\\134'</literal>). The first
    and third backslashes are interpreted as escape characters by the
    string-literal parser, and therefore are consumed, leaving two
    backslashes in the string passed to the <type>bytea</type> input function,
    which interprets them as representing a single backslash.
    For example, a string literal passed to the
    server as <literal>'\\\\'</literal> becomes <literal>'\\'</literal>
    after passing through the string-literal parser. The
    <literal>'\\'</literal> is then sent to the <type>bytea</type> input
    function, where it is converted to a single octet with a decimal
    value of 92.
   </para>

   <para>
    A single quote is a bit different in that it must be input as
    <literal>'\''</literal> (or <literal>'\\047'</literal>),
    <emphasis>not</emphasis> as <literal>'\\''</literal>. This is because,
    while the literal parser interprets the single quote as a special
    character, and will consume the single backslash, the
    <type>bytea</type> input function does <emphasis>not</emphasis>
    recognize a single quote as a special octet. Therefore a string
    literal passed to the backend as <literal>'\''</literal> becomes
    <literal>'''</literal> after passing through the string-literal
    parser. The <literal>'''</literal> is then sent to the
    <type>bytea</type> input function, where it is retains its single
    octet decimal value of 39.
   </para>

   <para>
    Depending on the front end to <productname>PostgreSQL</> you use,
    you may have additional work to do in terms of escaping and
    unescaping <type>bytea</type> strings. For example, you may also
    have to escape line feeds and carriage returns if your interface
    automatically translates these. Or you may have to double up on
    backslashes if the parser for your language or choice also treats
    them as an escape character.
   </para>

   <para>
	The <acronym>SQL</acronym> standard defines a different binary
	string type, called <type>BLOB</type> or <type>BINARY LARGE
	 OBJECT</type>.  The input format is different compared to
	<type>bytea</type>, but the provided functions and operators are
	mostly the same.
   </para>
 </sect1>


  <sect1 id="datatype-datetime">
   <title>Date/Time Types</title>

   <para>
    <productname>PostgreSQL</productname> supports the full set of
    <acronym>SQL</acronym> date and time types, shown in <xref
    linkend="datatype-datetime-table">.
   </para>

    <table id="datatype-datetime-table">
     <title>Date/Time Types</title>
     <tgroup cols="6">
      <thead>
       <row>
	<entry>Type</entry>
        <entry>Description</entry>
	<entry>Storage</entry>
        <entry>Earliest</entry>
        <entry>Latest</entry>
        <entry>Resolution</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>both date and time</entry>
        <entry>8 bytes</entry>
        <entry>4713 BC</entry>
        <entry>AD 1465001</entry>
        <entry>1 microsecond / 14 digits</entry>
       </row>
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>both date and time</entry>
        <entry>8 bytes</entry>
        <entry>4713 BC</entry>
        <entry>AD 1465001</entry>
        <entry>1 microsecond / 14 digits</entry>
       </row>
       <row>
        <entry><type>interval [ (<replaceable>p</replaceable>) ]</type></entry>
        <entry>time intervals</entry>
        <entry>12 bytes</entry>
        <entry>-178000000 years</entry>
        <entry>178000000 years</entry>
        <entry>1 microsecond</entry>
       </row>
       <row>
        <entry><type>date</type></entry>
        <entry>dates only</entry>
        <entry>4 bytes</entry>
        <entry>4713 BC</entry>
        <entry>32767 AD</entry>
        <entry>1 day</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>times of day only</entry>
        <entry>8 bytes</entry>
        <entry>00:00:00.00</entry>
        <entry>23:59:59.99</entry>
        <entry>1 microsecond</entry>
       </row>
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>times of day only</entry>
        <entry>12 bytes</entry>
        <entry>00:00:00.00+12</entry>
        <entry>23:59:59.99-12</entry>
        <entry>1 microsecond</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    <type>time</type>, <type>timestamp</type>, and
    <type>interval</type> accept an optional precision value
    <replaceable>p</replaceable> which specifies the number of
    fractional digits retained in the seconds field. By default, there
    is no explicit bound on precision.  The allowed range of
    <replaceable>p</replaceable> is from 0 to 6 for the
    <type>timestamp</type> and <type>interval</type> types, 0 to 13
    for the <type>time</type> types.
   </para>

   <note>
   <para>
    When <type>timestamp</> values are stored as double precision floating-point
    numbers (currently the default), the effective limit of precision
    may be less than 6, since timestamp values are stored as seconds
    since 2000-01-01.  Microsecond precision is achieved for dates within
    a few years of 2000-01-01, but the precision degrades for dates further
    away.  When timestamps are stored as eight-byte integers (a compile-time
    option), microsecond precision is available over the full range of
    values.
   </para>
   </note>

   <para>
    Time zones, and time-zone conventions, are influenced by
    political decisions, not just earth geometry. Time zones around the
    world became somewhat standardized during the 1900's,
    but continue to be prone to arbitrary changes.
    <productname>PostgreSQL</productname> uses your operating
    system's underlying features to provide output time-zone
    support, and these systems usually contain information for only
    the time period 1902 through 2038 (corresponding to the full
    range of conventional Unix system time).
    <type>timestamp with time zone</type> and <type>time with time
     zone</type> will use time zone
    information only within that year range, and assume that times
    outside that range are in <acronym>UTC</acronym>.
   </para>

   <para>
    The type <type>time with time zone</type> is defined by the SQL
    standard, but the definition exhibits properties which lead to
    questionable usefulness. In most cases, a combination of
    <type>date</type>, <type>time</type>, <type>timestamp without time
    zone</type> and <type>timestamp with time zone</type> should
    provide a complete range of date/time functionality required by
    any application.
   </para>

   <para>
    The types <type>abstime</type>
    and <type>reltime</type> are lower precision types which are used internally.
    You are discouraged from using these types in new
    applications and are encouraged to move any old
    ones over when appropriate. Any or all of these internal types
    might disappear in a future release.
   </para>

   <sect2 id="datatype-datetime-input">
    <title>Date/Time Input</title>

    <para>
     Date and time input is accepted in almost any reasonable format, including
     <acronym>ISO 8601</acronym>, <acronym>SQL</acronym>-compatible, 
     traditional <productname>PostgreSQL</productname>, and others.
     For some formats, ordering of month and day in date input can be
     ambiguous and there is support for specifying the expected
     ordering of these fields.
     The command
     <literal>SET DateStyle TO 'US'</literal> 
     or <literal>SET DateStyle TO 'NonEuropean'</literal>
     specifies the variant <quote>month before day</quote>, the command
     <literal>SET DateStyle TO 'European'</literal> sets the variant
     <quote>day before month</quote>.
    </para>

    <para>
     <productname>PostgreSQL</productname> is more flexible in
     handling date/time than the
     <acronym>SQL</acronym> standard requires.
     See <xref linkend="datetime-appendix">
     for the exact parsing rules of date/time input and for the
     recognized text fields including months, days of the week, and
     time zones. 
    </para>

    <para>
     Remember that any date or time literal input needs to be enclosed
     in single quotes, like text strings.  Refer to 
     <xref linkend="sql-syntax-constants-generic"> for more
     information.
     <acronym>SQL</acronym> requires the following syntax
<synopsis>
<replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] '<replaceable>value</replaceable>'
</synopsis>
     where <replaceable>p</replaceable> in the optional precision
     specification is an integer corresponding to the
     number of fractional digits in the seconds field. Precision can
     be specified 
     for <type>time</type>, <type>timestamp</type>, and
     <type>interval</type> types.
    </para>

    <sect3>
    <title>Dates</title>

    <indexterm>
     <primary>date</primary>
     <secondary>data type</secondary>
    </indexterm>
 
    <para>
     <xref linkend="datatype-datetime-date-table"> shows some possible
     inputs for the <type>date</type> type.
    </para>

     <table id="datatype-datetime-date-table">
      <title>Date Input</title>
      <tgroup cols="2">
       <thead>
	<row>
	 <entry>Example</entry>
	 <entry>Description</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>January 8, 1999</entry>
	 <entry>unambiguous</entry>
	</row>
	<row>
	 <entry>1999-01-08</entry>
	 <entry>ISO-8601 format, preferred</entry>
	</row>
	<row>
	 <entry>1/8/1999</entry>
	 <entry>U.S.; read as August 1 in European mode</entry>
	</row>
	<row>
	 <entry>8/1/1999</entry>
	 <entry>European; read as August 1 in U.S. mode</entry>
	</row>
	<row>
	 <entry>1/18/1999</entry>
	 <entry>U.S.; read as January 18 in any mode</entry>
	</row>
	<row>
	 <entry>19990108</entry>
	 <entry>ISO-8601 year, month, day</entry>
	</row>
	<row>
	 <entry>990108</entry>
	 <entry>ISO-8601 year, month, day</entry>
	</row>
	<row>
	 <entry>1999.008</entry>
	 <entry>year and day of year</entry>
	</row>
	<row>
	 <entry>99008</entry>
	 <entry>year and day of year</entry>
	</row>
	<row>
	 <entry>J2451187</entry>
	 <entry>Julian day</entry>
	</row>
	<row>
	 <entry>January 8, 99 BC</entry>
	 <entry>year 99 before the Common Era</entry>
	</row>
       </tbody>
      </tgroup>
     </table>
    </sect3>

    <sect3>
     <title>Times</title>

     <indexterm>
      <primary>time</primary>
      <secondary>data type</secondary>
     </indexterm>
     <indexterm>
      <primary>time without time zone</primary>
      <secondary>time</secondary>
     </indexterm>
     <indexterm>
      <primary>time with time zone</primary>
      <secondary>data type</secondary>
     </indexterm>

     <para>
      The <type>time</type> type can be specified as <type>time</type> or
      as <type>time without time zone</type>. The optional precision
      <replaceable>p</replaceable> should be between 0 and 13, and
      defaults to the precision of the input time literal.
     </para>

     <para>
      <xref linkend="datatype-datetime-time-table"> shows the valid <type>time</type> inputs.
     </para>

      <table id="datatype-datetime-time-table">
       <title>Time Input</title>
       <tgroup cols="2">
	<thead>
	 <row>
	  <entry>Example</entry>
	  <entry>Description</entry>
	 </row>
	</thead>
	<tbody>
	 <row>
	  <entry><literal>04:05:06.789</literal></entry>
	  <entry>ISO 8601</entry>
	 </row>
	 <row>
	  <entry><literal>04:05:06</literal></entry>
	  <entry>ISO 8601</entry>
	 </row>
	 <row>
	  <entry><literal>04:05</literal></entry>
	  <entry>ISO 8601</entry>
	 </row>
	 <row>
	  <entry><literal>040506</literal></entry>
	  <entry>ISO 8601</entry>
	 </row>
	 <row>
	  <entry><literal>04:05 AM</literal></entry>
	  <entry>same as 04:05; AM does not affect value</entry>
	 </row>
	 <row>
	  <entry><literal>04:05 PM</literal></entry>
	  <entry>same as 16:05; input hour must be <= 12</entry>
	 </row>
	 <row>
	  <entry><literal>allballs</literal></entry>
	  <entry>same as 00:00:00</entry>
	 </row>
	</tbody>
       </tgroup>
      </table>

     <para>
      The type <type>time with time zone</type> accepts all input also
      legal for the <type>time</type> type, appended with a legal time
      zone, as shown in <xref
      linkend="datatype-datetime-timetz-table">.
     </para>

      <table id="datatype-datetime-timetz-table">
       <title>Time With Time Zone Input</title>
       <tgroup cols="2">
       <thead>
	<row>
	 <entry>Example</entry>
	 <entry>Description</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>04:05:06.789-8</entry>
	 <entry>ISO 8601</entry>
	</row>
	<row>
	 <entry>04:05:06-08:00</entry>
	 <entry>ISO 8601</entry>
	</row>
	<row>
	 <entry>04:05-08:00</entry>
	 <entry>ISO 8601</entry>
	</row>
	<row>
	 <entry>040506-08</entry>
	 <entry>ISO 8601</entry>
	</row>
       </tbody>
      </tgroup>
     </table>

     <para>
      Refer to <xref linkend="datatype-timezone-table"> for
      more examples of time zones.
     </para>
    </sect3>

    <sect3>
    <title>Time stamps</title>

    <indexterm>
     <primary>timestamp</primary>
     <secondary>data type</secondary>
    </indexterm>

    <indexterm>
     <primary>timestamp without time zone</primary>
     <secondary>data type</secondary>
    </indexterm>

     <para>
      Time stamp types exist as <type>timestamp [
      (<replaceable>p</replaceable>) ]</type>, <type>timestamp [
      (<replaceable>p</replaceable>) ] without time zone</type> and
      <type>timestamp [ (<replaceable>p</replaceable>) ] without time
      zone</type>.  A plain <type>timestamp</type> is equivalent to
      <type>timestamp without timezone</type>.
     </para>

     <para>
      Valid input for the time stamp types consists of a concatenation
      of a date and a time, followed by an optional
      <literal>AD</literal> or <literal>BC</literal>, followed by an
      optional time zone. (See <xref
      linkend="datatype-timezone-table">.)  Thus

<programlisting>
1999-01-08 04:05:06
</programlisting>
      and
<programlisting>
1999-01-08 04:05:06 -8:00
</programlisting>

      are valid values, which follow the <acronym>ISO</acronym> 8601
      standard.  In addition, the wide-spread format

<programlisting>
January 8 04:05:06 1999 PST
</programlisting>
      is supported.
     </para>

     <para>
      The optional precision
      <replaceable>p</replaceable> should be between 0 and 6, and
      defaults to the precision of the input <type>timestamp</type> literal.
     </para>

     <para>
      For <type>timestamp without time zone</type>, any explicit time
      zone specified in the input is silently swallowed. That is, the
      resulting date/time value is derived from the explicit date/time
      fields in the input value, and is not adjusted for time zone.
     </para>

      <table tocentry="1" id="datatype-timezone-table">
       <title>Time Zone Input</title>
       <tgroup cols="2">
	<thead>
	 <row>
	  <entry>Time Zone</entry>
	  <entry>Description</entry>
	 </row>
	</thead>
	<tbody>
	 <row>
	  <entry>PST</entry>
	  <entry>Pacific Standard Time</entry>
	 </row>
	 <row>
	  <entry>-8:00</entry>
	  <entry>ISO-8601 offset for PST</entry>
	 </row>
	 <row>
	  <entry>-800</entry>
	  <entry>ISO-8601 offset for PST</entry>
	 </row>
	 <row>
	  <entry>-8</entry>
	  <entry>ISO-8601 offset for PST</entry>
	 </row>
	</tbody>
       </tgroup>
      </table>
    </sect3>

    <sect3>
     <title>Intervals</title>

     <indexterm>
      <primary>interval</primary>
     </indexterm>

      <para>
       <type>interval</type> values can be written with the following syntax:

<programlisting>
  Quantity Unit [Quantity Unit...] [Direction]
@ Quantity Unit [Quantity Unit...] [Direction]
</programlisting>

      where: <literal>Quantity</literal> is a number (possibly signed),
      <literal>Unit</literal> is <literal>second</literal>,
      <literal>minute</literal>, <literal>hour</literal>, <literal>day</literal>,
      <literal>week</literal>, <literal>month</literal>, <literal>year</literal>,
      <literal>decade</literal>, <literal>century</literal>, <literal>millennium</literal>,
      or abbreviations or plurals of these units;
      <literal>Direction</literal> can be <literal>ago</literal> or
      empty.  The at sign (<literal>@</>) is optional noise.  The amounts
      of different units are implicitly added up with appropriate
      sign accounting.
     </para>

     <para>
      Quantities of days, hours, minutes, and seconds can be specified without
      explicit unit markings.  For example, <literal>'1 12:59:10'</> is read
      the same as <literal>'1 day 12 hours 59 min 10 sec'</>.
     </para>

     <para>
      The optional precision
      <replaceable>p</replaceable> should be between 0 and 6, and
      defaults to the precision of the input literal.
     </para>
    </sect3>

    <sect3>
     <title>Special values</title>

     <indexterm>
      <primary>time</primary>
      <secondary>constants</secondary>
     </indexterm>

     <indexterm>
      <primary>date</primary>
      <secondary>constants</secondary>
     </indexterm>

     <para>
      The following <acronym>SQL</acronym>-compatible functions can be
      used as date or time
      input for the corresponding data type: <literal>CURRENT_DATE</literal>,
      <literal>CURRENT_TIME</literal>,
      <literal>CURRENT_TIMESTAMP</literal>. The latter two accept an
      optional precision specification.  (See also <xref linkend="functions-datetime">.)
     </para>

     <para>
      <productname>PostgreSQL</productname> also supports several
      special constants for convenience, shown in <xref
      linkend="datatype-datetime-special-table">.
     </para>

      <table id="datatype-datetime-special-table">
       <title>Special Date/Time Constants</title>
       <tgroup cols="2">
	<thead>
	 <row>
	  <entry>Constant</entry>
	  <entry>Description</entry>
	 </row>
	</thead>
	<tbody>
	 <row>
	  <entry><literal>epoch</literal></entry>
	  <entry>1970-01-01 00:00:00+00 (Unix system time zero)</entry>
	 </row>
	 <row>
	  <entry><literal>infinity</literal></entry>
	  <entry>later than other valid times</entry>
	 </row>
	 <row>
	  <entry><literal>-infinity</literal></entry>
	  <entry>earlier than other valid times</entry>
	 </row>
	 <row>
	  <entry><literal>invalid</literal></entry>
	  <entry>illegal entry</entry>
	 </row>
	 <row>
	  <entry><literal>now</literal></entry>
	  <entry>current transaction time</entry>
	 </row>
	 <row>
	  <entry><literal>today</literal></entry>
	  <entry>midnight today</entry>
	 </row>
	 <row>
	  <entry><literal>tomorrow</literal></entry>
	  <entry>midnight tomorrow</entry>
	 </row>
	 <row>
	  <entry><literal>yesterday</literal></entry>
	  <entry>midnight yesterday</entry>
	 </row>
	 <row>
	  <entry><literal>zulu</>, <literal>allballs</>, <literal>z</></entry>
	  <entry>00:00:00.00 GMT</entry>
	 </row>
	</tbody>
       </tgroup>
      </table>

    </sect3>
   </sect2>

   <sect2 id="datatype-datetime-output">
    <title>Date/Time Output</title>

    <indexterm>
     <primary>date</primary>
     <secondary>output format</secondary>
     <seealso>Formatting</seealso>
    </indexterm>

    <indexterm>
     <primary>time</primary>
     <secondary>output format</secondary>
     <seealso>Formatting</seealso>
    </indexterm>

    <para>
     Output formats can be set to one of the four styles ISO 8601,
     <acronym>SQL</acronym> (Ingres), traditional PostgreSQL, and
     German, using the <command>SET DateStyle</command>.  The default
     is the <acronym>ISO</acronym> format.  (The
     <acronym>SQL</acronym> standard requires the use of the ISO 8601
     format.  The name of the <quote>SQL</quote> output format is a
     historical accident.)  <xref
     linkend="datatype-datetime-output-table"> shows examples of each
     output style.  The output of the <type>date</type> and
     <type>time</type> types is of course only the date or time part
     in accordance with the given examples.
    </para>

     <table id="datatype-datetime-output-table">
      <title>Date/Time Output Styles</title>
      <tgroup cols="3">
       <thead>
	<row>
	 <entry>Style Specification</entry>
	 <entry>Description</entry>
	 <entry>Example</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>ISO</entry>
	 <entry>ISO 8601/SQL standard</entry>
	 <entry>1997-12-17 07:37:16-08</entry>
	</row>
	<row>
	 <entry>SQL</entry>
	 <entry>traditional style</entry>
	 <entry>12/17/1997 07:37:16.00 PST</entry>
	</row>
	<row>
	 <entry>PostgreSQL</entry>
	 <entry>original style</entry>
	 <entry>Wed Dec 17 07:37:16 1997 PST</entry>
	</row>
	<row>
	 <entry>German</entry>
	 <entry>regional style</entry>
	 <entry>17.12.1997 07:37:16.00 PST</entry>
	</row>
       </tbody>
      </tgroup>
     </table>

    <para>
     The <acronym>SQL</acronym> style has European and non-European
     (U.S.) variants, which determines whether month follows day or
     vice versa. (See <xref linkend="datatype-datetime-input">
     for how this setting also affects interpretation of input values.)
     <xref linkend="datatype-datetime-output2-table"> shows an
     example.
    </para>

     <table id="datatype-datetime-output2-table">
      <title>Date Order Conventions</title>
      <tgroup cols="3">
       <thead>
	<row>
	 <entry>Style Specification</entry>
	 <entry>Description</entry>
	 <entry>Example</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>European</entry>
	 <entry><replaceable>day</replaceable>/<replaceable>month</replaceable>/<replaceable>year</replaceable></entry>
	 <entry>17/12/1997 15:37:16.00 MET</entry>
	</row>
	<row>
	 <entry>US</entry>
	 <entry><replaceable>month</replaceable>/<replaceable>day</replaceable>/<replaceable>year</replaceable></entry>
	 <entry>12/17/1997 07:37:16.00 PST</entry>
	</row>
       </tbody>
      </tgroup>
     </table>

    <para>
    <type>interval</type> output looks like the input format, except that units like
    <literal>week</literal> or <literal>century</literal> are converted to years and days.
    In ISO mode the output looks like

<programlisting>
[ Quantity Units [ ... ] ] [ Days ] Hours:Minutes [ ago ]
</programlisting>
    </para>

    <para>
     The date/time styles can be selected by the user using the
     <command>SET DATESTYLE</command> command, the
     <varname>datestyle</varname> parameter in the
     <filename>postgresql.conf</filename> configuration file, and the
     <envar>PGDATESTYLE</envar> environment variable on the server or
     client.  The formatting function <function>to_char</function>
     (see <xref linkend="functions-formatting">) is also available as
     a more flexible way to format the date/time output.
    </para>
   </sect2>

   <sect2 id="datatype-timezones">
    <title>Time Zones</title>

    <indexterm zone="datatype-timezones">
     <primary>time zones</primary>
    </indexterm>

    <para>
     <productname>PostgreSQL</productname> endeavors to be compatible with
     the <acronym>SQL</acronym> standard definitions for typical usage.
     However, the <acronym>SQL</acronym> standard has an odd mix of date and
     time types and capabilities. Two obvious problems are:

     <itemizedlist>
      <listitem>
       <para>
	Although the <type>date</type> type 
	does not have an associated time zone, the
	<type>time</type> type can.
	Time zones in the real world can have no meaning unless 
	associated with a date as well as a time
	since the offset may vary through the year with daylight-saving
	time boundaries.
       </para>
      </listitem>

      <listitem>
       <para>
	The default time zone is specified as a constant integer offset 
	from <acronym>GMT</>/<acronym>UTC</>. It is not possible to adapt to daylight-saving
	time when doing date/time arithmetic across
	<acronym>DST</acronym> boundaries.
       </para>
      </listitem>

     </itemizedlist>
    </para>

    <para>
     To address these difficulties, we recommend using date/time types
     that contain both date and time when using time zones. We
     recommend <emphasis>not</emphasis> using the type <type>time with
     time zone</type> (though it is supported by
     <productname>PostgreSQL</productname> for legacy applications and
     for compatibility with other <acronym>SQL</acronym>
     implementations).  <productname>PostgreSQL</productname> assumes
     your local time zone for any type containing only date or
     time. Further, time zone support is derived from the underlying
     operating system time-zone capabilities, and hence can handle
     daylight-saving time and other expected behavior.
    </para>

    <para>
     <productname>PostgreSQL</productname> obtains time-zone support
     from the underlying operating system for dates between 1902 and
     2038 (near the typical date limits for Unix-style
     systems). Outside of this range, all dates are assumed to be
     specified and used in Universal Coordinated Time
     (<acronym>UTC</acronym>).
    </para>

    <para>
     All dates and times are stored internally in
     <acronym>UTC</acronym>, traditionally known as Greenwich Mean
     Time (<acronym>GMT</acronym>).  Times are converted to local time
     on the database server before being sent to the client frontend,
     hence by default are in the server time zone.
    </para>

    <para>
     There are several ways to affect the time-zone behavior:

     <itemizedlist>
      <listitem>
       <para>
	The <envar>TZ</envar> environment variable on the server host
	is used by the server as the default time zone.
       </para>
      </listitem>

      <listitem>
       <para>
	The <envar>PGTZ</envar> environment variable, if set at the
	client, is used by <application>libpq</application>
	applications to send a <command>SET TIME ZONE</command>
	command to the server upon connection.
       </para>
      </listitem>

      <listitem>
       <para>
	The <acronym>SQL</acronym> command <command>SET TIME ZONE</command>
	sets the time zone for the session.
       </para>
      </listitem>

      <listitem>
       <para>
	The construct
<programlisting>
<replaceable>timestamp</replaceable> AT TIME ZONE '<replaceable>zone</replaceable>'
</programlisting>
	where <replaceable>zone</replaceable> can be specified as a
	text time zone (e.g., <literal>'PST'</literal>) or as an
	interval (e.g., <literal>INTERVAL '-08:00'</literal>).
       </para>
      </listitem>
     </itemizedlist>
    </para>

     <note>
      <para>
       If an invalid time zone is specified, the time zone becomes
       <acronym>UTC</acronym> (on most systems anyway).
      </para>
     </note>

   <para>
    Refer to <xref linkend="datetime-appendix"> for a list of
    available time zones.
   </para>

   </sect2>

   <sect2 id="datatype-datetime-internals">
    <title>Internals</title>

    <para>
     <productname>PostgreSQL</productname> uses Julian dates
     for all date/time calculations. They have the nice property of correctly
     predicting/calculating any date more recent than 4713 BC
     to far into the future, using the assumption that the length of the
     year is 365.2425 days.
    </para>

    <para>
     Date conventions before the 19th century make for interesting reading,
     but are not consistent enough to warrant coding into a date/time handler.
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-boolean">
   <title>Boolean Type</title>

   <indexterm zone="datatype-boolean">
    <primary>Boolean</primary>
    <secondary>data type</secondary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>true</primary>
   </indexterm>

   <indexterm zone="datatype-boolean">
    <primary>false</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> provides the
    standard <acronym>SQL</acronym> type <type>boolean</type>.
    <type>boolean</type> can have one of only two states:
    <quote>true</quote> or <quote>false</quote>.  A third state,
    <quote>unknown</quote>, is represented by the
    <acronym>SQL</acronym> null value.
   </para>

   <para>
    Valid literal values for the <quote>true</quote> state are:
    <simplelist>
     <member><literal>TRUE</literal></member>
     <member><literal>'t'</literal></member>
     <member><literal>'true'</literal></member>
     <member><literal>'y'</literal></member>
     <member><literal>'yes'</literal></member>
     <member><literal>'1'</literal></member>
    </simplelist>
    For the <quote>false</quote> state, the following values can be
    used:
    <simplelist>
     <member><literal>FALSE</literal></member>
     <member><literal>'f'</literal></member>
     <member><literal>'false'</literal></member>
     <member><literal>'n'</literal></member>
     <member><literal>'no'</literal></member>
     <member><literal>'0'</literal></member>
    </simplelist>
    Using the key words <literal>TRUE</literal> and
    <literal>FALSE</literal> is preferred (and
    <acronym>SQL</acronym>-compliant).
   </para>

   <example id="datatype-boolean-example">
    <title>Using the <type>boolean</type> type</title>

<programlisting>
CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, 'sic est');
INSERT INTO test1 VALUES (FALSE, 'non est');
SELECT * FROM test1;
 a |    b
---+---------
 t | sic est
 f | non est

SELECT * FROM test1 WHERE a;
 a |    b
---+---------
 t | sic est
</programlisting>
   </example>

   <para>
    <xref linkend="datatype-boolean-example"> shows that
    <type>boolean</type> values are output using the letters
    <literal>t</literal> and <literal>f</literal>.
   </para>

   <tip>
    <para>
     Values of the <type>boolean</type> type cannot be cast directly
     to other types (e.g., <literal>CAST
     (<replaceable>boolval</replaceable> AS integer)</literal> does
     not work).  This can be accomplished using the
     <literal>CASE</literal> expression: <literal>CASE WHEN
     <replaceable>boolval</replaceable> THEN 'value if true' ELSE
     'value if false' END</literal>.  See also <xref
     linkend="functions-conditional">.
    </para>
   </tip>

   <para>
    <type>boolean</type> uses 1 byte of storage.
   </para>
  </sect1>

  <sect1 id="datatype-geometric">
   <title>Geometric Types</title>

   <para>
    Geometric data types represent two-dimensional spatial
    objects. <xref linkend="datatype-geo-table"> shows the geometric
    types available in <productname>PostgreSQL</productname>.  The
    most fundamental type, the point, forms the basis for all of the
    other types.
   </para>

    <table id="datatype-geo-table">
     <title>Geometric Types</title>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Geometric Type</entry>
	<entry>Storage</entry>
	<entry>Representation</entry>
	<entry>Description</entry>
       </row>
      </thead>
      <tbody>
       <row>
	<entry><type>point</type></entry>
	<entry>16 bytes</entry>
	<entry>(x,y)</entry>
	<entry>Point in space</entry>
       </row>
       <row>
	<entry><type>line</type></entry>
	<entry>32 bytes</entry>
	<entry>((x1,y1),(x2,y2))</entry>
	<entry>Infinite line (not fully implemented)</entry>
       </row>
       <row>
	<entry><type>lseg</type></entry>
	<entry>32 bytes</entry>
	<entry>((x1,y1),(x2,y2))</entry>
	<entry>Finite line segment</entry>
       </row>
       <row>
	<entry><type>box</type></entry>
	<entry>32 bytes</entry>
	<entry>((x1,y1),(x2,y2))</entry>
	<entry>Rectangular box</entry>
       </row>
       <row>
	<entry><type>path</type></entry>
	<entry>16+16n bytes</entry>
	<entry>((x1,y1),...)</entry>
	<entry>Closed path (similar to polygon)</entry>
       </row>
       <row>
	<entry><type>path</type></entry>
	<entry>16+16n bytes</entry>
	<entry>[(x1,y1),...]</entry>
	<entry>Open path</entry>
       </row>
       <row>
	<entry><type>polygon</type></entry>
	<entry>40+16n bytes</entry>
	<entry>((x1,y1),...)</entry>
	<entry>Polygon (similar to closed path)</entry>
       </row>
       <row>
	<entry><type>circle</type></entry>
	<entry>24 bytes</entry>
	<entry><(x,y),r></entry>
	<entry>Circle (center and radius)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    A rich set of functions and operators is available to perform various geometric
    operations such as scaling, translation, rotation, and determining 
    intersections.  They are explained in <xref linkend="functions-geometry">.
   </para>

   <sect2>
    <title>Point</title>

    <indexterm>
     <primary>point</primary>
    </indexterm>

    <para>
     Points are the fundamental two-dimensional building block for geometric types.
     <type>point</type> is specified using the following syntax:

<synopsis>
( <replaceable>x</replaceable> , <replaceable>y</replaceable> )
  <replaceable>x</replaceable> , <replaceable>y</replaceable>
</synopsis>

     where the arguments are

     <variablelist>
      <varlistentry>
       <term><replaceable>x</replaceable></term>
       <listitem>
	<para>
	 the x-axis coordinate as a floating-point number
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable>y</replaceable></term>
       <listitem>
	<para>
	 the y-axis coordinate as a floating-point number
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </sect2>

   <sect2>
    <title>Line Segment</title>

    <indexterm>
     <primary>line</primary>
    </indexterm>

    <para>
     Line segments (<type>lseg</type>) are represented by pairs of points.
     <type>lseg</type> is specified using the following syntax:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )  
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     where the arguments are

     <variablelist>
      <varlistentry>
       <term>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</term>
       <term>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</term>
       <listitem>
	<para>
	 the end points of the line segment
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </sect2>

   <sect2>
    <title>Box</title>

    <indexterm>
     <primary>box (data type)</primary>
    </indexterm>

    <para>
     Boxes are represented by pairs of points that are opposite
     corners of the box.
     <type>box</type> is specified using the following syntax:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )  
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     where the arguments are

     <variablelist>
      <varlistentry>
       <term>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</term>
       <term>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</term>
       <listitem>
	<para>
	 opposite corners of the box
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para>
     Boxes are output using the first syntax.
     The corners are reordered on input to store
     the upper right corner, then the lower left corner.
     Other corners of the box can be entered, but the lower
     left and upper right corners are determined from the input and stored corners.
    </para>
   </sect2>

   <sect2>
    <title>Path</title>

    <indexterm>
     <primary>path (data type)</primary>
    </indexterm>

    <para>
     Paths are represented by connected sets of points. Paths can be
     <firstterm>open</firstterm>, where
     the first and last points in the set are not connected, and <firstterm>closed</firstterm>,
     where the first and last point are connected. Functions
     <function>popen(p)</function>
     and
     <function>pclose(p)</function>
     are supplied to force a path to be open or closed, and functions
     <function>isopen(p)</function>
     and
     <function>isclosed(p)</function>
     are supplied to test for either type in a query.
    </para>

    <para>
     <type>path</type> is specified using the following syntax:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )  
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )  
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>    
</synopsis>

     where the arguments are

     <variablelist>
      <varlistentry>
       <term>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</term>
       <listitem>
	<para>
	 End points of the line segments comprising the path.
	 A leading square bracket (<literal>[</>) indicates an open path, while
	 a leading parenthesis (<literal>(</>) indicates a closed path.
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para>
     Paths are output using the first syntax.
    </para>
   </sect2>

   <sect2>
    <title>Polygon</title>

    <indexterm>
     <primary>polygon</primary>
    </indexterm>

    <para>
     Polygons are represented by sets of points. Polygons should probably be
     considered equivalent to closed paths, but are stored differently 
     and have their own set of support routines.
    </para>

    <para>
     <type>polygon</type> is specified using the following syntax:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )  
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )  
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>    
</synopsis>

     where the arguments are

     <variablelist>
      <varlistentry>
       <term>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</term>
       <listitem>
	<para>
	 End points of the line segments comprising the boundary of the
	 polygon
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para>
     Polygons are output using the first syntax.
    </para>
   </sect2>

   <sect2>
    <title>Circle</title>

    <indexterm>
     <primary>circle</primary>
    </indexterm>

    <para>
     Circles are represented by a center point and a radius.
     <type>circle</type> is specified using the following syntax:

<synopsis>
&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> &gt;
( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> )
  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable>  
    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , <replaceable>r</replaceable>  
</synopsis>

     where the arguments are

     <variablelist>
      <varlistentry>
       <term>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</term>
       <listitem>
	<para>
	 center of the circle
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable>r</replaceable></term>
       <listitem>
	<para>
	 radius of the circle
	</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

    <para>
     Circles are output using the first syntax.
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-net-types">
   <title>Network Address Data Types</title>

   <indexterm zone="datatype-net-types">
    <primary>network</primary>
    <secondary>addresses</secondary>
   </indexterm>

   <para>
    <productname>PostgreSQL</> offers data types to store IP and MAC
    addresses, shown in <xref linkend="datatype-net-types-table">.  It
    is preferable to use these types over plain text types, because
    these types offer input error checking and several specialized
    operators and functions.
   </para>

    <table tocentry="1" id="datatype-net-types-table">
     <title>Network Address Data Types</title>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Name</entry>
	<entry>Storage</entry>
	<entry>Description</entry>
	<entry>Range</entry>
       </row>
      </thead>
      <tbody>

       <row>
	<entry><type>cidr</type></entry>
	<entry>12 bytes</entry>
	<entry>IP networks</entry>
	<entry>valid IPv4 networks</entry>
       </row>

       <row>
	<entry><type>inet</type></entry>
	<entry>12 bytes</entry>
	<entry>IP hosts and networks</entry>
	<entry>valid IPv4 hosts or networks</entry>
       </row>

       <row>
	<entry><type>macaddr</type></entry>
	<entry>6 bytes</entry>
	<entry>MAC addresses</entry>
	<entry>customary formats</entry>
       </row>

      </tbody>
     </tgroup>
    </table>

   <para>
    IPv6 is not yet supported.
   </para>


   <sect2 id="datatype-inet">
    <title><type>inet</type></title>

    <indexterm>
     <primary>inet (data type)</primary>
    </indexterm>

    <para>
     The <type>inet</type> type holds an IP host address, and
     optionally the identity of the subnet it is in, all in one field.
     The subnet identity is represented by the number of bits in the
     network part of the address (the <quote>netmask</quote>).  If the
     netmask is 32, 
     then the value does not indicate a subnet, only a single host.
     Note that if you want to accept networks only, you should use the
     <type>cidr</type> type rather than <type>inet</type>.
    </para>

    <para>
     The input format for this type is <replaceable
     class="parameter">x.x.x.x/y</replaceable> where <replaceable
     class="parameter">x.x.x.x</replaceable> is an IP address and
     <replaceable class="parameter">y</replaceable> is the number of
     bits in the netmask.  If the <replaceable
     class="parameter">/y</replaceable> part is left off, then the
     netmask is 32, and the value represents just a single host.
     On display, the <replaceable class="parameter">/y</replaceable>
     portion is suppressed if the netmask is 32.
    </para>
   </sect2>

   <sect2 id="datatype-cidr">
    <title><type>cidr</></title>

    <indexterm>
     <primary>cidr</primary>
    </indexterm>

    <para>
     The <type>cidr</type> type holds an IP network specification.
     Input and output formats follow Classless Internet Domain Routing
     conventions.
     The format for
     specifying classless networks is <replaceable
     class="parameter">x.x.x.x/y</> where <replaceable
     class="parameter">x.x.x.x</> is the network and <replaceable
     class="parameter">y</> is the number of bits in the netmask.  If
     <replaceable class="parameter">y</> is omitted, it is calculated
     using assumptions from the older classful numbering system, except
     that it will be at least large enough to include all of the octets
     written in the input.
    </para>

    <para>
     <xref linkend="datatype-net-cidr-table"> shows some examples.
    </para>

     <table id="datatype-net-cidr-table">
      <title><type>cidr</> Type Input Examples</title>
      <tgroup cols="3">
       <thead> 
	<row> 
	 <entry><type>CIDR</type> Input</entry>
	 <entry><type>CIDR</type> Displayed</entry>
	 <entry><function>abbrev</function>(<type>CIDR</type>)</entry>
	</row>
       </thead>
       <tbody>
	<row>
	 <entry>192.168.100.128/25</entry>
	 <entry>192.168.100.128/25</entry>
	 <entry>192.168.100.128/25</entry>
	</row>
	<row>
	 <entry>192.168/24</entry>
	 <entry>192.168.0.0/24</entry>
	 <entry>192.168.0/24</entry>
	</row>
	<row>
	 <entry>192.168/25</entry>
	 <entry>192.168.0.0/25</entry>
	 <entry>192.168.0.0/25</entry>
	</row>
	<row>
	 <entry>192.168.1</entry>
	 <entry>192.168.1.0/24</entry>
	 <entry>192.168.1/24</entry>
	</row>
	<row>
	 <entry>192.168</entry>
	 <entry>192.168.0.0/24</entry>
	 <entry>192.168.0/24</entry>
	</row>
	<row>
	 <entry>128.1</entry>
	 <entry>128.1.0.0/16</entry>
	 <entry>128.1/16</entry>
	</row>
	<row>
	 <entry>128</entry>
	 <entry>128.0.0.0/16</entry>
	 <entry>128.0/16</entry>
	</row>
	<row>
	 <entry>128.1.2</entry>
	 <entry>128.1.2.0/24</entry>
	 <entry>128.1.2/24</entry>
	</row>
	<row>
	 <entry>10.1.2</entry>
	 <entry>10.1.2.0/24</entry>
	 <entry>10.1.2/24</entry>
	</row>
	<row>
	 <entry>10.1</entry>
	 <entry>10.1.0.0/16</entry>
	 <entry>10.1/16</entry>
	</row>
	<row>
	 <entry>10</entry>
	 <entry>10.0.0.0/8</entry>
	 <entry>10/8</entry>
	</row>
       </tbody>
      </tgroup>
     </table>
   </sect2>

   <sect2 id="datatype-inet-vs-cidr">
    <title><type>inet</type> vs <type>cidr</type></title>

    <para>
    The essential difference between <type>inet</type> and <type>cidr</type>
    data types is that <type>inet</type> accepts values with nonzero bits to
    the right of the netmask, whereas <type>cidr</type> does not.

      <tip>
        <para>
	If you do not like the output format for <type>inet</type> or
	<type>cidr</type> values, try the <function>host</>(),
	<function>text</>(), and <function>abbrev</>() functions.
	</para>
      </tip>
    </para>
   </sect2>

   <sect2 id="datatype-macaddr">
    <title><type>macaddr</></>

    <indexterm>
     <primary>macaddr (data type)</primary>
    </indexterm>

    <indexterm>
     <primary>MAC address</primary>
     <see>macaddr</see>
    </indexterm>

    <para>
     The <type>macaddr</> type stores MAC addresses, i.e., Ethernet
     card hardware addresses (although MAC addresses are used for
     other purposes as well).  Input is accepted in various customary
     formats, including

     <simplelist>
      <member><literal>'08002b:010203'</></member>
      <member><literal>'08002b-010203'</></member>
      <member><literal>'0800.2b01.0203'</></member>
      <member><literal>'08-00-2b-01-02-03'</></member>
      <member><literal>'08:00:2b:01:02:03'</></member>
     </simplelist>

     which would all specify the same
     address.  Upper and lower case is accepted for the digits
     <literal>a</> through <literal>f</>.  Output is always in the
     last of the shown forms.
    </para>

    <para>
     The directory <filename class="directory">contrib/mac</filename>
     in the <productname>PostgreSQL</productname> source distribution
     contains tools that can be used to map MAC addresses to hardware
     manufacturer names.
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-bit">
   <title>Bit String Types</title>

   <indexterm zone="datatype-bit">
    <primary>bit strings</primary>
    <secondary>data type</secondary>
   </indexterm>

   <para>
    Bit strings are strings of 1's and 0's.  They can be used to store
    or visualize bit masks.  There are two SQL bit types:
    <type>BIT(<replaceable>n</replaceable>)</type> and <type>BIT
    VARYING(<replaceable>n</replaceable>)</type>, where
    <replaceable>n</replaceable> is a positive integer.
   </para>

   <para>
    <type>BIT</type> type data must match the length
    <replaceable>n</replaceable> exactly; it is an error to attempt to
    store shorter or longer bit strings.  <type>BIT VARYING</type> data is
    of variable length up to the maximum length
    <replaceable>n</replaceable>; longer strings will be rejected.
    Writing <type>BIT</type> without a length is equivalent to
    <literal>BIT(1)</literal>, while <type>BIT VARYING</type> without a length
    specification means unlimited length.
   </para>

   <note>
    <para>
     If one explicitly casts a bit-string value to
     <type>BIT(<replaceable>n</>)</type>, it will be truncated or
     zero-padded on the right to be exactly <replaceable>n</> bits,
     without raising an error.  Similarly,
     if one explicitly casts a bit-string value to
     <type>BIT VARYING(<replaceable>n</>)</type>, it will be truncated
     on the right if it is more than <replaceable>n</> bits.
    </para>
   </note>

   <note>
    <para>
     Prior to <productname>PostgreSQL</> 7.2, <type>BIT</type> data
     was always silently truncated or zero-padded on the right, with
     or without an explicit cast. This was changed to comply with the
     <acronym>SQL</acronym> standard.
    </para>
   </note>

   <para>
    Refer to <xref
    linkend="sql-syntax-bit-strings"> for information about the syntax
    of bit string constants.  Bit-logical operators and string
    manipulation functions are available; see <xref
    linkend="functions">.
   </para>

   <example>
    <title>Using the bit string types</title>

<programlisting>
CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
<computeroutput>
ERROR:  Bit string length 2 does not match type BIT(3)
</computeroutput>
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
<computeroutput>
  a  |  b
-----+-----
 101 | 00
 100 | 101
</computeroutput>
</programlisting>
   </example>

  </sect1>

  <sect1 id="datatype-oid">
   <title>Object Identifier Types</title>

   <indexterm zone="datatype-oid">
    <primary>object identifier</primary>
    <secondary>data type</secondary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>oid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regproc</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regprocedure</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regoper</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regoperator</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regclass</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>regtype</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>xid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>cid</primary>
   </indexterm>

   <indexterm zone="datatype-oid">
    <primary>tid</primary>
   </indexterm>

   <para>
    Object identifiers (OIDs) are used internally by
    <productname>PostgreSQL</productname> as primary keys for various system
    tables.  Also, an OID system column is added to user-created tables
    (unless <literal>WITHOUT OIDS</> is specified at table creation time).
    Type <type>oid</> represents an object identifier.  There are also
    several aliases for <type>oid</>: <type>regproc</>, <type>regprocedure</>,
    <type>regoper</>, <type>regoperator</>, <type>regclass</>,
    and <type>regtype</>. <xref linkend="datatype-oid-table"> shows an overview.
   </para>

   <para>
    The <type>oid</> type is currently implemented as an unsigned four-byte
    integer.
    Therefore, it is not large enough to provide database-wide uniqueness
    in large databases, or even in large individual tables.  So, using a
    user-created table's OID column as a primary key is discouraged.
    OIDs are best used only for references to system tables.
   </para>

   <para>
    The <type>oid</> type itself has few operations beyond comparison
    (which is implemented as unsigned comparison).  It can be cast to
    integer, however, and then manipulated using the standard integer
    operators.  (Beware of possible signed-versus-unsigned confusion
    if you do this.)
   </para>

   <para>
    The  <type>oid</> alias types have no operations of their own except
    for specialized input and output routines.  These routines are able
    to accept and display symbolic names for system objects, rather than
    the raw numeric value that type <type>oid</> would use.  The alias
    types allow simplified lookup of OID values for objects: for example,
    one may write <literal>'mytable'::regclass</> to get the OID of table
    <literal>mytable</>, rather than <literal>SELECT oid FROM pg_class WHERE
    relname = 'mytable'</>.  (In reality, a much more complicated <command>SELECT</> would
    be needed to deal with selecting the right OID when there are multiple
    tables named <literal>mytable</> in different schemas.)
   </para>

    <table id="datatype-oid-table">
     <title>Object Identifier Types</title>
     <tgroup cols="4">
      <thead>
       <row>
	<entry>Type name</entry>
	<entry>References</entry>
	<entry>Description</entry>
	<entry>Value example</entry>
       </row>
      </thead>

      <tbody>

       <row>
	<entry><type>oid</></entry>
	<entry>any</entry>
	<entry>numeric object identifier</entry>
	<entry><literal>564182</></entry>
       </row>

       <row>
	<entry><type>regproc</></entry>
	<entry><structname>pg_proc</></entry>
	<entry>function name</entry>
	<entry><literal>sum</></entry>
       </row>

       <row>
	<entry><type>regprocedure</></entry>
	<entry><structname>pg_proc</></entry>
	<entry>function with argument types</entry>
	<entry><literal>sum(int4)</></entry>
       </row>

       <row>
	<entry><type>regoper</></entry>
	<entry><structname>pg_operator</></entry>
	<entry>operator name</entry>
	<entry><literal>+</></entry>
       </row>

       <row>
	<entry><type>regoperator</></entry>
	<entry><structname>pg_operator</></entry>
	<entry>operator with argument types</entry>
	<entry><literal>*(integer,integer)</> or <literal>-(NONE,integer)</></entry>
       </row>

       <row>
	<entry><type>regclass</></entry>
	<entry><structname>pg_class</></entry>
	<entry>relation name</entry>
	<entry><literal>pg_type</></entry>
       </row>

       <row>
	<entry><type>regtype</></entry>
	<entry><structname>pg_type</></entry>
	<entry>type name</entry>
	<entry><literal>integer</></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    All of the OID alias types accept schema-qualified names, and will
    display schema-qualified names on output if the object would not
    be found in the current search path without being qualified.
    The <type>regproc</> and <type>regoper</> alias types will only
    accept input names that are unique (not overloaded), so they are
    of limited use; for most uses <type>regprocedure</> or
    <type>regoperator</> is more appropriate.  For <type>regoperator</>,
    unary operators are identified by writing <literal>NONE</> for the unused
    operand.
   </para>

   <para>
    OIDs are 32-bit quantities and are assigned from a single cluster-wide
    counter.  In a large or long-lived database, it is possible for the
    counter to wrap around.  Hence, it is bad practice to assume that OIDs
    are unique, unless you take steps to ensure that they are unique.
    Recommended practice when using OIDs for row identification is to create
    a unique constraint on the OID column of each table for which the OID will
    be used.  Never assume that OIDs are unique across tables; use the
    combination of <structfield>tableoid</> and row OID if you need a
    database-wide identifier.  (Future releases of
    <productname>PostgreSQL</productname> are likely to use a separate
    OID counter for each table, so that <structfield>tableoid</>
    <emphasis>must</> be included to arrive at a globally unique identifier.)
   </para>

   <para>
    Another identifier type used by the system is <type>xid</>, or transaction
    (abbreviated <abbrev>xact</>) identifier.  This is the data type of the system columns
    <structfield>xmin</> and <structfield>xmax</>.
    Transaction identifiers are 32-bit quantities.  In a long-lived
    database it is possible for transaction IDs to wrap around.  This
    is not a fatal problem given appropriate maintenance procedures;
    see the &cite-admin; for details.  However, it is
    unwise to depend on uniqueness of transaction IDs over the long term
    (more than one billion transactions).
   </para>

   <para>
    A third identifier type used by the system is <type>cid</>, or
    command identifier.  This is the data type of the system columns
    <structfield>cmin</> and <structfield>cmax</>.  Command
    identifiers are also 32-bit quantities.  This creates a hard limit
    of 2<superscript>32</> (4 billion) <acronym>SQL</acronym> commands
    within a single transaction.  In practice this limit is not a
    problem --- note that the limit is on number of
    <acronym>SQL</acronym> commands, not number of tuples processed.
   </para>

   <para>
    A final identifier type used by the system is <type>tid</>, or tuple
    identifier.  This is the data type of the system column
    <structfield>ctid</>.  A tuple ID is a pair
    (block number, tuple index within block) that identifies the
    physical location of the tuple within its table.
   </para>

  </sect1>

  <sect1 id="datatype-pseudo">
   <title>Pseudo-Types</title>

   <indexterm zone="datatype-pseudo">
    <primary>record</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>any</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>anyarray</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>void</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>trigger</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>language_handler</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>cstring</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>internal</primary>
   </indexterm>

   <indexterm zone="datatype-pseudo">
    <primary>opaque</primary>
   </indexterm>

   <para>
    The <productname>PostgreSQL</productname> type system contains a
    number of special-purpose entries that are collectively called
    <firstterm>pseudo-types</>.  A pseudo-type cannot be used as a
    column data type, but it can be used to declare a function's
    argument or result type.  Each of the available pseudo-types is
    useful in situations where a function's behavior does not
    correspond to simply taking or returning a value of a specific
    <acronym>SQL</acronym> data type.  <xref
    linkend="datatype-pseudotypes-table"> lists the existing
    pseudo-types.
   </para>

    <table id="datatype-pseudotypes-table">
     <title>Pseudo-Types</title>
     <tgroup cols="2">
      <thead>
       <row>
	<entry>Type name</entry>
	<entry>Description</entry>
       </row>
      </thead>

      <tbody>

       <row>
	<entry><type>record</></entry>
	<entry>Identifies a function returning an unspecified row type</entry>
       </row>

       <row>
	<entry><type>any</></entry>
	<entry>Indicates that a function accepts any input data type whatever</entry>
       </row>

       <row>
	<entry><type>anyarray</></entry>
	<entry>Indicates that a function accepts any array data type</entry>
       </row>

       <row>
	<entry><type>void</></entry>
	<entry>Indicates that a function returns no value</entry>
       </row>

       <row>
	<entry><type>trigger</></entry>
	<entry>A trigger function is declared to return <type>trigger</></entry>
       </row>

       <row>
	<entry><type>language_handler</></entry>
	<entry>A procedural language call handler is declared to return <type>language_handler</></entry>
       </row>

       <row>
	<entry><type>cstring</></entry>
	<entry>Indicates that a function accepts or returns a null-terminated C string</entry>
       </row>

       <row>
	<entry><type>internal</></entry>
	<entry>Indicates that a function accepts or returns a server-internal
	data type</entry>
       </row>

       <row>
	<entry><type>opaque</></entry>
	<entry>An obsolete type name that formerly served all the above purposes</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Functions coded in C (whether built-in or dynamically loaded) may be
    declared to accept or return any of these pseudo data types.  It is up to
    the function author to ensure that the function will behave safely
    when a pseudo-type is used as an argument type.
   </para>

   <para>
    Functions coded in procedural languages may use pseudo-types only as
    allowed by their implementation languages.  At present the procedural
    languages all forbid use of a pseudo-type as argument type, and allow
    only <type>void</> as a result type (plus <type>trigger</> when the
    function is used as a trigger).
   </para>

   <para>
    The <type>internal</> pseudo-type is used to declare functions
    that are meant only to be called internally by the database
    system, and not by direct invocation in a <acronym>SQL</acronym>
    query.  If a function has at least one <type>internal</>-type
    argument then it cannot be called from <acronym>SQL</acronym>.  To
    preserve the type safety of this restriction it is important to
    follow this coding rule: do not create any function that is
    declared to return <type>internal</> unless it has at least one
    <type>internal</> argument.
   </para>

  </sect1>

  &array;

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-tabs-mode:nil
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/share/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
