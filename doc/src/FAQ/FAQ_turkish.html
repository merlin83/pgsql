<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf8">
	<title>PostgreSQL Sıkça Sorulan Sorular - Türkçe</title>
	<style type="text/css"><!--
	body { background: #FFFFFF; }
	a:link { color: #ff0000; }
	a:active { color: #0000ff; }
	a:visited { color: #a00000; }
	i { font-style: oblique; }
	body, h1, h2, h4, ul, p, a { font-family: helvetica, arial, sans-serif; font-size: medium; color: black; }
	pre { color: #5C5C5C; padding-left: 30px; }
	.fixme { color: cyan; }
	--></style>
</head>
<body bgcolor="#ffffff" text="#000000" link="#ff0000" vlink="#a00000" alink="#0000ff">

<h1>PostgreSQL için Sıkça Sorulan Sorular (SSS)</h1>
<p>Son güncelleme : 15 Kasım 2004 Pazartesi - 15:03:23</p>
<p>Current maintainer: Bruce Momjian
(<a href="mailto:pgman@candle.pha.pa.us">pgman@candle.pha.pa.us</a>)<br></p>
<p>Çevirenler : Devrim Gündüz (<a href="mailto:devrim@tdmsoft.com">devrim@tdmsoft.com</a>)<br>Nicolai Tufar 
(<a href="mailto:ntufar@tdmsoft.com">ntufar@tdmsoft.com</a>)<BR>Volkan YAZICI (<a href="mailto:volkany@phreaker.net">volkany@phreaker.net</a>)</p>
<p>Bu belgenin en güncel hali, <a href="http://www.postgresql.org/docs/faqs/FAQ_turkish.html">http://www.PostgreSQL.org/docs/faqs/FAQ_turkish.html</a> 
ve <a href="http://www.gunduz.org/seminer/pg/FAQ_turkish.html">http://www.gunduz.org/seminer/pg/FAQ_turkish.html</a> 
adreslerinde görülebilir.</p>
<p>Platforma özel sorularınız, <a href="http://www.postgresql.org/docs/index.html">http://www.PostgreSQL.org/docs/index.html</a> adresinde yanıtlanır.</p>

<hr>

<h2 align="center">Genel Sorular</h2>
	<a href="#1.1">1.1</a>) PostgreSQL nedir? Nasıl okunur?<br>
	<a href="#1.2">1.2</a>) PostgreSQL'in hakları nedir?<br>
	<a href="#1.3">1.3</a>) PostgreSQL, hangi Unix platformlarında çalışır?<br>
	<a href="#1.4">1.4</a>) Hangi Unix olmayan uyarlamaları bulunmaktadır?<br>
	<a href="#1.5">1.5</a>) PostgreSQL'i nereden indirebilirim?<br>
	<a href="#1.6">1.6</a>) Desteği nereden alabilirim?<br>
	<a href="#1.7">1.7</a>) En son sürümü nedir?<br>
	<a href="#1.8">1.8</a>) Hangi belgelere ulaşabilirim?<br>
	<a href="#1.9">1.9</a>) Bilinen hatalar ya da eksik özelliklere nereden ulasabilirim?<br>
	<a href="#1.10">1.10</a>) Nasıl <small>SQL</small> öğrenebilirim?<br>
	<a href="#1.11">1.11</a>) PostgreSQL 2000 yılına uyumlu mudur?<br>
	<a href="#1.12">1.12</a>) Geliştirme takımına nasıl katılabilirim??<br>
	<a href="#1.13">1.13</a>) Bir hata raporunu nasıl gönderebilirim?<br>
	<a href="#1.14">1.14</a>) PostgreSQL, diğer <small>VTYS(DBMS)</small> lerle nasıl
	karşılaştırılabilir?<br>
	<a href="#1.15">1.15</a>) PostgreSQL'e maddi açıdan nasıl destek olabilirim?<br>
	
<h2 align="center">Kullanıcı/istemci Soruları</h2>
	<a href="#2.1">2.1</a>) PostgreSQL için <i>ODBC</i> sürücüleri var mı?<br>
	<a href="#2.2">2.2</a>) PostgreSQL'i web sayfalarında kullanabilmek için
	hangi araçlar bulunmaktadır?<br>
	<a href="#2.3">2.3</a>) PostgreSQL'in grafik kullanıcı arabirimi var mıdır?<br>
	<a href="#2.4">2.4</a>) PostgreSQL ile iletişimi kurabilmek için
	hangi dilleri kullanabilirim? <br>
	
<h2 align="center">Yönetimsel Sorular</h2>
	<a href="#3.1">3.1</a>) PostgreSQL'i <code>/usr/local/pgsql</code> dizininden
	başka dizinlere nasıl kurabilirim?<br>
	<a href="#3.2">3.2</a>) <i>Postmaster</i>'ı başlattığımda <code>Bad System Call</code>
	ya da <code>core dumped</code> mesajı alıyorum. Neden?<br>
	<a href="#3.3">3.3</a>) <i>Postmaster</i>'ı başlattığımda, <code>IpcMemoryCreate</code>
	hatası alıyorum. Neden?<br>
	<a href="#3.4">3.4</a>) <i>Postmaster</i>'ı, başlattığımda, <code>IpcSemaphoreCreate</code>
	hatası alıyorum. Neden?<br>
	<a href="#3.5">3.5</a>) Diğer bilgisayarların benim PostgreSQL veritabanı
	sunucuma bağlantılarını nasıl kontrol edebilirim?<br>
	<a href="#3.6">3.6</a>) Veritabanı motorunu daha iyi başarım icin nasıl ayarlayabilirim?<br>
	<a href="#3.7">3.7</a>) Hangi hata ayıklama özellikleri bulunmaktadır?<br>
	<a href="#3.8">3.8</a>) Bağlanmaya çalışırken, neden "<code>Sorry, too many clients</code>"
	hatasını alıyorum. Neden?<br>
	<a href="#3.9">3.9</a>) <code>pgsql_tmp</code>dizinin içindeki dosyalar nelerdir?<br>
	<a href="#3.10">3.10</a>) PostgreSQL sürümlerini yükseltmek için neden bir
	<code>dump/reload</code> işlemi gerçekleştirmek zorundayım?<br>
	<a href="#3.11">3.11</a>) Nasıl bir donanım kullanmalıyım?br>
	
<h2 align="center">İşletimsel Sorular</h2>
	<a href="#4.1">4.1</a>) <i>Binary cursor</i> ve <i>normal cursor</i> arasındaki fark nedır?<br>
	<a href="#4.2">4.2</a>) Sorgunun sadece ilk birkaç satırını nasıl
	<code>SELECT</code> edebilirim?<br>
	<a href="#4.3">4.3</a>) <i>psql</i>'in içinde gördügüm tabloların ya da diğer
	şeylerin listesini nasıl alabilirim?<br>
	<a href="#4.4">4.4</a>) Bir tablodan bir kolonu nasıl kaldırabilirim?<br>
	<a href="#4.5">4.5</a>) Bir satır, tablo ve veritabanı için en fazla büyüklük nedir?<br>
	<a href="#4.6">4.6</a>) Tipik bir metin dosyasındaki veriyi saklamak için ne
	kadar disk alanı gereklidir?<br>
	<a href="#4.7">4.7</a>) Veritabanında hangi tablo ya da <i>index</i>'lerin
	tanımlandığını nasıl görebilirim?<br>
	<a href="#4.8">4.8</a>) Sorgularım cok yavaş, ya da <i>index</i>'lerimi kullanmıyorlar. Neden?<br>
	<a href="#4.9">4.9</a>) <i>Query-optimizer</i>'ın sorgularımı nasıl değerlendirdiğini,
	işleme soktuğunu nasıl görebilirim?<br>
	<a href="#4.10">4.10</a>) <i>R-tree index</i> nedir?<br>
	<a href="#4.11">4.11</a>) <i>Genetic Query Optimizer</i> nedir?<br>
	<a href="#4.12">4.12</a>) Düzenli ifade (<i>Regular Expression</i>) aramalarını
	ve büyük/küçük harfe duyarsız aramaları nasıl yapabilirim? Bu büyük/küçük harfe duyarlı
	aramalar için <i>index</i>'i nasıl kullanabilirim?<br>
	<a href="#4.13">4.13</a>) Bir sorguda, bir alanın <code>NULL</code> olduğunu nasıl
	ortaya çıkarabilirim?<br>
	<a href="#4.14">4.14</a>) Çesitli karakter tipleri arasındaki farklar nelerdir?<br>
	<a href="#4.15.1">4.15.1</a>) Nasıl <code>serial</code>/otomatik artan
	(<i>auto-incrementing</i>) bir alan yaratabilirim?<br>
	<a href="#4.15.2">4.15.2</a>) <code>Serial</code> girişinin değerini nasıl alabilirim?<br>
	<a href="#4.15.3">4.15.3</a>) <code>currval()</code> ve  <code>nextval()</code>
	diğer kullanıcılara sorun yaratmaz mı?<br>
	<a href="#4.15.4">4.15.4</a>) Neden sequence sayıların <i>transaction</i>
	işleminin iptalinden sonra yeniden kullanılıyor? Neden <code>sequence/SERIAL</code>
	kolonumdaki sayılarda atlamalar oluyor?<br>
	<a href="#4.16">4.16</a>) <code>OID</code> nedir? <code>TID</code> nedir?<br>
	<a href="#4.17">4.17</a>) PostgreSQL' de kullanılan bazı terimlerin anlamları nelerdir?<br>
	<a href="#4.18">4.18</a>) Neden "<code>ERROR: Memory exhausted in AllocSetAlloc()</code>"
	hatasını alıyorum?<br>
	<a href="#4.19">4.19</a>) Hangi PostgreSQL sürümünü çalıstırdığımı nasıl görebilirim?<br>
	<a href="#4.20">4.20</a>) Neden <i>large-object</i> işlemlerim, "<code>invalid large
	obj descriptor</code>" hatasını veriyor?<br>
	<a href="#4.21">4.21</a>) Şu andaki zamanı öntanımlı değer olarak kabul
	eden kolonu nasıl yaratırım?<br>
	<a href="#4.22">4.22</a>) Neden <code>IN</code> kullanan <i>subquery</i>'lerim çok yavaş?<br>
	<a href="#4.23">4.23</a>) <i>Outer join</i> işlemini nasıl yapabilirim?<br>
	<a href="#4.24">4.24</a>) Aynı anda birden fazla veritabanında nasıl işlem yapabilirim?<br>
	<a href="#4.25">4.25</a>) Bir fonksiyondan nasıl çoklu satır ya da kolon döndürebilirim?<br>
	<a href="#4.26">4.26</a>) Neden Pl/PgSQL fonksiyonları içinden güvenli
	bir şekilde tablo yaratma/kaldırma işlemlerini yapamıyoruz?<br>
	<a href="#4.27">4.27</a>) Hangi şifreleme seçenekleri bulunmaktadır?<br>
	

<h2 align="center">PostgreSQL Özelliklerini Genişletmek</h2>
	<a href="#5.1">5.1</a>) Kullanıcı-tanımlı bir fonksiyon yazdım. <i>psql</i>'de
	çalıştırdığım zaman neden <code>core dump</code> ediyor?<br>
	<a href="#5.2">5.2</a>) PostgreSQL'e nasıl yeni veri tipleri/fonksiyonlar ekleyebilirim?<br>
	<a href="#5.3">5.3</a>) Bir tuple döndürmek için bir C fonksiyonunu nasıl yazarım?<br>
	<a href="#5.4">5.4</a>) Bir kaynak dosyasında değişiklik yaptım.
	Yeniden derlememe rağmen değişiklik geçerli olmuyor. Neden?<br>
	
    <hr>

	<h2 align="center">Genel Sorular</h2>

		<h4><a name="1.1">1.1</a>) PostgreSQL nedir? Nasıl okunur?</h4>
		<p>PostgreSQL, <i>Post-Gres-Q-L</i>. olarak okunur</p>
		<p>PostgreSQL, yeni-nesil <small>VTYS</small> araştırma prototipi olan POSTGRES
		veritabanı yönetim sisteminin geliştirilmesidir. POSTGRES'in zengin veri tiplerini ve
		güçlü veri modelini tutarken, <small>SQL</small>'in geliştirilmiş alt kümesi 
		olan PostQuel dilini kullanır. PostgreSQL ücretsizdir ve kaynak kodu açık dağıtılır.</p>
		<p>PostgreSQL, PostgreSQL geliştirme listesine üye olan bir Internet geliştirici
		takımı tarafından geliştirilir. Şu andaki koordinatör, Marc G. Fournier 
		(<a href="mailto:scrappy@PostgreSQL.org">scrappy@PostgreSQL.org</a>). 
		(Bu takıma nasıl katılacagınızı öğrenmek için <a href="#1.6">1.6</a> numaralı maddeyi
		okuyunuz.) Bu takım, tüm PostgreSQL gelişiminden sorumludur.</p>
		<p>PostgreSQL 1.01 sürümünün yazarları Andrew Yu ve Jolly Chen idi. Bunların dışında
		bir kaç kisi de uyarlama, hata ayıklama ve kodun geliştirilmesi için çalısmıştı.
		PostgreSQL'in türediği orijinal Postgres kodu, lisans, lisansüstü ve akademisyenler
		tarafından, Professor Michael Stonebraker (University of California, Berkeley)
		koordinatörlügünde yazılmıştır.</p>
		<p>Berkley'deki yazılımın adı Postgres idi. <small>SQL</small> uyumluluğu
		1995'te eklenince, adı Postgres 95 oldu. 1996 yılının sonlarında adı
		PostgreSQL olarak değiştirildi.</p>
		
		<h4><a name="1.2">1.2</a>) PostgreSQL'in hakları nedir?</h4>
		<p>PostgreSQL Data Base Management System</p>

                <P>Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group
                Portions Copyright (c) 1994-6 Regents of the University of California</P>

		<p>Permission to use, copy, modify, and distribute this software
		and its documentation for any purpose, without fee, and without a
		written agreement is hereby granted, provided that the above
		copyright notice and this paragraph and the following two
		paragraphs appear in all copies.</p>
		<p>IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY
		PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
		DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS
		SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
		CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
		<p>THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
		WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
		OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
		SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE
		UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE,
		SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.</p>
		<p>Üstteki metin klasik açık-kod lisansı olan BSD lisansıdır. Kaynak kodun nasıl 
		kullanılabileceğine dair sınırlamaları yoktur. Bu lisansı seviyoruz. Değiştirme 
		niyetimiz bulunmamaktadır.</p>
		
		<h4><a name="1.3">1.3</a>) PostgreSQL, hangi Unix platforlarında çalışır?</h4>
		<p>Genel olarak, modern bir Unix-uyumlu platform PostgreSQL'i çalıştıracaktır.
		Ayrıntılı bilgi için kurulum belgelerine bakabilirsiniz.</p>
		
		<h4><a name="1.4">1.4</a>) Hangi Unix olmayan uyarlamaları bulunmaktadır?</h4>
	        <P>PostgreSQL 8.0 sürümü ile , PostgreSQL artık Win2000, WinXP ve Win2003 gibi Microsoft 
		Windows NT tabanlı işletim sistemlerinde doğal olarak çalışmaya başlamıştır. Paketlenmiş bir
		kurulum programı, <a href="http://pgfoundry.org/projects/pginstaller">http://pgfoundry.org/projects/pginstaller</a>. adresinden 
		indirilebilir.</P>

		<p>Ayrıca, http://forge.novell.com adresinde Novell Netware 6 portu bulunmaktadır.</p>
		
		<h4><a name="1.5">1.5</a>) PostgreSQL'i nereden indirebilirim?</h4>
		<p>PostgreSQL için ana anonim ftp sitesi <i><a href="ftp://ftp.PostgreSQL.org/pub">ftp://ftp.PostgreSQL.org/pub</a></i>
		adresidir. Yansılar için, ana web sayfamıza bakabilirsiniz.</p>
		
		<h4><a name="1.6">1.6</a>) Nereden destek alabilirim?</h4>
		<p>Ana e-posta listesi : pgsql-general@PostgreSQL.org. PostgreSQL konusundaki tartışmalara
		açıktır. Üye olmak için, aşağıdaki satırları e-postanızın <i>body</i> kısmına
		(konu kısmına değil) yazıp, pgsql-general-request@PostgreSQL.org adresine gönderin:</p>
		<pre>subscribe<br>end</pre>
		<p>Aynı zamanda, bir <i>digest</i> listesi bulunmaktadır. Bu listeye üye olmak için, 
		pgsql-general-digest-request@PostgreSQL.org adresine, body kısmında</p>
		<pre>subscribe<br>end</pre>
		<p>yazan bir e-posta atmanız yeterli olacaktır.</p>
		<p><i>Digest</i> postalar, ana liste 30k civarında e-postaya ulaştığında
		üyelere gönderilmektedir.</p>
		<p><i>Bug</i>'lar için bir e-posta listesi bulunmaktadır. Bu listeye üye olmak için,
		pgsql-bugs-request@PostgreSQL.org adresine, <i>body</i> kısmında</p>
		<pre>subscribe<br>end</pre>
		<p>yazan bir e-posta atmanız yeterli olacaktır.</p>
		<p>Aynı zamanda, geliştiriciler için tartışma listesi bulunmaktadır. Bu listeye
		üye olmak için, pgsql-hackers-request@PostgreSQL.org adresine, body kısmında</p>
		<pre>subscribe<br>end</pre>
		<p>yazan bir e-posta atmanız yeterli olacaktır.</p>
		<p>Bunun dışındaki e-posta listelerine ve PostgreSQL hakkında bilgiye, PostgreSQL WWW 
		ana sayfasından ulasabilirsiniz: <i><a href="http://www.PostgreSQL.org">http://www.PostgreSQL.org</a></i></p>
		<p>Aynı zamanda, EFNet üzerinde, <code>#PostgreSQL</code> adlı bir IRC kanalı
		bulunmaktadır. Bunun için, <code>irc -c '#PostgreSQL' "$USER" irc.phoenix.net</code>
		Unix komutunu kullanabilirsiniz.</p>
		<p>Ticari destek veren firmaların listesine</p>
		<p><i><a href="http://www.postgresql.org/users-lounge/commercial-support.html">http://www.postgresql.org/users-lounge/commercial-support.html</a></i></p>
		<p>adresinden ulaşbilirsiniz.</p>
		
		<h4><a name="1.7">1.7</a>) En son sürüm nedir?</h4>
		<p>PostgreSQL'in son sürümü 7.4.6'dır.</p>
		<p>Her 6-8 ayda <i>ana sürüm</i> çıkarılması planlanmaktadır.</p>

		<h4><a name="1.8">1.8</a>) Hangi belgelere ulaşabilirim?</h4>
		<p>Dağıtımın içinde, kitapçıklar, kitapçık sayfaları ve bazı küçük örnekler verilmektedir.
		<code>/doc</code> dizinine bakınız. Ayrıca, bu el kitapçıklarını online olarak
		<i><a href="http://www.PostgreSQL.org/docs/">http://www.PostgreSQL.org/docs/</a></i> adresinden inceleyebilirsiniz.</p>
		<p><i><a href="http://www.PostgreSQL.org/docs/awbook.html">http://www.PostgreSQL.org/docs/awbook.html</a></i>
		ve <i><a href="http://www.commandprompt.com/ppbook">http://www.commandprompt.com/ppbook</a></i>
		adreslerinde PostgreSQL kitapları bulunmaktadır. PostgreSQL kitablarının listesine, 
		<i><a href="http://www.ca.PostgreSQL.org/books/">http://www.ca.PostgreSQL.org/books/</a></i> adresinden ulaşaiblirsiniz.
		Ayrıca, PostgreSQL konusundaki teknik makalelere de
		<i><a href="http://techdocs.PostgreSQL.org/">http://techdocs.PostgreSQL.org/</a></i> adresinden ulaşabilirsiniz.</p>
		<p>psql'in, \d ile baslayan veri tipler, operatorler, fonksiyonlar,
		<i>aggregate</i>'ler, vb. ile ilgili güzel komutları vardır.</p>
		<p>Web sitemiz daha fazla belgeyi içermektedir.</p>
		
		<h4><a name="1.9">1.9</a>) Bilinen hatalar ya da eksik
		özelliklere nereden ulaşabilirim?</h4>
		<p>PostgreSQL SQL-92 uyumluluğu içindedir, standartlardan fazla da özellikleri
		bulunmaktadır. Bilinen hatalar, eksik özellikler ve gelecek ile ilgili planlar için
		TODO listesine bakınız.</p>
		
		<h4><a name="1.10">1.10</a>) Nasıl <small>SQL</small> öğrenebilirim?</h4>
		<p><i><a href="http:/www.PostgreSQL.org/docs/awbook.html">http:/www.PostgreSQL.org/docs/awbook.html</a></i>
		adresindeki kitap SQL ögretecektir.
		<i><a href="http://www.commandprompt.com/ppbook">http://www.commandprompt.com/ppbook</a></i>
		adresinde de bir baska PostgreSQL kitabı bulunmaktadır.</p>
		<p><i><a href="http://www.intermedia.net/support/sql/sqltut.shtm">http://www.intermedia.net/support/sql/sqltut.shtm</a></i>,
		<i><a href="http://ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM">http://ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM</a></i>
		<i><a href="http://sqlcourse.com">http://sqlcourse.com</a></i>
		ve <i><a href="http://sqlcourse2.com">http://sqlcourse2.com</a></i>
		adreslerinde de güzel belgeler bulunmaktadır.</p>
		<p>Bir başkası da, <i><a href="http://members.tripod.com/er4ebus/sql/index.htm">http://members.tripod.com/er4ebus/sql/index.htm</a></i>
		adresinde bulunan "<i>Teach Yourself SQL in 21 Days, Second Edition</i>" kitabıdır.</p>
		<p>Bazı kullanıcılarımız da şu kitabı önermektedirler: "<i>The Practical SQL Handbook,
		Bowman, Judith S., et al.,Addison-Wesley</i>". Bazıları ise "<i>The Complete
		Reference SQL, Groff et al., McGraw-Hill</i>" kitabını önermektedirler.</p>
		
		<h4><a name="1.11">1.11</a>) PostgreSQL 2000 yılına uyumlu mudur?</h4>
		<p>Evet.</p>
		
		<h4><a name="1.12">1.12</a>) Geliştirme takımına nasıl katılabilirim?</h4>
		<p>Öncelikle, en son kaynak kodunu indirin ve web sitemizdeki ya da dağıtımın içindeki
		PostgreSQL Developer belgesini okuyun. Ardından, pgsql-hackers ve pgsql-patches 
		listelerine üye olun. Üçüncü olarak da, pgsql-pacthes listesine yüksek kalitede 
		yamalar gönderin.</p>
		<p>PostgreSQL CVS arşivine erişim izni olan, 10 kadar geliştirici bulunmaktadır.
		Hepsi defalarca, diğer kişilerin yaptığından çok daha yüksek-kaliteli yamalar 
		göndermişlerdir. Ayrıca biz de bu geliştiricilerin ekledikleri yamaların yüksek
		kalitede olduğuna güveniyoruz.</p>
		
		<h4><a name="1.13">1.13</a>) Bir hata raporunu nasıl gönderebilirim?</h4>
		<p>PostgreSQL BugTool sayfasına gidiniz. O sayfada bir <i>bug</i> bildirmek
		için neleri yapmanız gerektiği anlatılmıştır.</p>
		<p>Ayrıca, <i><a href="ftp://ftp.PostgreSQL.org/pub">ftp://ftp.PostgreSQL.org/pub</a></i>
		ftp adresimizde, yeni bir PostgreSQL sürümü ya da yaması olup olmadığıni kontrol ediniz.</p>
		
		<h4><a name="1.14">1.14</a>) PostgreSQL, diger DBMS'lerle nasıl karşılastırılabilir?</h4>
		<p>Bir yazılımın gücünü ölçmek için çeşitli yollar vardır: Yazılımın özellikleri, 
		başarımı, güvenilirliği, desteği ve ücreti.</p>
		<p>Özellikler:</p>
		<p>PostgreSQL mevcut büyük ticari veritabanlarının, <i>transaction</i>,
		<i>subselect</i>, <i>trigger</i>, <i>view</i>, <i>foreign key referential integrity</i>
		ve <i>sophisticated locking</i> gibi (<i>user-defined types</i>), <i>rules</i>,
		<i>inheritance</i> ve <i>lock</i> cakışmalarını düşürmek için <i>multi-version</i>
		uyumluluk özellikleri bulunmaktadır.</p>
		<p>Performans (Başarım):</p>
		<p>PostgreSQL, diğer ticari ve açık kaynak kodlu veritabanlarıyla yakın başarımı sağlar.
		Bazı açılardan daha hızlıdır, diğer açılardan da yavaştır. MySQL ya da daha zayıf 
		veritabanları ile karşılaştırıldığında, <code>INSERT/UPDATE</code> işlemlerinde,
		<i>transaction</i> bazlı çalıstığımız için daha yavaşız. MySQL, yukarıdaki "özellikler"
		kısmında belirtilenlerden hiç birine sahip değildir. Biz, başarımımızı her sürümde
		arttırsak da, esneklik ve gelişmiş özellikler için yapılanmış durumdayız.
		PostgreSQL'i MySQL ile karşılaştıran şu web sitesine bakabilirsiniz:
		<i><a href="http://openacs.org/why-not-mysql.html">http://openacs.org/why-not-mysql.html</a></i></p>
		<p>Güvenilirlik:</p>
		<p><i>DBMS</i>'lerin güvenilir olması gerketiği, yoksa değerleri olmayacağını düşünüyoruz.
		Çok iyi test edilmiş, dengeli çalısan minimum sayıda hata içeren kod sunmaya çalışıyoruz.
		Her bir sürüm en az 1 aylık beta testlerinden geçirilmektedir. Sürüm geçmişine bakarsanız,
		üretime hazır, dengeli ve kararlı kodlar sunduğumuzu görebilirsiniz. Bu alanda, diğer 
		veritabanı yazılımlarına üstünlüğümüz olduğuna inanmaktayız.</p>
		<p>Destek:</p>
		<p>E-posta listemiz, oluşan herhangi bir sorunu çözebilecek büyük sayıda kullanıcı
		ve geliştirici grubunu içerir. Sorununuz için, en az bir ticari veritabanı kadar
		rahat çözüm bulabilirsiniz. Gelistiricilere, kullanıcı grubuna, belgelere ve
		kaynak koda direk olarak erişebilme, PostgreSQL desteğini, diğer <i>DBMS</i>'lere
		göre daha önemli kılar. Gereksinimi olanlara, ticari destek verilebilir.
		(Destek için 1.6 bölümüne bakınız.)</p>
		<p>Fiyat:</p>
		<p>Ticari ve ticari olmayan tüm kullanımlarınız için PostgreSQL ücretsizdir. Kodumuzu,
		yukarıda belirtilen BSD-stili lisanstaki sınırlamalar hariç, ürününüzün içine
		ekleyebilirsiniz.</p>
		
		<h4><a name="1.15">1.15</a>) PostgreSQL'e maddi açıdan nasıl destek olabilirim?</h4>
		<p>PostgreSQL, 1996 yılından beri 1. sınıf altyapıya sahiptir. Bunun için, yıllar
		boyu çalışıp bu altyapıyı oluşturup yöneten Marc Fournier'e teşekkürler.</p>
		<p>Bir açık kaynak kodlu proje için, kaliteli altyapı çok önemlidir. Bu altyapı,
		projenin kesilmesini önler ve projenin ilerlemesini hızlandırır.</p>
		<p>Tabii ki bu altyapı ucuz değildir. İşlerin yürümesi için çeşitli yılık ve anlık 
		harcamalarımız olmaktadır. Eğer siz ya da şirketinizin bu çabamıza bağışta
		bulunabilecek parası varsa, lütfen
		<i><a href="http://store.pgsql.com/">http://store.pgsql.com/</a></i>
		adresine gidiniz ve bağışta, hibede bulununuz.</p>
		<p>Web sayfasının 'PostgreSQL Inc.' den bahsetmesine rağmen, "katkıda bulunanlar" 
		(<i>contributors</i>) maddesi sadece PostgreSQL projesini desteklemek içindir ve
		belirli bir şirketin para kaynağı değildir. isterseniz, bağlantı adresine bir
		çek gönderebilirsiniz.</p>
		
		<hr>
		
	<h2 align="center">Kullanıcı/İstemci Soruları</h2>
		
		<h4><a name="2.1">2.1</a>) PostgreSQL icin ODBC sürücüleri var mı?</h4>
		<p>iki tane ODBC sürücüsü bulunmaktadır:  PsqlODBC ve OpenLink ODBC.</p>
		<p>PsqlODBC'i http://gborg.postgresql.org/project/psqlodbc/projdisplay.php adresinden 
		indirebilirsiniz.</p>
		<p>OpenLink ODBC http://www.openlinksw.com adresinden alınabilir.Bu sürücü,
		kendi standart ODBC istemci yazılımı ile çalıstığından, destekledikleri 
		her platformda (Win, Mac, Unix, VMS) PostgreSQL ODBC bulunmalidir.</p>
		<p>Ücretsiz sürümü olmakla beraber, ticari kalitede destek almak isteyenlere satmak isteyeceklerdir. 
		Sorularınızı lütfen postgres95@openlink.co.uk adresine gönderiniz.</p>
		
		<h4><a name="2.2">2.2</a>) PostgreSQL'i web sayfalarında kullanabilmek için hangi
		araçlar bulunmaktadır?</h4>
		<p><i><a href="http://www.webreview.com/">http://www.webreview.com/</a></i> adresinde,
		arka planda veritabanı çalıstıran Web sayfaları için giriş seviyesinde bilgi bulunmaktadır.</p>
		<p>Web ile bütünleşme için, PHP (<i><a href="http://www.php.net/"></a></i>)
		mükemmel bir arabirim sunar.</p>
		<p>Karmaşık sorunlar için, çoğu kisi Perl arabirimini ve CGI.pm ya da mod_perl kullanır.</p>
		
		<h4><a name="2.3">2.3</a>) PostgreSQL'in grafik kullanıcı arabirimi var mıdır?</h4>
		<p>Çeşitli grafik arabirimlerimiz bulunmaktadır. Bunların arasında,
		PgAccess (<i><a href="http://www.pgaccess.org/">http://www.pgaccess.org/</a></i>),
		PgAdmin II (<i><a href="http://www.pgadmin.org/">http://www.pgadmin.org/</a></i>, sadece Win32 için),
		RHDB Admin (<i><a href="http://sources.redhat.com/rhdb/">http://sources.redhat.com/rhdb/</a></i>)
		ve Rekall (<i><a href="http://www.thekompany.com/products/rekall/">http://www.thekompany.com/products/rekall/</a></i>)
		bulunmaktadır. Ayrıca, PostgreSQL için web tabanlı bir arabirim olan
		PHPPgAdmin (<i><a href="http://phppgadmin.sourceforge.net/">http://phppgadmin.sourceforge.net/</a></i>) bulunmaktadır.</p>
		<p>Daha ayrıntılı liste için
		<i><a href="http://techdocs.postgresql.org/guides/GUITools">http://techdocs.postgresql.org/guides/GUITools</a></i>
		adresine bakabilirsiniz.</p>
		
		<h4><a name="2.4">2.4</a>) PostgreSQL ile iletişimi kurabilmek için hangi dilleri kullanabilirim?</h4>
		<ul><li>C (libpq)</li>
		<li>Embedded C (ecpg)</li>
		<li>Java (jdbc)</li>
		<li>Python (PyGreSQL)</li>
		<li>TCL (libpgtcl)</li></ul>
		<p>Diğerleri için, http://gborg.postgresql.org adresindeki Drivers/Interfaces bölümüne 
  		bakabilirsiniz.</p>
		
		<hr>
		
	<h2 align="center">Yönetimsel Sorular</h2>
		
		<h4><a name="3.1">3.1</a>) PostgreSQL'i, <code>/usr/local/pgsql</code> dizininden
		başka dizinlere nasıl kurabilirim?</h4>
		<p><i>configure</i> betiğini çalıstırırken, <code>--prefix</code> seçeneğini veriniz.</p>
		
		<h4><a name="3.2">3.2</a>) postmaster'i baslattıgımda, a Bad System Call ya da core dumped mesajı alıyorum. Neden?</h4>
		<p>Bunun birçok nedeni olabilir. Ancak ilk kontrol edilmesi gereken sey, çekirdeginize
		System V uzantılarının kurulu olup olmadıgını kontrol etmek olabilir. PostgreSQL 
		shared memory ve semaphores için çekirdek destegine gereksinim duyar.</p>
		
		<h4><a name="3.3">3.3</a>) postmaster'i başlattığımda, <code>ıpcMemoryCreate</code>
		hatası alıyorum. Neden?</h4>
		<p>Ya çekirdeğinizde <i>shared memory</i> desteğiniz düzgünce yapılandırılmamıştır,
		ya da çekirdeğinizdeki mevcut <i>shared memory</i> miktarını büyütmeniz gerekecektir.
		Gereksinim duyacağınız miktar, mimarinize ve postmaster için ayarladıgınız tampon
		ile <i>backend</i> işlemi sayısına bağlıdır. Tüm sistemler için, tamponlar ve
		işlemlerde öntanımlı sayılarla, ~ 1MB kadar yere gereksinmeniz olacaktır.
		<i><a href="http://www.postgresql.com/docs/7.3/interactive/admin.html">PostgreSQL
		7.3.2 Sistem Yöneticileri Rehberi</a></i>'ne, <i>shared memory</i> ve <i>semaphorelar</i>
		hakkındaki ayrıntılı bilgi için bakabilirsiniz.</p>
		
		<h4><a name="3.3">3.4</a>) postmaster'ı başlattığımda,
		<code>ıpcSemaphoreCreate</code> hatası alıyorum. Neden?</h4>
		<p>Eğer hata, "<code>ıpcSemaphoreCreate: semget failed (No space left on device)</code>"
		ise, çekirdeğiniz yeterli <i>semaphore</i> ile yapılandırılmamış demektir. Postgres, her 
		bir potansiyel <i>backend</i> için bir <i>semaphore</i> gereksinimi duyar. Geçici
		bir çözüm, postmasterı <i>backend</i> işlemleri için daha az miktarda sınırla
		başlatmak olabilir. <code>-N</code>'i varsayılan değer olan 32'den küçük bir
		değerle başlatınız. Daha kalıcı bir çözüm, çekirdeğinizin <code>SEMMNS</code> ve
		<code>SEMMNI</code> parametrelerini yükseltmek olacaktır.</p>
		<p>Çalışmayan <i>semaphore</i>'lar ağır veritabanı işlemlerinde çökme yaratabilirler.</p>
		<p>Eğer hata mesajınız başka bir şey ise, çekirdeğinizde <i>semaphore</i> desteğini 
		yapılandırmamış olabilirsiniz. <i>Shared memory</i> ve <i>semaphore</i>'lar hakkındaki
		daha ayrıntılı bilgi için
		<i><a href="http://www.postgresql.com/docs/7.3/interactive/admin.html">PostgreSQL
		7.3.2 Sistem Yöneticileri Rehberi</a></i>'ne bakabilirsiniz.</p>
		
		
		<h4><a name="3.5">3.5</a>) Diger bilgisayarların benim PostgreSQL veritabanı
		sunucuma bağlantılarını nasıl kontrol edebilirim?</h4>
		<p>Ön tanımlı olarak, PostgreSQL sadece yerel makineden <i>Unix domain sockets</i>
		kullanarak bağlanılmasına izin verir. Diger makineler, postmaster'a <code>-i</code>
		etiketini geçirmezseniz ve <code>$PGDATA/pg_hba.conf</code> dosyasını düzenleyerek
		<i>host-based authentication</i>'a  olanak vermezseniz, bağlantı yapamayacaklardır.</p>
		
		<h4><a name="3.6">3.6</a>) Veritabani motorunu daha iyi
		başarım için nasıl ayarlayabilirim?</h4>
		<p><i>Index</i>'ler sorguları hızlandırabilir. <code>EXPLAIN</code> komutu,
		PostgreSQL'in sorgunuzu nasıl yorumladığını ve hangi <i>index</i>'leri kullandığını
		görmenize izin verir.</p>
		<p>Eğer cok fazla <code>INSERT</code> işlemi yapıyorsanız, bunları büyük bir
		toplu işlem dosyasıkullanıp <code>COPY</code> komutu ile veritabanına girmeyi
		deneyiniz. Bu, tekil <code>INSERT</code>'lerden daha hızlıdır. İkinci olarak,
		<code>BEGIN WORK/COMMIT</code> <i>transaction</i> bloğu içinde olmayan ifadeler kendi 
		<i>transaction</i>'larındaymış gibi düşünülür. Çoklu ifadeleri tek bir
		<i>transaction</i> bloğu içinde yapabilirsiniz. Bu, <i>transaction overhead</i>'ini
		düşürecektir. Tek bir <i>transaction</i> bloğu içinde birden çok ifadeyi çalıştırmayı 
		deneyebilirsiniz. Bu da aynı şekilde, <i>transaction overhead</i>'ini düşürür.</p>
		<p>Çeşitli ayarlama seçenekleri mevcuttur. <code>fsync()</code> işlemini, postmaster'ı
		<code>-o -F</code> seçeneği ile başlatarak devre dışı bırakabilirsiniz. Bu işlem,
		<code>fsync()</code>'lerin her <i>transactiondan</i> sonra diski <i>flush</i> etmesini
		engelleyecektir.</p>
		<p>Aynı zamanda, postmaster'i <code>-B</code> seçeneği ile başlatıp, <i>backend</i>
		işlemleri tarafından kullanılan <i>shared memory buffers</i> sayılarını arttırabilirsiniz.
		Eğer bu parametreyi çok yüksek tutarsanız, çekirdeğinizin <i>shared memory</i>
		bölgesindeki limiti aşma olasılığınız yüzünden postmaster başlayamayabilir. Her bir
		tampon (<i>buffer</i>) 8K'dır. Öntanımlı sayı ise 64 tampondur.</p>
		<p>Aynı şekilde, backend'in <code>-S</code> seçeneğini geçici sıralamalar için
		<i>backend</i> süreçleri tarafından kullanılacak hafızayı arttırmak amacıyla
		kullanabilirsiniz. <code>-S</code> seçeneği kilobayt cinsinden değer alır ve ön
		tanımlı değeri 512'dir (512 K)</p>
		<p>Tablolardaki veriyi bir <i>index</i>'e eşlemek amacıyla gruplama için
		<code>CLUSTER</code> komutunu kullanabilirsiniz. Ayrıntılı bilgi için
		<code>CLUSTER</code> komutunun yardım sayfasına bakabilirsiniz.</p>
		
		<h4><a name="3.7">3.7</a>) Hangi hata ayıklama özellikleri bulunmaktadır?</h4>
		<p>PostgreSQL, hata ayıklama amacıyla kullanılabilecek durum bilgisi
		rapor eden çeşitli özeliklere sahiptir.</p>
		<p>Öncelikle, <i>configure</i> betiğini <code>--enable-cassert</code> seçeneğiyle
		çalıştırırsanız, bir çok <code>assert() backend</code> calışmasını gözlemler ve
		beklenmeyen bir durumda programı durdurur.</p>
		<p>Postmaster ve postgres çeşitli hata ayıklama seçeneklerine sahiptir. Öncelikle,
		postmaster'ı başlattığınızda, standart çıktıyı ve hataları bir log dosyasına 
		yönlendirdiğinize emin olun:</p>
		<pre>cd /usr/local/pgsql<br>./bin/postmaster >server.log 2>&amp;1 &amp;</pre>
		<p>Bu işlem PostgreSQL ana dizinine <code>server.log</code> dosyası yerleştirecektir.
		Bu dosya sunucunun yaşadığı sorunlar ya da hatalar hakkında yararlı bilgiler içerir.
		<code>-d</code> seçeneği, hata ayıklama seviyesini belirten bir rakam ile kullanılır.
		Yüksek hata ayıklama seviyelerinin büyük log dosyaları oluşturacağını unutmayınız.</p>
		<p>Eğer postmaster çalışmıyorsa, <code>postgres backend</code>'ini komut satırından
		çalıştırabilir ve SQL ifadenizi direk olarak yazabilirsiniz. Bu sadece hata ayıklama
		amacıyla önerilir. Burada, noktalı virgülün değil de yeni bir satırın sorguyu
		sonlandırdığını unutmayınız. Eğer hata ayıklama sembolleri ile derlediyseniz,
		ne olduğunu görmek için bir hata ayıklayıcı kullanabilirsiniz. <i>backend</i>
		postmaster'dan başlatılmadığından, eşdeğer bir ortamda çalışmamaktadır ve
		<i>locking/backend</i> etkileşim sorunları artabilir.</p>
		<p>Eğer postmaster çalışıyorsa, bir pencerede psql'i çalıştırın ve psql tarafından
		kullanılan postgres sürecinin süreç numarasını (<code>PID</code>) bulun. Postgres
		süreci ile ilişkilendirmek için bir hata ayıklarıcı kullanın. Sorguları psql aracılığı
		ile çalıştırabilirsiniz. Eğer postgres başlangıcında hata ayıklamak istiyorsanız,
		<code>PGOPTIONS="-W n"</code> seçeneğini ayarlayabilir ve psql'i başlatabilirsiniz.
		Bu işlem, başlangıcın <code>n</code> saniye kadar gecikmesini sağlayacaktır; böylece
		hata ayıklayıcıyı sürece ilişkilendirdikten sonra başlangıç sürecinin devam etmesini 
		sağlayabilirsiniz.</p>
		<p>postgres programı hata ayıklama ve başarım ölçümleri için <code>-s</code>,
		<code>-A</code> ve <code>-t</code> seçeneklerine sahiptir.</p>
		
		<h4><a name="3.8">3.8</a>) Bağlanmaya çalışırken, neden "<i>Sorry, too many
		clients</i>" hatasını alıyorum?</h4>
		<p>Postmaster'ın  eşzamanlı olarak başlatabileceği <i>backend</i> süreçleri
		sınırlarını arttırmanız gerekmektedir.</p>
		<p>Ön tanımlı değer 32 süreçtir. Bunu, postmaster'ı uygun <code>-N</code>
		değeri ile ya da <code>postgresql.conf</code> dosyasını düzenleyerek yeniden
		başlatmakla arttırabilirsiniz.</p>
		<p>Eğer <code>-N</code> değerini 32'den büyük yapacaksanız, aynı zamanda
		<code>-B</code> değerini de değiştirmeniz gerektiğini unutmayın. <code>-B</code>,
		<code>-N</code>'nin en az 2 katı kadar olmalıdır; daha iyi başarım için bu sayıyı daha
		da arttırmalısınız. Yüksek sayıdaki <i>backend</i> süreçleri için, çeşitli çekirdek
		yapılandırma parametrelerini arttırmanız gerekecektir. Yapılması gerekenler,
		<code>SHMMAX</code>, <code>SEMMNS</code>, <code>SEMMNI</code>, <code>NPROC</code>,
		<code>MAXUPRC</code> ve açılabilecek dosyaların maksimum sayısı olan <code>NFILE</code>
		ve <code>NINODE</code> değerlerini karıştırmaktır. Bunun nedeni, PostgreSQL'in izin
		verilen <i>backend</i> süreçlerinin sayısı üzerinde bir sınırı olmasıdır. Böylelikle
		sistem kaynaklarının dışına çıkılmayacaktır.</p>
		<p>PostgreSQL'in 6.5 sürümüne kadar, en fazla <i>backend</i> sayısı 64 idi ve bunu
		değiştirmek için <code>include/storage/sinvaladt.h</code> dosyası içindeki
		<code>MaxBAckendid</code> sabitini değiştirdek sonra yazılımı yeniden
		derlemek gerekiyordu.</p>
		
		<h4><a name="3.9">3.9</a>) <code>pgsql_tmp</code> dizinin içindeki dosyalar nelerdir?</h4>
		<p>Sorgu çalıstırıcı (<i>query executer</i>) tarafından yaratılan geçici dosyalardır.
		Örnegin, bir sıralama <code>ORDER BY</code> ile yapılacaksa ve sıralama
		<code>backend</code>'in <code>-s</code> parametresinin izin verdiğinden daha
		fazla alana gereksinim duyuyorsa, ekstra veriyi tutmak için geçici dosyalar yaratılır.</p>
		<p>Geçici dosyalar, eğer sıralama sırasında <i>backend</i> göçmezse otomatik olarak
		silinecektir. Eğer çalışan durumda bir <i>backend</i>'iniz yoksa,
		<code>pg_tempNNN.NN</code> dosyalarını silmeniz güvenlidir.</p>
		
		<h4><a name="3.10">3.10</a>) PostgreSQL sürümlerini yükseltmek için neden bir
		dump/reload işlemi gerçekleştirmek zorundayım?</h4>
		<p>PostgreSQL takımı ara sürümlerde sadece küçük değişiklikler yapmaktadır;
		bu yüzden 7.2 sürümünden 7.2.1'e yükseltmek <i>dump/restore</i> işlemi
		gerekmemektedir. Ancak, esas sürümlerde (örnek: 7.2'den 7.3'e) çoğunlukla sistem
		tablolarının ve veri dosyalarının iç yapısı değiştirilir. Bu değişiklikler çoğunlukla
		karmaşıktır; dolayısıyla veri dosyalarının geriye dönük uyumluluğu işlemlerini
		yapmıyoruz. <i>Dump</i> işlemi, veriyi genel biçimde alacağından yeniden yükleme
		esnasında veri, yeni iç biçime uygun şekilde yerleştirilecektir.</p>
		<p>Disk biçiminin değişmediği sürümlerde, <code>pg_upgrade</code> betiği güncellemenin
		bir <i>dump/restore</i> gerektirmeden yapılmasını sağlayacaktır. <i>pg_upgrade</i>
		betiğinin o sürüm için bulunup bulunmadığını sürüm notları içinde bulabilirsiniz.</p>

		<h4><a name="3.11">3.11</a>) Nasıl bir donanım kullanmalıyım? </h4>
		<p> PC donanımı tamamen uyumlu olduğu için, insanlar tüm PC donanımlarının aynı kalitede olduğunu 
		düşünürler. Oysa böyle değildir. ECC RAM, SCSI ve kaliteli anakartlar daha ucuz donanımlara göre daha 
		çok güvenilirlerdir ve başarımları daha yüksektir. PostgreSQL hemen hemen tüm donanımda 
		çalışabilmektedir, ancak güvenilirlik ve başarım önemli ise donanım seçeneklerini çok iyi araştırmak 
		gereklidir. E-posta listelerimi donanımlarla ilgili sorular ve de ticaret için kullanılabilir.</p>

		<hr>
		
	<h2 align="center">İşletimsel Sorular</h2>
	
		<h4><a name="4.1">4.1</a>) <i>Binary cursor</i> ve <i>normal cursor</i>
		arasındaki fark nedir?</h4>
		<p><code>DECLARE</code> yardım sayfasına bakınız.</p>
		
		<h4><a name="4.2">4.2</a>) Sorgunun sadece ilk birkaç satırını
		nasıl <code>SELECT</code> edebilirim?</h4>
		<p><code>FETCH</code> yardım sayfasına bakınız, ya da <code>SELECT</code> ...
		<code>LIMIT</code> ... kullanınız.</p>
		<p>İlk birkaç satırı almak isteseniz bile, tüm sorgu değerlendirilmek durumunda kalınabilir. ORDER 
 		BY içeren bir sorgu düşünün. Eğer ORDER BY işe eşleşen bir index varsa, PostgreSQL istenen ilk birkaç  
		satırı işleyebilir, ya da tüm sorgu istenen satırlar üretilene kadar işlenebilir. </p>
		
		<h4><a name="4.3">4.3</a>) psql'in içinde gördügüm tabloların ya da diğer
		şeylerin listesini nasıl alabilirim?</h4>
		<p><code>pgsql/src/bin/psql/describe.c</code> içindeki psql kaynak kodunu
		okuyabilirsiniz. Bu kod, psql'in <code>\</code> ile başlayan komutlarının
		çıktısını olusturan SQL komutlarını içerir. Aynı zamanda, psql'i <code>-E</code>
		seçeneği ile başlatıp, verdiğiniz komutları çalıştırmak için yaptığı 
		sorguların çıktılarını görebilirsiniz.</p>
		
		<h4><a name="4.4">4.4</a>) Bir tablodan bir kolonu nasıl kaldırabilirim?</h4>
		<p>Bu özellik (<code>ALTER TABLE DROP COLUMN</code>) 7.3 sürümü ile gelmiştir.
		Eski sürümlerde aşağıdakileri uygulamalısınız: </p>
		<pre>
BEGIN;
LOCK TABLE old_table;
SELECT ...  -- select all columns but the one you want to remove
INTO TABLE new_table
FROM old_table;
DROP TABLE old_table;
ALTER TABLE new_table RENAME TO old_table;
COMMIT;		
		</pre>
		
		<h4><a name="4.5">4.5</a>) Bir satır, tablo ve veritabanı için en
		fazla büyüklük nedir?</h4>
		<p>Sınırlar:</p>
		<p>Veritabanı için en fazla büyüklük nedir?<br>Sınırsız (32 TB'lık veritabanı bulunmaktadır)<br><br>
		Bir tablo için en fazla büyüklük nedir?<br>32 TB<br><br>
		Bir satır için en fazla büyüklük nedir?<br>1.6 TB<br><br>
		Bir alan için en fazla büyüklük nedir?<br>1 GB<br><br>
		Tabloda en fazla satır sayısı kaçtır?<br>Sınırsız<br><br>
		Bir tabloda olabilecek en fazla kolon sayısı kaçtır?<br>Kolon tiplerine bağlı olarak 250-1600<br><br>
		Bir tabloda olabilecek en fazla <i>index</i> sayısı kaçtır?<br>Sınırsız</p>
		<p>Tabii ki bunlar aslında sınırsız degildir. Burada belirtilen sınırlar, fiziksel
		sınırların haricindeki sınırlardır. Boş disk alanı, hafıza/takas alanı na bağlı 
		sınırlamalar vardır. Başarım, sınır değerlere yaklaştıkça, ya da değerler çok büyük 
		olduğunda düşebilir.</p>
		<p>Bir tablo için büyüklük sınırı olan 32 TB, işletim sisteminin büyük dosya desteği olup
		olmamasından bağımsızdır. Büyük tablolar, 1 GB'lik dosyalarda saklandığı için, dosya 
		sistemi sınırlarınin bir önemi yoktur.</p>
		<p>Tablo ve kolon sayısı büyüklükleri, ön tanımlı blok büyüklüğü 32k ya çıkarılarak 
		arttırılabilir.</p>
		
		<h4><a name="4.6">4.6</a>) Tipik bir metin dosyasındaki veriyi saklamak için ne
		kadar disk alanı gereklidir?</h4>
		<p>Bir PostgreSQL veritabanı, veriyi "<i>flat</i>" metin dosyasında saklamak için
		gereken alanın 5 kat fazla disk alanına gereksinim duyabilir.</p>
		<p>Her satırında bir tamsayı ve metin (<i>text</i>) içeren, 100.000 satırlık bir
		dosya düşünün.  Her satırın ortalama 20 byte olduğunu farzedelim. Metin dosyası
		2.8 MB olacaktır. Bu veriyi tutan PostgreSQL veritabanı
		yaklaşık 6.4 MB yer kaplayacaktır.</p>
		<pre>
  36 byte: Her bir satır başlığı (yaklaşık)
+ 24 byte: Bir tamsayı (int) alanı ve bir metin (text) alanı 
+  4 byte: Sayfada tuple a pointer
----------------------------------------
  64 byte -> kayıt başına</pre>
		<p>PostgreSQL'de veri sayfası (data page) büyüklüğü 8192 byte (8k)dır, dolayısıyla:</p>
		<pre>
8192 byte -> page başına
-------------------------  =  Her bir veritabanı <i>page</i>'ı başına 128 satır (yaklaşık)
  Satır başına 64 byte
  
100000 veri satırı
--------------------  =  782 veritabanı sayfası
     128 satır</pre>
		<p>782 veritabanı sayfası <code>*</code> sayfa başına <code>8192 byte =
		6,406,144 bytes (6.4 MB)</code></p>
		<p><i>Index</i>'ler çok fazla yere gereksinim duymazlar, ama <i>index</i>'lenmiş
		veriyi tutacaklarından büyük olabilirler.</p>
		<p><code>NULL</code> değerler bitmapler içinde tutulur; dolayısıyla çok az yer kaplarlar.</p>
		
		<h4><a name="4.7">4.7</a>) Veritabanında hangi tablo ya da <i>index</i>'lerin
		tanımlandığını nasıl görebilirim?</h4>
		<p>psql, bu tür bilgileri göstermek için, <code>\</code> ile başlayan bir çok
		komut sunmaktadır. <code>\?</code> komutu ile bu komutları görebilirsiniz. Ayrıca,
		bunları açıklayan ve <code>pg_</code> ile başlayan çok sayıda sistem tablosu
		bulunmaktadır. Aynı zamanda, <code>psql -l</code> ile tüm veritabanlarını
		listeyelebirsiniz.</p>
		<p>Ayrıca, <code>pgsql/src/tutorial/syscat.source</code> kodunu inceleyebilirsiniz.
		Bu dosya, veritabanı sistem dosyalarından bilgiyi almak için gereksinim duyulan
		bir çok <code>SELECT</code>'leri gösterir.</p>
		
		<h4><a name="4.8">4.8</a>) Sorgularım cok yavaş, ya da <i>index</i>'lerimi
		kullanmıyorlar. Neden?</h4>
		<p>Indexler her sorgu tarafından otomatik olarak kullanılmazlar. Indexler eğer bir 
		tablonun büyüklüğü minimum bir büyüklükten fazla ise ve sorgu tablodaki satırların sadece küçük bir 
		yüzdesini seçiyorsa kullanılır. Bunun nedeni, index erişiminin neden olduğu raslansal disk erişimi
		nin diskin ya da tablonun sıralı okunmasından daha yavas olabilmesidir.</p>

	 	<p>Bir index'in kullanılıp kullanılmayacağını belirlemek için, PostgreSQL tablo hakkındaki 
		istatistiklere gereksinmesi vardır. Bu istatistikler, <small>VACUUM ANALYZE</small> kullanılarak
		toplanırlar. Optimizer, istatistikleri kullanarak, tabloda kaç satır olduğunu ve bilir ve indexin 
		kullanılıp kullanılmayacağına daha iyi karar verir. Istatistikler, aynı zamanda en uygun join 
		sırasını ve yöntemini belirlemekte çok önemlidir. İstatistik toplanması, tablo içerikleri 
		değiştikçe periyodik olarak yapılmalıdır.</p>
		

    <p>Indexler normalde <small>ORDER BY</small> sorguları ya da join işlemlerini gerçekleştirmek için
    kullanılmazlar. Açık bir sıralamayı takip eden sıralı bir arama (sequential scan), büyük bir tabloda index
    araması yapmaktan genelde daha hızlıdır.</p>

    Ancak, <small>ORDER BY</small> ile birleşmiş <small>LIMIT</small>
    genellikle bir index kullanacaktır; çünkü tablonun sadece belirli bir miktarı döndürülecektir.
    Aslında, MAX() ve MIN() fonksiyonlarının index kullanmamalarından dolayı, bu gibi değerleri ORDER BY ve LIMIT 
    kullanarak da almak olasıdır:
<pre>
    SELECT col
    FROM tab
    ORDER BY col [ DESC ]
    LIMIT 1;
</pre>

    <p>Eğer optimizer'ın sıralı arama yapmasının yanlış olduğuna inanıyorsanız, <code>SET enable_seqscan TO 
'off'</code> kullanın ve index kullanan aramaların hala daha hızlı olup olmadığını görün.</p>

		<p><code>LIKE</code> ya da <code>~</code> gibi operatörler kullanıyorsanız,
		<i>index</i>'ler sadece aşağıdaki koşullarda kullanılabilir:</p>

		<ul>
		<li>Arama dizininin başı, dizinin başı ile bağlanmalıdır. Yani,
		<ul><li><code>LIKE</code> sorguları <code>%</code> ile başlamamalıdır.</li>
		<li>Düzenli ifade sorguları <code>^</code> işe başlamamalıdır.</li></ul></li>
		<li>Arama metni bir karakter sınıfı ile başlayamaz. Örnek: <code>[a-e]</code></li>
		<li><code>ILIKE</code> ve <code>~*</code> gibi  büyük/küçük harfe duyarsız
		aramalar <i>index</i>'lerden yararlanmazlar. Onun yerine, bölüm 4.12'de anlatılan
		fonksiyonel <i>index</i>'leri kullanabilirsiniz.</li>
		<li><i>initdb</i> sırasında öntanımlı <i>C locale</i>'i kullanılmalıdır.</li>
		</ul>
		
		<h4><a name="4.9">4.9</a>) <i>query-optimizer</i>'ın sorgularımı nasıl
		değerlendirdiğini, işleme soktuğunu nasıl görebilirim?</h4>
		<p><code>EXPLAIN</code> yardım sayfasına bakınız.</p>
		
		<h4><a name="4.10">4.10</a>) <i>R-tree index</i> nedir?</h4>
		<p>R-tree index, uzaysal (spatial) verileri indexlemek için kullanılır. Bir hash
		index, dizi aramalarında (range search) kullanılamaz. B-tree index dizi aramalarında sadece tek 
		boyutlu çalışmaktadır. R-tree, çok boyutlu veriyi destekler. Örneğin, eğer bir R-tree index point 
		veri tipi üzerinde inşa edililebilirse, sistem "select all points within a bounding rectangle"
		gibi sorgulara daha verimli yanıtlar verecektir.</p>
		<p>Orijinal R-tree tasarımını açıklayan belge:</p>
		<p>Guttman, A. "R-trees: A Dynamic Index Structure for Spatial Searching."
		Proceedings of the 1984 ACM SIGMOD Int'l Conf on Mgmt of Data, 45-57.</p>
		<p>Bu belgeyi, Stonebraker'ın "Readings in Database Systems" kitabında bulabilirsiniz.</p>
		<p>Gömülü R-tree indexleri poligon ve boxları kullanabilir. Teorik olarak,
		R-tree indexlerin özelliklerini genişletmek bir miktar çaba gerektirir ve bunun nasıl 
		yapılacağına dair bir belgemiz henüz bulunmamaktadır.</p>

		<h4><a name="4.11">4.11</a>) <i>Genetic Query Optimizer</i> nedir?</h4>
		<p><i>GEQO</i> modülü, <i>Genetic Algorithm(GA)</i> kullanılarak tablolar
		birleştirildiğinde sorgu optimizasyonunu hızlandırır. </p>
		
		<h4><a name="4.12">4.12</a>) Düzenli ifade (<i>Regular Expression</i>) aramalarını
		ve büyük/küçük harfe duyarsız aramaları nasıl yapabilirim?
		Bu büyük(küçük harfe duyarlı aramalar için <i>index</i>'i nasıl kullanabilirim?</h4>
		<p><code>~</code> operatörü düzenli ifade eşleşmesi ve <code>~*</code>  büyük/küçük
		harfe duyarsız düzenli ifade eşleşmesi yapar. Büyük/küçük harfe duyarlı olan
		<code>LIKE</code>'ın  büyük/küçük harfe duyarsız olan biçimi <code>ILIKE</code>'tır
		ve PostgreSQL 7.1 sürümü ile birlikte gelmiştir.</p>
		<p>Büyük-küçük harfe duyarsız eşitlik karşılaştırmaları aşağıdaki gibi ifade edilir:</p>
		<pre>
SELECT *
FROM tab
WHERE lower(col) = 'abc'
		</pre>
		<p>Bu standart bir <i>index</i> yaratmayacaktır. Ancak eğer fonksiyonel bir
		<i>index</i> yaratırsanız; o kullanılacaktır:</p>
		<pre>CREATE INDEX tabindex on tab (lower(col));</pre>
		
		<h4><a name="4.13">4.13</a>) Bir sorguda, bir alanin "<code>NULL</code>" olduğunu
		nasıl ortaya çıkarabilirim?</h4>
		<p>Kolonu, <code>IS NULL</code> ve <code>IS NOT NULL</code> ile test edebilirsiniz.</p>
		
		<h4><a name="4.14">4.14</a>) Çesitli karakter tipleri arasındaki farklar nelerdir?</h4>
		<pre>
Veri Tipi	    İç Adı              Not
--------------------------------------------------
VARCHAR(n)      varchar         boyut en büyük uzunluğu verir; sadece verilen kadar veri tutulur.
CHAR(n)         bpchar          belirtilen uzunluğa kadar sonuna  boşluk eklenir.
TEXT            text            uzunlukta herhangi bir üst sınır yoktur. 
BYTEA           bytea           variable-length byte array (null-byte safe)
"char"          char            bir karakter 
		</pre>
		<p>İç adları (<i>internal name</i>) sistem kataloglarını ve
		bazı hata mesajlarını incelerken göreceksiniz.</p>
		<p>İlk dört veri tipi "<i>varlena</i>" tipidir (yani, diskteki ilk 4 bayt uzunluktur;
		devamı da veridir.) Dolayısıyla, kullanılan gerçek alan, belirtilen alandan biraz
		daha büyüktür. Ancak, bu veri tipleri, sıkıştırılmaya tabi tutulabilir; dolayısıyla
		disk alanı beklenilenden küçük olabilir. <code>VARCHAR(<i>n</i>)</code> büyüklüğü
		artabilen ama en büyük uzunluğu sınırlı olan verileri saklamak için en uygun yöntemdir.
		<code>TEXT</code>, 1 GB büyüklüğe kadar olan verileri tutmak için kullanılır.</p>
		<p><code>CHAR(<i>n</i>)</code>, aynı uzunluktaki dizilerin saklanması için kullanımır.
		<code>CHAR(<i>n</i>)</code> belirtilen uzunluğa kadar boşluk ile doldurur; ancak
		<code>VARCHAR(<i>n</i>)</code> sadece verilen karakterleri saklar. <code>BYTEA</code>
		binary veri saklamak içindir; ayrıca "<code>NULL</code>" bayt içeren değerleri de saklar.
		Burada anlatılan üç veri tipi de benzer başarım karakteristiklere sahiptir.</p>
		
		<h4><a name="4.15.1">4.15.1</a>) Nasıl <i>serial</i>/otomatik artan
		(<i>auto-incrementing</i>) bir alan yaratabilirim?</h4>
		<p>PostgreSQL'de <code>SERIAL</code> veri tipi vardır. Bu veri tipi bir
		<i>sequence</i> ve kolon üzerinde bir <i>index</i> yaratır.</p>
		<p>Örnek, aşağıdaki sorgu:</p>
		<pre>
CREATE TABLE person (
    id   SERIAL,
    name TEXT
);		
		</pre>
		<p>buna çevrilir:</p>
		<pre>
CREATE SEQUENCE person_id_seq;
CREATE TABLE person (
    id   INT4 NOT NULL DEFAULT nextval('person_id_seq'),
    name TEXT
);
CREATE UNIQUE INDEX person_id_key ON person ( id );		
		</pre>
		<p><i>Sequenceler</i> hakkında daha fazla bilgi için <i>create_sequence</i>
		yardım sayfasına bakabilirsiniz. Her satırın <code>OID</code> alanını tekil bir sayı
		olarak alabilirsiniz. Ancak, veritabanınızın <i>dump</i>'ını alıp yeniden yüklerseniz,
		<code>OID</code> değerlerini koruyabilmek için <code>pg_dump</code>'ın <code>-o</code>
		parametresini ya da "<code>COPY WITH OIDS</code>" seçeneğini kullanmanız gerekecektir.</p>

    	<h4><a name="4.15.2">4.15.2</a>) <code>SERIAL</code> girişinin degerini nasıl alabilirim?</h4>
		<p>Bir yaklaşım, sequence nesnesindeki SERIAL değerini, veriyi girmeden önce nextval() ile alıp, 
		aldığınız değeri kendinizin girmesidir. 4.15.1'deki örnek tabloyu kullanarak bir örnek verelim:</p>

		<pre>new_id = execute("SELECT nextval('person_id_seq')");<BR>
    execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");</pre>

	<P>Diğer sorgular için new_id'de yeni değerin saklanması gerekir. Otomatik olarak yaratılan SEQUENE nesnesinin adı,
  &lt;tablo adı&gt;_&lt;serial kolonu adı&gt;_seq şeklinde olacaktır (&lt; &gt; işaretleri olmadan).</p>

		<p>Alternatif olarak, atanmış SERIAL değerini, değer girildikten sonra currval()
		fonksiyonu ile alabilirsiniz:</p>
		<pre>
		execute("INSERT INTO person (name) VALUES ('Blaise Pascal')");
		new_id = execute("SELECT currval('person_id_seq')");	
		</pre>
		<p>Son olarak, ön tanımlı değeri bulmak için <code>INSERT</code> ifadesinden
		dönen <code>OID</code> değerini kullanabilirsiniz; ancak bu en az taşınabilir
		çözüm olacaktır. Perl'de, Edmund Mergl'in <i>DBD:Pg</i> mödülü ile birlikte
		<i>DBI</i> kullanarak, <code>OID</code> değeri <code>$sth->execute()</code>
		çalıştırıldıktan sonra <code>$sth->(pg_oid_status)</code> ile alınabilir.</p>
	
		<h4><a name="4.15.3">4.15.3</a>) <code>currval()</code> ve <code>nextval()</code>
		diğer kullanıcılara sorun yaratmaz mı?</h4>
		<p>Hayır. <code>curval()</code>, tüm kullanıcılar değil, backend
		tarafından atanan geçerli değeri döndürür.</p>
		
		<h4><a name="4.15.4">4.15.4</a>) Neden <i>sequence</i> sayıları <i>transaction</i>
		işleminin iptalinden sonra yeniden kullanılıyor? Neden <i>sequence/SERIAL</i>
		kolonumdaki sayılarda atlamalar oluyor?</h4>
		<p>Uyumluluğu arttırmak için, <i>sequence</i> değerleri çalışan
		<i>transaction</i>'lara gerektiği şekilde aktarılır ve <i>transaction</i>
		bitene kadar o değer kilitlenmez. Bu, iptal edilen <i>transaction</i>
		işlemleri nedeniyle boşluklara neden olur.</p>
		
		<h4><a name="4.16">4.16</a>) OID nedir? TID nedir?</h4>
		<p>OIDler, tekil satır numaralarına PostgreSQL'in yanıtıdır. PostgreSQL'de yaratılan
		her sayı, tekil bir OID alır. initdb işlemi sırasında yaratılan tüm OID'ler 16384'ten küçüktür 
		(backend/access/transam.h). Kullanıcılar tarafından yaratılan tüm OID'ler bu sayıya eşit ya da bu 
		sayıdan büyüktür. Varsayılan durumda, tüm bu OIDler sadece bir tablo ya da veritabanında değil, tüm 
		PostgreSQL kurulumunda tekildir.</p>

		<p> PostgreSQL OIDleri, tablolar arasında satırları ilişkilendirmek için kendi iç tablolarında 
		kullanır. Bu OIDler belirli kullanıcı satırlarını belirtmek için kullanabilir ve join işlemlerinde 
		kullanılır. OID değerlerini saklamak için OID kolon tipini kullanmanız önerinir. Daha hızlı bir 
		erişim için, OID alanında bir index yaratabilirsiniz.</p>

		<p>OID'ler yeni satırlara, tüm veritabanları tarafında kullanılan ortak bir alandan atanırlar. Eğer 
		 OID'i başka bir değere eşitlemek isterseniz ya da tablonun bir kopyasını orijinal OIDler ile 
		çıkarmak isterseniz, bu mümkündür:</p>
		<pre>
			CREATE TABLE new_table(old_oid oid, mycol int);
			SELECT old_oid, mycol INTO new FROM old;
			COPY new TO '/tmp/pgtable';
			DELETE FROM new;
			COPY new WITH OIDS FROM '/tmp/pgtable';		
		</pre>
		<p>OIDler 4-bit tamsayı olarak saklanırlar ve 4 milyarda overflow olacaktır. Kimse 
		bu sayıya ulaştığına dair bir bilgi iletmedi ve bu sınırı kimse bu sınıra ulaşmadan kaldıracağız.</p>

		<p>TIDler, belirli fiziksel satırlar block ve offset değerleri ile belirtmekte kullanılır. TIDler, 
		satırlar değiştiğinde ya da yeniden yüklendiğinde değişirler. Index girdileri tarafından fiziksel 
		satırları göstermek için kullanılırlar.</p>
		
		<h4><a name="4.17">4.17</a>) PostgreSQL'de kullanılan bazı
		terimlerin anlamları nelerdir?</h4>
		<p>Kaynak kodun bir kısmı ve eski belgeler, daha geniş kullanım alanı olan terimleri
		kullanırlar. Bunların bazıları:</p>
		<ul><li>table, relation, class</li>
		<li>row, record, tuple</li>
		<li>column, field, attribute</li>
		<li>retrieve, select</li>
		<li>replace, update</li>
		<li>append, insert</li>
		<li>OID, serial value</li>
		<li>portal, cursor</li>
		<li>range variable, table name, table alias</li></ul>
		<p>Genel veritabanı terimleri, 
		<i><a href="http://hea-www.harvard.edu/MST/simul/software/docs/pkgs/pgsql/glossary/glossary.html">http://hea-www.harvard.edu/MST/simul/software/docs/pkgs/pgsql/glossary/glossary.html</a></i>
		adresinde bulunabilir.</p>
		
		<h4><a name="4.18">4.18</a>) Neden "<i>ERROR: Memory exhausted in AllocSetAlloc()</i>"
		hatasını alıyorum?</h4>
		<p>Sisteminizde sanal belleğinizi tüketmiş olabilirsiniz, ya da çekirdeğiniz
		belli kaynaklar icin düşük bir sınıra sahip olabilir. <i>postmaster</i>'ı
		başlatmadan önce aşağıdakileri deneyebilirsiniz:</p>
		<pre>
ulimit -d 262144
limit datasize 256m		
		</pre>
		<p>Kabuğunuza bağlı olarak, bunlardan sadece biri olumlu sonuç verecektir, ama
		bu işlem veri segment sınırınızı arttıracak, ve belki de sorgunuzun tamamlanmasını
		sağlayacaktır. Bu komut, varolan işleme (<i>current process</i>) ve komut çalıştırıldıktan
		sonraki tüm alt işlemlere uygulanır. Eğer SQL istemcinizle, <i>backend</i>'in çok
		fazla veri döndürmesi nedeniyle bir sorun yaşıyorsanız, bunu istemciyi başlatmadan
		önce deneyiniz.</p>
		
		<h4><a name="4.19">4.19</a>) Hangi PostgreSQL sürümünü çalıştırdığımı nasıl görebilirim?</h4>
		<p>psql arabiriminde, <code>select version();</code> yazınız.</p>
		
		<h4><a name="4.20">4.20</a>) Neden <i>large-object</i> işlemlerim, "<i>invalid large obj
		descriptor</i>" hatasını veriyor?</h4>
		<p><i>Large object</i> işlemlerinizin uçlarına, yani <code>lo_open</code> ...
		<code>lo_close</code> komutlarının çevresine, <code>BEGIN WORK</code> ve
		<code>COMMIT</code> koymanız gerekmektedir;</p>
		<p>Şu anda, PostgreSQL kuralları large objectleri transaction commit edildiğinde kapatarak 
	        uygulamaktadır. Dolayısıyla handle ile yapılacak ilk şey <i>invalid large obj descriptor</i> hatası 
		ile sonuçlanacaktır.Dolayısıyla çalışan kodunuz eğer transaction kullanmazsanız hata mesajları 
		üretecektir.</p>
		<p>Eğer ODBC gibi bir istemci arabirimi kullanıyorsanız, <i>auto-commit</i>'i
		kapatmanız gerekebilir.</p>
		
		<h4><a name="4.21">4.21</a>) Şu andaki zamanı öntanımlı değer olarak
		kabul eden <b>How do I create a column that will default to the current time?</b></h4>
		<p>Alttakini kullanabilirsiniz:</p>
		<pre>
CURRENT_TIMESTAMP:
CREATE TABLE test (x int, modtime timestamp DEFAULT CURRENT_TIMESTAMP );
		</pre>
		
		<h4><a name="4.22">4.22</a>) Neden <code>IN</code> kullanan <i>subquery</i>'lerim
		çok yavas?</h4>
		<p>7.4 sürümünden önce, subqueryler. Eğer subquery sadece birkaç satır ve outer query bol 
		sayıda satır döndürüyorsa, IN en hızlısıdır. Sorguları hızlandırmak için IN yerine EXISTS 
		kullanın:</p>
		<pre>
SELECT *
    FROM tab
    WHERE col1 IN (SELECT col2 FROM TAB2)
		</pre>
		<p>sorgusunu, aşağıdaki ile değiştirin:</p>
		<pre>
SELECT *
    FROM tab
    WHERE EXISTS (SELECT col2 FROM TAB2 WHERE col1 = col2)		
		</pre>
		<p>Bu işlemin hızlı olması için, subcol'un indexlenmiş bir kolon olması gerekmektedir.</p>
		<p>7.4 sürümü ve sonrasında, IN aslında normal sorgularla aynı karmaşık join tekniklerini kullanır ve 
		EXISTS'e tercih edilir.</p>

		<h4><a name="4.23">4.23</a>) <i>Outer join</i> işlemini nasıl yapabilirim?</h4>
		<p>PostgreSQL outer joins islemlerini SQL standartlarını kullanarak
		gerçekleştirmektedir. Aşağıda 2 örnek bulunmaktadır:</p>
		<pre>
SELECT *
FROM t1 LEFT OUTER JOIN t2 ON (t1.col = t2.col);		
		</pre>
		<p>ya da</p>
		<pre>
SELECT *
FROM t1 LEFT OUTER JOIN t2 ON (t1.col = t2.col);		
		</pre>
		<p>Bu özdeş sorgular t1.col' i t2.col'ye <i>join</i> ederler ve aynı zamanda t1'deki
		<i>unjoined</i> satırları (t2'de eşlenmemiş olanlarla) döndürürler. <code>RIGHT
		JOIN t2</code>'nin <i>unjoined</i> satırlarını ekleyecektir. Bir FULL join, eşleşmiş
		bütün satırları ve t1 ile t2'den tüm bağlanmamış (<i>unjoined</i>) satırları alır.
		<code>OUTER</code> sözcüğü seçimseldir ve <code>LEFT</code>, <code>RIGHT</code> ve
		<code>FULL</code> <i>join</i> işlemlerinde olduğu kabul edilir. Sıradan <i>join</i>
		işlemleri <code>INNER JOIN</code> olarak adlandırılır.</p>
		<p>Önceki sürümlerde, <code>OUTER JOIN</code>ler <code>UNION</code> ve <code>NOT IN</code>
		kullanılarak simüle edilebiliyordu. Örneğin, tab1 ve tab2'yi birleştirirken, aşağıdaki
		sorgu iki tablonun dıştan bağlanmasını sağlar:</p>
		<pre>
SELECT tab1.col1, tab2.col2
FROM tab1, tab2
WHERE tab1.col1 = tab2.col1
UNION ALL
SELECT tab1.col1, NULL
FROM tab1
WHERE tab1.col1 NOT IN (SELECT tab2.col1 FROM tab2)
ORDER BY col1		
		</pre>
		
		<h4><a name="4.24">4.24</a>) Aynı andan birden fazla veritabanında nasıl
		işlem yapabilirim?</h4>
		<p>Mevcut veritabanınız dışındaki başka bir veritabanınızı sorgulamanızın
		bir yolu bulunmamaktadır. Bunun nedeni, PostgreSQL'in veritabanına özel sistem
		katalogları yüklemesidir. Bu nedenle, cross-database bir sorgunun nasıl
		davranacağını kestirmek zordur.</p>
		<p>contrib/dblink fonksiyon çağrılarını kullanarak cross-database sorgulara
		izin verir. Tabii ki, bir istemci değişik veritabanlarına aynı anda erişim
		sağlayabilir ve bilgiyi bu şekilde birleştirebilir.</p>
		
		<h4><a name="4.25">4.25</a>) Bir fonksiyondan nasıl çoklu satır ya da 
		kolon döndürebilirim?</h4>
		<p>7.3 sürümünde, bir fonksiyondan kolaylıkla çoklu satır ya da sütun
		döndürebilirsiniz.
		(<i><a href="http://techdocs.postgresql.org/guides/SetReturningFunctions">http://techdocs.postgresql.org/guides/SetReturningFunctions</a></i>)</p>
		
		<h4><a name="4.26">4.26</a>) Neden Pl/PgSQL fonksiyonları içinden
		güvenli bir şekilde tablo yaratma/kaldırma işlemlerini yapamıyoruz?</h4>
		<p>PL/PgSQL fonksiyon içerikleri <i>cache</i>'ler. Bunun istenmeyen bir tarafı,
		eğer bir PL/PgSQL fonksiyonu geçici bir tabloya erişiyorsa ve bu tablo ileride
		kaldırılıp yeniden oluşturulduktan sonra fonksiyon yeniden çağrılırsa, fonksiyon
		çalışmayacaktır; çünkü <i>cache</i>'lenmiş fonksiyon hala eski geçici tabloyu
		gösteriyor olacaktır. Çözüm, geçici tablo erişimleri için PL/PgSQL'de
		<code>EXECUTE</code> kullanmaktır. Bu, sorgunun her seferinde yeniden işlenmesini
		sağlayacaktır.</p>
		
		<h4><a name="4.27">4.27</a>) 4.28) Hangi şifreleme seçenekleri bulunmaktadır?</h4>
		<ul><li>contrib/pgcrypto SQL sorgularında kullanılabilmesi için
		şifreleme fonksiyonları içermektedir.</li>
		<li> İstemciden sunucuya iletişimi şifrelemek için, sunucuda ssl seçeneği postgresql.conf içinde 
		açık olmalıdır. Ayrıca,pg_hba.conf dosyası içinde host ya da hostssl kaydı mutlaka olmalıdır ve 
		istemci sslmode kapatılmamalıdır. (Aynı zamanda,PostgreSQL'in doğal SSL bağlantıları dışında ssh ya 
		da ssl gibi 3.parti şifrelenmiş veri iletimi de mümkündür.)</li>
		<li>Veritabanı kullanıcı adı ve şifreleri 7.3 sürümü ile birlikte
		otomatik olarak şifrelenirler. Önceki sürümlerde, postgresql.conf
		içindeki PASSWORD_ENCRYPTION seçeneğini aktif hale getirmeniz gerekmektedir.</li>
		<li>Sunucunun kendisini şifreli dosya sistemi üzerinde çalıştırabilirsiniz.</li></ul>
		
		<hr>
		
	<h2 align="center">PostgreSQL Özelliklerini Genişletmek</h2>
		
		<h4><a name="5.1">5.1</a>) Kullanıcı-tanımlı bir fonksiyon yazdım.
		psql'de çalıştırdığım zaman neden core dump ediyor?</h4>
		<p>Sorunun nedeni birden fazla şey olabilir. Kullanıcı-tanımlı fonksiyonunuzu
		stand-alone bir programda çalıştırmayı deneyiniz.</p>
		
		<h4><a name="5.2">5.2</a>) PostgreSQL'e nasıl yeni tipler/fonksiyonlar ekleyebilirim?</h4>
		<p>Çalışmalarınızı pgsql-hackers e-posta listesine gönderiniz. Kodunuz
		incelendikten sonra contrib dizinine konacaktır.</p>
		
		<h4><a name="5.3">5.3</a>) Bir <i>tuple</i> dondürmek icin bir C fonksiyonunu nasil yazarım?</h4>
		<p>PostgreSQL 7.3 sürümü ile birlikte, C, PL/PgSQL ve SQL kullanılarak tablo-döndüren
		fonksiyonlar tamamen desteklenmektedir. Ayrıntılı bilgi için
		<i><a href="http://www.postgresql.com/docs/7.3/interactive/user.html">PostgreSQL 7.3.2
		Kullanıcı Rehberi</a></i>'ne bakabilrisiniz. Bir örneği contrib/tablefunc
		içinde bulabilirsiniz.</p>
		
		<h4><a name="5.4">5.4</a>) Bir kaynak dosyasında değişiklik yaptım. Yeniden derlememe
		rağmen değişiklik geçerli olmuyor. Neden?</h4>
		<p>Makefile'lar include dosyaları için tam bir bağımlılık içermezler. 
		Öncelikle make clean, ardından da baska bir make işlemi yapmanız gerekir.
		GCC kullanıyorsanız, configure betiğinin --enable-depend seçeneğini, derleyicinin
		bağımlılıkları otomatik olarak hesaplaması için kullanabilirsiniz.</p>
		
</body></html>
