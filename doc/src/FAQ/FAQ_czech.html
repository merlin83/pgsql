<html><head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
    <meta http-equiv="Content-language" content="cs">
    <meta name="robots" content="index,FOLLOW">
    <meta name="description" lang="en" content="Czech translation of FAQ for PostgreSQL"> 
    <meta name="description" lang="cs" content="Èeský pøeklad FAQ PostgreSQL"><title>PostgreSQL FAQ cz</title> 
  
    
    <style type="text/css">
      A {font-family:helvetica,arial,sans-serif; font-weight:normal; color:#0201FF; text-decoration:none;}
      A:active {color:#0201FF;;}
      A:visited {color:#0F0169;}
      A:hover{text-decoration:underline; color:#020169;}
      body {font-family:helvetica,arial,sans-serif; font-weight:normal;}
    </style></head>
  <body leftmargin="10" topmargin="10" marginwidth="10" marginheight="10" bgcolor="white">


<h1>Èasto kladené dotazy (FAQ) PostgreSQL</h1>

<h2>Obecné otázky</h2>
<a href="#1.1">1.1</a> Co je PostgreSQL? Jak se vyslovuje?<br>
<a href="#1.2">1.2</a> Jaká je licence na PostgreSQL?<br>
<a href="#1.3">1.3</a> Na kterých Unixex lze spustit PostgreSQL?<br>
<a href="#1.4">1.4</a> Které ne-unixové platformy jsou podporované?<br>
<a href="#1.5">1.5</a> Kde mohu získat PostgreSQL?<br>
<a href="#1.6">1.6</a> Kde mohu získat podporu?<br>
<a href="#1.7">1.7</a> Kde je poslední verze?<br>
<a href="#1.8">1.8</a> Jaká je dostupná dokumentace?<br>
<a href="#1.9">1.9</a> Kde najdu seznam známých chyb nebo nepodporovaných vlastností?<br>
<a href="#1.10">1.10</a> Jak se mohu nauèit SQL?<br>
<a href="#1.11">1.11</a> Nemá PostgreSQL problémy s rokem 2000?<br>
<a href="#1.12">1.12</a> Jak se pøipojit k vývojáøskému týmu?<br>
<a href="#1.13">1.13</a> Kam podat report o chybì?<br>
<a href="#1.14">1.14</a> Jak je na tom PostgreSQL v porovnání s jinými databázemi?<br>
<a href="#1.15">1.15</a> Jak lze finanènì pomoci PostgreSQL?<br>

<h2>User client dotazy</h2>

<a href="#2.1">2.1</a> Kde naleznu ODBC ovladaèe pro PostgreSQL?<br>
<a href="#2.2">2.2</a> Jaké nástroje lze pou¾ít pro PostgreSQL a web?<br>
<a href="#2.3">2.3</a> Existuje grafické rozhraní pro PostgreSQL?<br>
<a href="#2.4">2.4</a> Které programovací jazyky mají podporu pro PostgreSQL?<br>

<h2>Administrativní dotazy</h2>
<a href="#3.1">3.1</a> Jak nainstalovat PostgreSQL jinam ne¾ do /usr/local/pgsql?<br>
<a href="#3.2">3.2</a> Pøi startu postmaster, dostanu chybové hlá¹ení Bad System Call nebo
core dump. Proè?<br>
<a href="#3.3">3.3</a> Pøi startu postmastera dostanu hlá¹ení o chybì IpcMemoryCreate. Proè?<br>
<a href="#3.4">3.4</a> Pøi startu postmastera dostanu hlá¹ení o chybì
IpcSemaphoreCreate. Proè?<br>
<a href="#3.5">3.5</a> Jak povolit nebo zakázat pøístup z jiných stanic?<br>
<a href="#3.6">3.6</a> Jak ladit databázový stroj na lep¹í výkon?<br>
<a href="#3.7">3.7</a> Jaké jsou mo¾nosti ladìní?<br>
<a href="#3.8">3.8</a> Proè dostanu "Sorry, too many clients", kdy¾ se zkou¹ím pøipojit?<br>
<a href="#3.9">3.9</a> K èemu slou¾í adresáø pgsql_tmp?<br>
<a href="#3.10">3.10</a> Proè je po¾adováno dump a obnovení (load) databáze bìhem upgrade
mezi velkými verzemi PostgreSQL?<br>
<h2>Provozní dotazy</h2>
<a href="#4.1">4.1</a> Èím se li¹í binární a normální kurzor?<br>
<a href="#4.2">4.2</a> Jak získat pouze první øádek dotazu? Náhodný øádek?<br>
<a href="#4.3">4.3</a> Jak získám seznam tabulek nebo jinak jak jej získá psql?<br>
<a href="#4.4">4.4</a> Jak odstraním sloupec tabulky, jak zmìním jeho typ?<br>
<a href="#4.5">4.5</a> Jaká je maximální velikost øádku, tabulky a databáze?<br>
<a href="#4.6">4.6</a> Kolik diskového prostoru je potøeba k ulo¾ení dat z normálního
textového souboru? <br>
<a href="#4.7">4.7</a> Jak získám seznam vytvoøených tabulek, indexù, databází?<br>
<a href="#4.8">4.8</a> Mùj dotaz je pomalý a nepou¾ívá vytvoøené indexy. Proè?<br>
<a href="#4.9">4.9</a> Jak zjistím, jak optimizer dotazu vyhodnocuje mùj dotaz?<br>
<a href="#4.10">4.10</a> Co to je R-tree index?<br>
<a href="#4.11">4.11</a> Co je Genetic Query Optimizer?<br>
<a href="#4.12">4.12</a> Jak provést vyhledávání regulárního výrazu case sensitiv,
insensitiv? Jak pou¾ít index pro case insensitive vyhledávání?<br>
<a href="#4.13">4.13</a> Jak v dotazu detekovat, ¾e polo¾ka je NULL?<br>
<a href="#4.14">4.14</a> Jaké jsou rozdíly mezi rùznými znakovými typy?<br>
<a href="#4.15.1">4.15.1</a> Jak vytvoøit serial/auto-increment pole?<br>
<a href="#4.15.2">4.15.2</a> Jak získat hodnotu SERIAL po vlo¾ení øádku?<br>
<a href="#4.15.3">4.15.3</a> Nepovede currval() a nextval() k rozhození podmínek pøi soubìhu s jinými u¾ivateli?<br>
<a href="#4.15.4">4.15.4</a> Proè není vygenerované èíslo pou¾ito pøi pøeru¹ení
transakce? Proè vznikají díry v èíslování vlastní sekvencí/SERIAL
sloupce?<br>
<a href="#4.16">4.16</a> Co to je OID? Co je to TID?<br>
<a href="#4.17">4.17</a> Jaký je význam nìkterých výrazù pou¾itých v PostgreSQL?<br>
<a href="#4.18">4.18</a> Proè jsem získal chybové hlá¹ení "ERROR: Memory exhausted in
AllocSetAlloc()"?<br>
<a href="#4.19">4.19</a> Jak se dozvím, kterou verzi PostgreSQL pou¾ívám?<br>
<a href="#4.20">4.20</a> Proè operace s velkými objekty konèí "invalid large obj descriptor"?<br>
<a href="#4.21">4.21</a> Jak vytvoøit sloupec obsahující implicitnì aktuální datum?<br>
<a href="#4.22">4.22</a> Proè jsou moje vnoøené dotazy pou¾ívající IN tak pomalé?<br>
<a href="#4.23">4.23</a> Jak provést vnìj¹í spojení (outer join)?<br>
<a href="#4.24">4.24</a> Jak provést dotaz napøíè nìkolika databázemi?<br>
<a href="#4.25">4.25</a> Mù¾e funkce vrátit více øádkù nebo sloupcù?<br>
<a href="#4.26">4.26</a> Proè nelze spolehlivì vytváøet a ru¹it doèasné tabulky v
PL/pgSQL funkcích?<br>
<a href="#4.27">4.27</a> Jaké jsou mo¾nosti replikace databází?<br>
<a href="#4.28">4.28</a> Jaké jsou mo¾nosti ¹ifrování databází?<br>
<h2>Roz¹iøování PostgreSQL</h2>
<a href="#5.1">5.1</a> Napsal jsem UDF funkci, PostgreSQL v¹ak konèí dump core?<br>
<a href="#5.2">5.2</a> Jak mohu pøispìt nìjakými ¹ikovnými datovými typy a funkcemi
do PostgreSQL?<br>
<a href="#5.3">5.3</a> Jak napsat funkci v C vracející ntici?<br>
<a href="#5.4">5.4</a> Modifikoval jsem zdrojové soubory. Tato zmìna nebyla pøi
rekompilaci vzata v potaz. Proè?<br>




<hr>
<h2>Obecné otázky</h2>

<h3><a name="1.1">1.1</a> Co je PostgreSQL? Jak se vyslovuje?</h3>

<p>PostgreSQL se vyslovuje Post-Gres-Q-L.</p>

<p></p>PostgreSQL vychází z databáze POSTGRES - výzkumného prototypu DBMS
nové generace. Z postgresu byl pøevzat silný datový model a bohatý
soubor datových typù a jeho dotazovací jazyk PostQuel byl nahrazen
roz¹íøenou podmno¾inou jazyka SQL. PostgreSQL lze pou¾ívat bez
omezení a jeho zdrojové kódy jsou volnì k dispozici.<p></p>

<p>PostgreSQL vyvýjí tým vývojáøù pøihlá¹ených do vývojáøské konference
PostgreSQL. Souèasným koordinátorem je Marc G. Fournier. (Odpovìï
1.6. - jak se zapojit). Tento tým je zodpovìdný za ve¹kerý vývoj
PostgreSQL.</p>

<p>Autory první verze PostgreSQL 1.01 byli Andrew Yu and Jolly
Chen. Do portace, testování, ladìní a
roz¹iøování kódu se zapojilo mnoho dal¹ích vývojáøù . Pùvodni kód Postgresu, ze kterého PostgreSQL
vychází, je výsledkem úsilí mnoha studentù a programátorù pracujících
pod vedením prof. Michaela Stonebrakera na University of California v
Berkley.</p>

<p>Pùvodní název software z Berkley byl Postgres. Po pøidání jazyka SQL
se název zmìnil na Postgres95. Koncem roku 1996 byl RDBMS 
pøejmenován na PostgreSQL.</p>

<h3><a name="1.2">1.2</a> Jaká je licence na PostgreSQL?</h3>

 <p>PostgreSQL je pøedmìtem následujících autorských práv:</p>

 <p>Dílèí copyright (c) 1996-2002, PostgreSQL Global Development Group</p>

 <p>Dílèí copyright (c) 1994-6, Regents of the University of California</p>


 <p>Udìluje se oprávnìní k u¾ití, rozmno¾ování, provádìní úprav a
 roz¹iøování tohoto softwaru a dokumentace k nìmu, pro jakékoli úèely,
 bez licenèního poplatku a bez písemné licenèní smlouvy, za podmínky, ¾e
 na v¹ech jeho kopiích je uvedeno oznámení o vý¹e uvedených právech,
 jako¾ i obsah tohoto a dvou následujících odstavcù.</p>


 <p>THE UNIVERSITY OF CALIFORNIA ("KALIFORNSKÁ UNIVERZITA") NENÍ V ®ÁDNÉM
 PØÍPADÌ ODPOVÌDNA ®ÁDNÉ TØETÍ OSOBÌ ZA PØÍMOU, NEPØÍMOU, ZVLÁ©TNÍ,
 NAHODILOU NEBO VýSLEDNOU ©KODU, VÈETNÌ U©LÉHO ZISKU, ZPùSOBENOU U®ITÍM
 TOHOTO SOFTWARU A DOKUMENTACE K NÌMU, A TO I V PØÍPADÌ, ®E THE
 UNIVERSITY OF CALIFORNIA BYLA INFORMOVÁNA O MO®NOSTI VZNIKU TAKOVÉ ©KODY.</p>


  <p>THE UNIVERSITY OF CALIFORNIA ZEJMÉNA NEPOSKYTUJE JAKÉKOLI ZÁRUKY, A TO
 NEJEN ZÁRUKY OBCHODOVATELNOSTI A VHODNOSTI TOHOTO VýROBKU KE SPECIFICKýM
 ÚÈELùM. NÍ®E UVEDENý SOFTWARE JE POSKYTNUT "JAK STOJÍ A LE®Í" A THE
 UNIVERSITY OF CALIFORNIA NENÍ POVINNA ZAJISTIT JEHO ÚDR®BU, PODPORU,
 AKTUALIZACI, VYLEP©ENÍ NEBO MODIFIKACI.</p>

 <p>Vý¹e uvedené je BSD licence, bì¾ná licence otevøeného zdroje. Není zde
 ¾ádné omezení ohlednì u¾ití kódu zdroje. Jsme s tím spokojeni a nemáme v
 úmyslu na této skuteènosti cokoli mìnit.</p>


<h3><a name="1.3">1.3</a> Na kterých Unixex lze spustit PostgreSQL?</h3>

<p>PostgreSQL bì¾í na v¹ech moderních unixových platformách. V instalaèních
instrukcích naleznete aktuální seznam v¹ech platforem na kterých byla
testováním ovìøena funkcionalita PostgreSQL.</p>

<h3><a name="1.4">1.4</a> Které ne-unixové platformy jsou podporované?</h3>

<h4>Klient</h4>

<p>Knihovna libpq, psql a nìkteré dal¹í moduly byly pøelo¾eny pro 
MS Windows. Klienta lze provozovat na MS Windows, ten prostøednictvím
TCP/IP protokolu komunikuje se serverem bì¾ícím na nìkteré z podporovaných
Unixových platforem. K pøekladu lze pou¾ít win32.mak a
Win32 knihovny libpq a psql. K databázi PostgerSQL lze pøistupovat skrze
rozhraní ODBC.</p>

<h4>Server</h4>
<p>Server mù¾e být na WindowsNT a Win2k provozován pouze s knihovnou Cygwin,
Cygnus Unix/NT porting library. Na nativním portu pro MS Win NT/2000/XP
se pracuje. Existující port pro Novell Netware 6 naleznete na 
<a href="http://forge.novell.com/">http://forge.novell.com</a>. </p>

<h3><a name="1.5">1.5</a> Kde mohu získat PostgreSQL?</h3>

<p>Primárním anonymním ftp serverem pro PostgreSQL je
<a href="ftp://ftp.postgresql.org/pub">ftp://ftp.PostgreSQL.org/pub</a>
. Seznam zrcadel naleznete na na¹ich
webových stránkách.</p><p>

</p><h3><a name="1.6">1.6</a> Kde mohu získat podporu?</h3>

<p>Hlavním mailová konference je pgsql-general@PostgreSQL.org. Slou¾í
k diskuzím ohlednì PostgreSQL. Pøihlásíte se zasláním mailu 
obsahující následující øádky v tìle dopisu (nikoliv v záhlaví - subjectu)</p>
<pre>subscribe
end
</pre>
na adresu <a href="mailto:pgsql-general-request@PostgreSQL.org">mailto:pgsql-general-request@PostgreSQL.org</a>.<p></p>

<p>Mù¾ete si vy¾ádat denní pøehled (diggest), který má zhruba 30K dennì zpráv.

</p><p>Konference psql-bugs je urèena k zasílání zpráv o chybách. Pro pøihlá¹ení 
po¹lete mail se stejným obsahem jako v pøedchozím pøípadì na adresu 
<href ="mailto:pgsql-bugs-request@PostgreSQL.org">mailto:pgsql-bugs-request@PostgreSQL.org.</href></p>

<p>Do vývojáøské konference se pøihlásíte odesláním dopisu s 
ji¾ zmiòovaným obsahem na <a href="mailto:pgsql-hackers-request@PostgreSQL.org">mailto:pgsql-hackers-request@PostgreSQL.org</a>.</p>

<p>Seznam dal¹ích konferencí naleznete na stránkách PostgreSQL 
<a href="http://www.postgresql.org/">http://www.postgresql.org</a></p>

<h3><a name="1.7">1.7</a> Kde je poslední verze?</h3>

<p>Poslední verzí je PostgreSQL 7.4.. Plánujeme uvolnit velkou verzi
ka¾dých ¹est a¾ osm mìsícù.</p>

<h3><a name="1.8">1.8</a> Jaká je dostupná dokumentace?</h3>

<p>Rùzné manuály, manuálové stránky a nìkolik malých testovacích pøíkladù
jsou souèásti distribuce. Podívejte se do adresáøe /doc. Manuály jsou
pøístupné online na <a href="http://www.postgresql.org/docs">http://www.PostgreSQL.org/docs</a>.</p>

<p>Na adresách <a href="http://www.postgresql.org/docs/awbook.html">http://www.PostgreSQL.org/docs/awbook.html</a> a
<a href="http://www.commandprompt.com/ppbook/">http://www.commandprompt.com/ppbook/</a> naleznezte dvì online knihy o
PostgreSQL. Seznam dostupné literatury je na
<a href="http://techdocs.postgresql.org/techdocs/bookreviews.php">http://techdocs.PostgreSQL.org/techdocs/bookreviews.php</a>. Soubor
technických èlánkù s tematikou PostgresQL najdete na
<a href="http://techdocs.postgresql.org/">http://techdocs.PostgreSQL.org/</a>.</p> 

<p>psql má u¾iteèný metapøíkaz \d slou¾ící k zobrazení informací
o typech, operátorech, funkcí, agregaèních funkcí atd.</p>

<p>Více dokumentace naleznete na na¹ich webových stránkách.</p>

<h3><a name="1.9">1.9</a> Kde najdu seznam známých chyb nebo nepodporovaných vlastností?</h3>

<p>PostgreSQL podporuje roz¹íøenou podmno¾inu SQL-92. V na¹em <a href="http://developer.postgresql.org/todo.php">TODO</a> najdete
seznam známých chyb, chybìjících vlastností a seznam vlastností,
které budou do systému implementovány v budoucnu (vèetnì priorit).</p>

<h3><a name="1.10">1.10</a> Jak se mohu nauèit SQL?</h3>

<p>V knize The PostgreSQL book na <a href="http://www.postgresql.org/docs/awbook.html">http://www.PostgreSQL.org/docs/awbook.html</a>
je vysvìtlen jazyk SQL (vy¹la èesky). Dal¹í dostupnou knihou je
<a href="http://www.commandprompt.com/ppbook">http://www.commandprompt.com/ppbook</a>. Kvalitní návody naleznete na
<a href="http://www.intermedia.net/support/sql/sqltut.shtm">http://www.intermedia.net/support/sql/sqltut.shtm</a>, na
<a href="http://ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM">http://www.intermedia.net/support/sql/sqltut.shtm</a>,
a na <a href="http://sqlcourse.com/">http://sqlcourse.com</a>.</p>

<p>Dal¹í je Teach Yourself SQL in 21 days, Second Edition na
<a href="http://members.tripod.com/er4ebus/sql/index.htm">http://members.tripod.com/er4ebus/sql/index.htm</a>.</p>

<p>Mnoho u¾ivatelù doporuèuje The Practical SQL Handbook, Bowman, Judith
S., et al., Addison-Wesley. Jiní preferují The Complete Reference SQL,
Groff et al., McGraw-Hill.</p>

<h3><a name="1.11">1.11</a> Nemá PostgreSQL problémy s rokem 2000?</h3>

<p>Nemá, mù¾eme pracovat s datumy po roce 2000 na¹eho letopoètu i pøed
rokem 2000 pø.n.l. </p>

<h3><a name="1.12">1.12</a> Jak se pøipojit k vývojáøskému týmu?</h3>

<p>Nejdøíve si stáhnìte nejnovìj¹í zdroje a pøeètìte si vývojáøskou
dokumentaci na na¹em webu nebo v distribuci. Pak se pøihla¹te do
konferencí pgsql-hackers a pgsql-patches. Kvalitní záplaty
posílejte do pgsql-patches.</p>

<p>Právo commit má v cvs archivu asi tøinácti lidí. Ka¾dý z nich
poslal mnoho kvalitních záplat, tak¾e tehdej¹í commiters mìli
jistotu, ¾e budou pøedkládat jenom kvalitní záplaty a mohli jim
pøedìlit vìt¹í práva.</p>

<h3><a name="1.13">1.13</a> Kam podat report o chybì?</h3>

<p>Nav¹tivte na¹i PostgreSQL BugTool stránku na
<a href="http://www.postgresql.org/bugs/bugs.php">http://www.PostgreSQL.org/bugs/bugs.php</a>, která obsahuje návod a
smìrnice jak podat chybový report. </p>

<p>Ovìøte si na na¹em ftp serveru <a href="ftp://ftp.postgresql.org/pub">ftp://ftp.PostgreSQL.org/pub</a>, zda-li
máte nejnovìj¹í verzi PostgreSQL a zda-li k ní neexistují nìjaké záplaty.</p>

<h3><a name="1.14">1.14</a> Jak je na tom PostgreSQL v porovnání s jinými databázemi?</h3>

<p>Existuje nìkolik hledisek jak porovnávat software: vlastnosti, výkon,
spolehlivost, podpora a cena.</p>

<h4>Vlastnosti</h4>
	<p>PostgreSQL má hodnì spoleèných vlastností s velkými komerèními
	DBMS, napø. transakce, vnoøené dotazy, spou¹tì, pohledy,
	kontrolu referenèní integrity a sofistikované
	zamykání. Podporuje nìkteré vlastnosti, které tyto systémy
	nemají, u¾ivatelem definované typy, dìdiènost, pravidla, MVCC
	redukující zamykání.</p>

<h4>Výkon</h4>
	<p>Výkonnostnì je na tom PostgreSQL podobnì jako dal¹í komerèní
	ale i open source databáze, v nìèem je rychlej¹í, jindy
	pomalej¹í. V porovnání s MySQL a podobnými databázovými
	systémy je PostgreSQL rychlej¹í pøi víceu¾ivatelském
	pøístupu, slo¾itìj¹ích dotazech a zatí¾ení read/write dotazy. MySQL
	je rychlej¹í v jednodu¹¹ích dotazech s malým poètem
	u¾ivatelù. Navíc, MySQL nepodporuje mnohé vlatnosti zmínìné v
	sekci vlastnosti. Zapracovali jsme na spolehlivosti a podporovaných
	vlastnostech, a výkon zvy¹ujeme v ka¾dé
	verzi. Zajímavou stránku porovnávající PostgreSQL a MySQL
	naleznete na
	<a href="http://openacs.org/philosophy/why-not-mysql.html">http://openacs.org/philosophy/why-not-mysql.html</a>. Za vývojem MySQL 
 	není Open Source komunita, ale komerèní spoleènost, pøesto¾e 
	svoje produkty distribuuje jako Open Source.</p>

<h4>Spolehlivost</h4>
	<p>Jsme si vìdomi, ¾e databáze musí být spolehlivá, jinak je
	nepou¾itelná. Sna¾íme se zveøejòovat dobøe otestovaný, stabilní kód s
	minimem chyb. Ka¾dá verze je více ne¾ mìsíc v beta testování,
	a na¹e historie verzí ukazuje, ¾e mù¾eme nabídnout stabilní,
	solidní verze, které jsou pøipraveny pro reálné nasazení. V
	této oblasti jsme srovnatelní s dal¹ími databázemi. </p>

<h4>Podpora</h4>
	<p>Na na¹í mailové konferenci mù¾ete kontaktovat velkou skupinu
	vývojáøù a u¾ivatelù.problémù. Nemù¾eme garantovat opravu, 
	nicménì komerèní databáze také ne v¾dy nabídnou opravu. Podle ohlasù
	je na¹e podpora hodnocena lépe ne¾ u jiných DBMS a to díky
	pøímému kontaktu s vývojáøi, velkou komunitou u¾ivatelù, 
	kvalitními manuály a pøístupným zdrojovým kódem. Pro u¾ivatele, 
	kteøí vy¾adují podporu ke konkrétním pøípadùm, existuje placená podpora
	(FAQ sekce 1.6).</p>

<h4>Cena</h4>
	<p>PosgreSQL lze volnì pou¾ívat pro nekomerèní i komerèní
	pou¾ití. Mù¾ete do svých produktù pøidat ná¹ kód bez omezení,
	respektive v souladu s podmínkami na¹í licenèní smlouvy (v duchu BSD
	licence).</p>

<h3><a name="1.15">1.15</a> Jak lze finanènì pomoci PostgreSQL?</h3>

<p>PosgreSQL má prvotøídní infrastrukturu od na¹eho zaèátku v roce
1996. Vdìèíme za to Marku Fournierovi, který zalo¾il a spravoval tuto
infrastrukturu nìkolik let.</p>

<p>Kvalitní infrastruktura je velice dùle¾itá pro ka¾dý open source
projekt. Pøedchází nedorozumìním, která velice zdr¾ují pokrok v projektu.</p>

<p>Tato infrastruktura není laciná. K jejímu zaji¹tìní je tøeba stále hradit urèité
mìsíèní a jednorázové èástky. Pokud máte Vy nebo Va¹e spoleènost
peníze, které nám mù¾ete darovat, obra»e se na <a href="http://store.pgsql.com/shopping/">http://store.pgsql.com/shopping/</a> a darujte je.</p>

<p>Aèkoliv webová stránka zmiòuje PostgreSQL, Inc. vklady jsou urèeny
pouze k podpoøe projektu PostgreSQL a nepodporují ¾ádnou existující
spoleènost. Pokud to vy¾adujete, mù¾ete poslat kontrolu na na¹i kontaktní
adresu.</p> 

<p>Pokud máte pøíklad úspì¹ného nasazení PostgreSQL, pøihla¹tì se na ná¹
advocacy site na  <a href="http://advocacy.postgresql.org/">http://advocacy.postgresql.org</a>.</p>
<hr>

<h2>User client dotazy</h2>

<h3><a name="2.1">2.1</a> Kde naleznu ODBC ovladaèe pro PostgreSQL?</h3>

<p>Pro PostgreSQL existují dva ODBC ovladaèe - PsqlODBC a OpenLink ODBC.</p>

<p>PsqlODBC je ke sta¾ení na <a href="http://gborg.postgresql.org/project/psqlodbc/projdisplay.php">http://gborg.postgresql.org/project/psqlodbc/projdisplay.php</a>.</p> 

<p>OpenLink mù¾ete získat na <a href="http://www.openlinksw.com/">http://www.openlinksw.com</a>. Spolupracuje 
s jejich klientským programovým vybavením a je dostupný pro v¹echny jimi 
podporované platformy (Win, Mac, Unix, VMS).</p> 

<p>Tento ovladaè je urèen pro ty, kteøí vy¾adují podporu komerèní kvality,
nicménì freeware verze je dostupná a funkèní. Dotazy zasílejte
na postgres95@openlink.co.uk.</p>

<h3><a name="2.2">2.2</a> Jaké nástroje lze pou¾ít pro PostgreSQL a web?</h3>

<p>Pìkný úvod do databázových technologií zabezpeèujících chod
webových stránek najdete na <a href="http://www.webreview.com/">http://www.webreview.com</a>.</p>

<p>Pro tvorbu webu existuje excelentní rozhraní PHP, které naleznete na
<a href="http://www.php.net/">http://www.php.net</a>.</p> 

<p>Pro slo¾itìj¹í pøípady se èasto pou¾ívá Perl a CGI.pm nebo mod_perl.</p>

<h3><a name="2.3">2.3</a> Existuje grafické rozhraní pro PostgreSQL?</h3>

<p>Pro PostgreSQL existuje nìkolik grafických rozhraní: 
PgAccess (<a href="http://www.php.net/">http://www.php.net</a>), PgAdmin (<a href="http://www.php.net/">http://www.php.net</a>), RHDB
Admin (<a href="http://sources.redhat.com/rhdb/">http://sources.redhat.com/rhdb/</a>) a Rekall
(<a href="http://www.thekompany.com/products/rekall/">http://www.thekompany.com/products/rekall/</a>). Dále existuje
PHPPgAdmin (<a href="http://phppgadmin.sourceforge.net/">http://phppgadmin.sourceforge.net/</a>) rozhraní
PostgreSQL zalo¾ené na web technologii.</p>

<p>Úplnìj¹í seznam najdete na <a href="http://techdocs.postgresql.org/guides/GUITools">http://techdocs.postgresql.org/guides/GUITools</a>.</p>

<h3><a name="2.4">2.4</a> Které programovací jazyky mají podporu pro PostgreSQL?</h3>

<p>Vìt¹ina programovacích jazykù obsahuje rozhraní pro
PostgreSQL. Podívejte se do roz¹iøujících modulù Va¹eho programovacího
jazyka.</p>

<p>Distribuce PostgreSQL obsahuje tato rozhraní:
  </p><ul>
  <li> C (libpq)
  </li><li> Embbedded C (ecpg)
  </li><li> Java (jdbc)
  </li><li> Python (PyGreSQL)
  </li><li> TCL (libpgtcl)
</li></ul>
<p>Dal¹í rozhraní jsou dostupná na <a href="http://gborg.postgresql.org/">http://gborg.postgresql.org</a> v sekci
Drivers/Interfaces. </p>
<hr>

<h2>Administrativní dotazy</h2>

<h3><a name="3.1">3.1</a> Jak nainstalovat PostgreSQL jinam ne¾ do /usr/local/pgsql?</h3>

<p>Pou¾ijte volbu --prefix pøi spu¹tìní configure</p>

<h3><a name="3.2">3.2</a> Pøi startu postmaster, dostanu chybové hlá¹ení Bad System Call nebo
core dump. Proè?</h3>

<p>Dùvody mohou být rùzné, ale nejprve zkontrolujte, zda Vá¹ systém
podporuje System V extensions. PostgreSQL vy¾aduje v jádøe podporu
sdílené pamìti a semaforù.</p>

<h3><a name="3.3">3.3</a> Pøi startu postmastera dostanu hlá¹ení o chybì IpcMemoryCreate. Proè?</h3>

<p>Buïto nemáte správnì nakonfigurovanou sdílenou pamì» v jádøe nebo
musite zvìt¹it její velikost. Potøebná velikost je závislá na
architektuøe a na tom, kolik pamì»ových bufferù a backendù máte povoleno 
pro postmastera. Pro vìt¹inu systémù s 
pøeddefinovaným poètem backendù a pamì»ových bufferù je
minimum zhruba 1MB. V <a href="http://postgresql.ok.cz/PostgreSQL%20Administrator%27sGuide">http://www.postgresql.org/docs/view.php?version=current&amp;idoc=1&amp;file=kernel-resources.html</a>
naleznete podrobnìj¹í informace o sdílené pamìti a semaforech.</p> 

<h3><a name="3.4">3.4</a> Pøi startu postmastera dostanu hlá¹ení o chybì
IpcSemaphoreCreate. Proè?</h3>

<p>Pokud dostane chybovou zprávu IpcSemaphoreCreate: semget failed (No
space left on device), pak va¹e jádro nemá dost volných  semaforù. PostgreSQL
vy¾aduje jeden semafor pro ka¾dý backend v pozadí. Doèasným
øe¹ením je start postmastera s limitem backendù. Pou¾ijte
pøepínaè -N s hodnotou men¹í ne¾ 32. Úplným øe¹ením je zvý¹ení hodnot
SEMMNS a SEMMNI jadra.</p>

<p>Nefunkèní semafory mohou zpùsobit pád bìhem intenzivních databázových
operací.</p>

<p>Pokud se tato chyba vyskytuje je¹tì nìkde jinde, mo¾ná nemáte vùbec
nakonfigurovány semafory ve va¹em jádøe. V PostgreSQL
Administrator's Guide najdete podrobnìj¹í popis po¾adavkù na sdílenou
pamìt a semafory.</p>

<h3><a name="3.5">3.5</a> Jak povolit nebo zakázat pøístup z jiných stanic?</h3>

<p>Pøi výchozím nastavení PostgreSQL odepøe pøístup z jiných stanic ne¾
lokální s pou¾itím UDP. Databáze se zpøístupní jiným stanicím
nastavením pøepínaèe -i postmastera a povolením stanice a urèením
re¾imu autentifikace v $PGDATA/pg_hba.conf. Tím se povolí TCP/IP
spojení. ZASTARALÉ</p>

<h3><a name="3.6">3.6</a> Jak ladit databázový stroj na lep¹í výkon?</h3>

<p>Urèitì pomohou indexy. Pøíkaz EXPLAIN zobrazí zpùsob interpretace
Va¹eho dotazu a pou¾ití indexù.</p>

<p>Pøi vìt¹í dávce INSERTù uva¾ujte o náhradì pøíkazem COPY. Ten je
mnohem rychlej¹í ne¾li samotný INSERT. Ka¾dý pøíkaz mimo blok
BEGIN WORK/COMMIT se provádí ve vlastní transakci. Zva¾te, zda-li by
se nedalo nìkolik pøíkazù spojit do jedné transakce. Tím se sní¾í
re¾ie na transakce. Pøed provedením rozsáhlých zmìn zru¹te indexy, 
které po dokonèení zmìn opìt vytvoøte.</p>

<p>Máte nìkolik dal¹ích mo¾ností, jak zlep¹it výkon. Mù¾ete zakázat fsyn()
pøi startu postmastera pøepínaèi -o -F. Tyto pøepínaèe zabrání
fsync(), tj. zápisu na disk po ka¾dé transakci.</p>

<p>Mù¾ete zvý¹it velikost pamì»ových bufferù pou¾itých backendy
tj. parametr -B postmasteru. Pokud ale tato hodnota bude pøíli¹
velká, tak mo¾ná nespustíte postmastera jeliko¾ dosáhnete limitu
sdílené pamìti. Ka¾dý buffer má 8K a implicitnì je 64 bufferù.</p>

<p>Dále mù¾ete pou¾ít pøepínaè -S k zvý¹ení limitu pamìti pro backendy
na doèasné tøídìní. Hodnota je mínìna v kilobytech a výchozí
nastavení je 512, tj. 512K. </p>

<p>Mù¾ete pou¾ít pøíkaz CLUSTER, který uspoøádá fyzicky data v
tabulkách podle indexu. Více na manuálových stránkách pøíkazu
CLUSTER.</p>

<h3><a name="3.7">3.7</a> Jaké jsou mo¾nosti ladìní?</h3>

<p>Máte nìkolik mo¾ností jak se dostat k u¾iteèným stavovým informacím.</p>

<p>Zaprvé, pøi pøekladu pou¾ijte pøepínaè --enable-cassert, tím se zapne
monitorování a následné zastavení aplikace, kdy¾ se proces v backendu
dostane do neoèekávaného stavu.</p>

<p>Jak postmaster tak postgres má nìkolik pøepínaèù umo¾òujících
ladìní. Postmaster nastartujte tak, abyste si byli jisti, ¾e je
standartní výstup a standartní chybový výstup pøesmìrován do souboru
logu, napøíklad:</p>
<pre>cd /usr/local/pgsql
./bin/postmaster &gt; server.log 2&gt;&amp;1 &amp;
</pre>
<p>Tím se vytvoøí log v adresáøi PostgreSQL, Tento soubor obsahuje
u¾iteèné informace o problémech a chybách vyskytlých se na
serveru. Postmaster má pøepínaè -d urèující, jak podrobné mají být
reportované informace, tj. debug level. Pozor, pøi velké hodnotì debug
levelu rychle roste velikost souboru logu.</p>

<p>Pokud nebì¾í postmaster, mù¾ete spustit backend PostgreSQL z pøíkazové
øádky a napsat svùj SQL dotaz pøímo v backendu (doporuèeno pouze pro
ladìní). Dotaz je v tomto pøípadì ukonèen novou øádkou, nikoliv
støedníkem. Pokud máte aplikaci pøelo¾enou s ladícími symboly, mù¾ete
pou¾ít debbuger k monitorování procesu. Pokud není backend spu¹tìn 
postmasterem, pak nebì¾í ve svém obvyklém prostøedí a tudí¾ nìkteré problémy
dané interakcí mezi backendy nemohou být nasimulovány.</p>

<p>Pokud bì¾í postmaster, spus»e psql v jednom oknì a pak si zjistìte PID
procesu postgres pou¾itého psql. V debuggeru sepøipojte k postgresql
PID. Pak nastavte breakpointy v debuggeru a zadejte dotaz v
psql. Pokud ladíte startup postgresu, pak nastavte PGOPTIONS="-W n" a
spus»e psql. Tento pøepínaè zpùsobí pauzu n sekund, tak¾e budete mít
èas se pøipojit k procesu, a nastavit breakpointy a pokraèovat v
startup posloupnosti.</p>

<p>Pro ladìní a mìøení výkonu mohou být u¾iteèné pøepínaèe -s, -A a -t
programu postgres (backend).</p>

<p>Mù¾ete provést pøeklad s profilací, tak abyste vidìli kolik èasu
zabírají jednotlivé funkce. Soubory s profily backendù jsou ulo¾eny v
adresáøi pgsql/data/base/dbname. Profil klienta pak v jeho aktuálním
adresáøi. Korektní profilace v prostøedí Linux po¾aduje konfiguraci 
systému s parametrem -DLINUX_PROFILE.</p>

<h3><a name="3.8">3.8</a> Proè dostanu "Sorry, too many clients", kdy¾ se zkou¹ím pøipojit?</h3>

<p>Zvy¹te limit postmastera na maximální poèet souèasnì spu¹tìných backendù.</p>

<p>Výchozí hodnota je 32 backendù. Tuto hodnotu zvý¹íte zastavením a 
opìtovným spu¹tìním postmastera s parametrem -N nebo úpravou postgresql.conf.</p>

<p>Pøi zvý¹ení hodnoty -N nad 32 musíte zvý¹it hodnotu -B nad výchozí 64,
-B musí být minimálnì dvakrát vìt¹í, nebo je¹tì lépe více. Pravdìpodobnì
zjistíte, ¾e pro velký poèet procesù backendu je nutné zvý¹it nìkteré 
parametry jádra. Jsou to pøedev¹ím maximální velikost sdílené pamìti SHMMAX, 
maximální poèet semafórù SEMMNS a SEMMNI, maximální poèet procesù NPROC, 
maximální poèet procesù u¾ivatele MAXUPRC a maximální poèet otevøených souborù
NFILE a NINODE. Dùvod pro omezení maximálního poètu backendù je fakt,
¾e by mohlo dojít k vyèerpání zdrojù Va¹eho systému.</p>

<h3><a name="3.9">3.9</a> K èemu slou¾í adresáø pgsql_tmp?</h3>

<p>Tento adresáø obsahuje doèasné soubory vytvoøené exekutorem
dotazù. Napøíklad, kdy¾ je nutné tøídìní k zaji¹tìní ORDER BY a
tøídìní má vìt¹í nároky na prostor ne¾ povoluje parametr -S
backendu, pak je vytvoøen doèasný soubor k ulo¾ení extra údajù.</p>

<p>Doèasné soubory jsou obvykle mazány automaticky, ale mù¾e se stát, ¾e
bìhem tøídìní server spadne. Zastavení a dal¹í start postmastera zajistí
odstranìní souborù s tìchto adresáøù.</p>

<h3><a name="3.10">3.10</a> Proè je po¾adováno dump a obnovení (load) databáze bìhem upgrade
mezi velkými verzemi PostgreSQL?</h3>

<p>PostgreSQL se minimálnì mìní bìhem malých verzí, tak¾e napø. pøi upgrade z
7.2 na 7.2.1 není nutné dump a load databáze. Ale velké verze èasto mìní
interní formát systémových tabulek a datových souborù. Tyto zmìny jsou
natolik rozsáhlé, ¾e nelze zajistit zpìtnou kompatibilitu pro datové
soubory. Dump ulo¾í data v obecném formátu, tak¾e mohou být naètena a
pou¾ívána v novém interním formátu.</p>
<hr>

<h2>Provozní dotazy</h2>

<h3><a name="4.1">4.1</a> Èím se li¹í binární a normální kurzor?</h3>

<p>Popis najdete v manuálové stránce DECLARE</p>

<h3><a name="4.2">4.2</a> Jak získat pouze první øádek dotazu? Náhodný øádek?</h3>

<p>Podívejte se do man. stránky pøíkazu FETCH, nebo pou¾ijte SELECT ...
LIMIT ... </p>

<p>Není nutné zpracovávat celý dotaz, kdy¾ potøebujete pouze nìkolik prvních
øádkù. Pokud existuje index ORDER BY, PostgreSQL je schopen pøeru¹it
zpracování dotazu po získání po¾adovaného poètu øádkù.</p>

<p>K získání náhodného øádku pou¾ijte:</p>
<pre>SELECT col FROM tab
  ORDER BY random() LIMIT 1;
</pre>
<h3><a name="4.3">4.3</a> Jak získám seznam tabulek nebo jinak jak jej získá psql?</h3>

<p>Podívejte se do zdrojových kódù psql do souboru
pgsql/src/bin/psql/describe.c. Ten obsahuje SQL pøíkazy, které se
pou¾ívají v psql metapøíkazech. Dále mù¾ete spustit psql s pøepínaèem
-E, který zpùsobí zobrazení ka¾dého dotazu, které zpracování
metapøíkazu vyvolá.</p>

<h3><a name="4.4">4.4</a> Jak odstraním sloupec tabulky, jak zmìním jeho typ?</h3>

<p>Poèínaje verzí 7.3 mù¾ete pou¾ít pøíkaz ALTER TABLE DROP COLUMN. Ve
star¹ích verzích mù¾ete pou¾ít následující postup:</p>
<pre>BEGIN;
LOCK TABLE old_table;
SELECT ... -- mimo sloupec, který chceme odstranit
  INTO TABLE new_table;
DROP TABLE old_table;
ALTER TABLE new_table RENAME TO old_table;
COMMIT;
</pre>
<p>Pro zmìnu typu sloupce je tøeba provést:</p>
<pre>BEGIN;
ALTER TABLE tab ADD COLUMN new_col new_data_type;
UPDATE tab SET new_col = CAST(old_col AS new_data_type;
ALTER TABLE tab DROP COLUMN old_col;
COMMIT;
</pre>
<p>Poté proveïte VACUUM FULL tab - uvolníte tím diskový prostor zabraný
nyní ji¾ neplatnými øádky.</p>

<h3><a name="4.5">4.5</a> Jaká je maximální velikost øádku, tabulky a databáze?</h3>

<p>PostgreSQL má tato omezení:</p>
<table>
<tbody><tr><td>Maximální velikost databáze:</td><td>	neomezena (existují 32TB db)
</td></tr><tr><td>Maximálné velikost tabulky:</td><td>		32 TB
</td></tr><tr><td>Maximální velikost øádky:</td><td>		1.6 TB
</td></tr><tr><td>Maximální velikost polo¾ky</td><td>		1 GB
</td></tr><tr><td>Maximální poèet øádkù v tabulce:</td><td>	neomezeno
</td></tr><tr><td>Maximální poèet sloupcù v tabulce:</td><td>	250-1600 podle typù
</td></tr><tr><td>Maximální poèet indexù na tabulce:</td><td>	neomezeno
</td></tr></tbody></table>
<p>Ve skuteènosti nic není neomezeno, limitem bývá v¾dy dostupná disková
pamì» nebo velikost operaèní pamìti. Pokud máte nìkterou z tìchto
hodnot neobvykle velkou, mù¾e dojít ke sní¾ení výkonu.</p>

<p>Maximální velikost tabulky je 32 TB a nevy¾aduje podporu velkých souborù
operaèním systémem. Velké tabulky se ukládají do nìkolika 1 GB souborù
tak¾e limity souborového systému nejsou podstatné.</p>

<p>Maximální velikost tabulky a maximální poèet sloupcù mù¾eme
zeètyønásobit nastavením velikosti bloku na 32K.</p>

<h3><a name="4.6">4.6</a> Kolik diskového prostoru je potøeba k ulo¾ení dat z normálního
textového souboru? </h3>

<p>PostgreSQL vy¾aduje a¾ pìtinásobek diskového prostoru k ulo¾ení dat z
textového souboru.</p>

<p>Napøíklad, uva¾ujme soubor se 100 tisíci øádky obsahující na ka¾dé
øádce celé èíslo a textový popis. Text je v prùmìru dvacet bytù
dlouhý. Textový soubor bude 2.8 MB dlouhý. Velikost 
databáze obsahující odpovídající data bude zhruba 6.4 MB.</p>
<pre> 36 bytù: hlavièka øádku (pøibli¾nì)
 24 bytù: jedna celoèíselná polo¾ka a jedna textová
  4 byty: ukazatel na stránku k ntici
------------------------------------------------------
 64 bytù na øádek
</pre>
<p>Velikost datové stránky PostgreSQL je 8KB</p>
<pre> 8192 bytù na stránce
---------------------- = 128 øádek na stránku
  64 bytù za øádek

100000 øádek
-------------------- = 782 stránek (zaokrouhleno nahoru)
128 øádek na stránce

782 * 8192 = 6, 406, 144 bytù (6.4 MB)
</pre>
<p>Indexy nemají tak velkou re¾ii, ale mohou být také velké, 
proto¾e obsahují indexovaná data.</p>

<p>Hodnoty NULL jsou ulo¾eny v bitmapách, tak¾e spotøebují jen velmi málo
diskového prostoru.</p>

<h3><a name="4.7">4.7</a> Jak získám seznam vytvoøených tabulek, indexù, databází?</h3>

<p>psql má sadu metapøíkazù k zobrazení tìchto informací. Jejich seznam
získáte pøíkazem \?. Dále se mù¾ete podívat na obsah systémových
tabulek zaèínajících pg_. Spu¹tìní psql s parametrem -l provede
výpis názvù v¹ech databází.</p>

<p>Soubor pgsql/src/tutorial/syscat.source obsahuje SELECTy pøistupující
k systémovým tabulkámm.</p>

<h3><a name="4.8">4.8</a> Mùj dotaz je pomalý a nepou¾ívá vytvoøené indexy. Proè?</h3>

<p>Ka¾dý dotaz nemusí nutnì pou¾ít existující indexy. Index se pou¾ije tehdy,
kdy¾ je tabulka vìt¹í ne¾ urèitá minimální velikost, a dotaz vybírá
pouze procentuálnì malou èást øádkù tabulky. To proto, ¾e náhodný
pøístup k disku daný ètením indexu mù¾e být pomalej¹í ne¾ lineární
ètení tabulky nebo sekvenèní ètení,</p>

<p>PostgreSQL rozhoduje o pou¾ití indexù na základì statistiky pøístupù k
tabulce. Tyto statistiky se shroma¾ïují pøíkazy VACUUM ANALYZE nebo
ANALYZE. Díky statistikám má optimizer informaci o poètu øádek v
tabulce a mù¾e lépe rozhodnout o pou¾ití indexù. Statistiky se uplatní
pøi urèení optimálního poøadí a metody spojení tabulek. Statistiky by 
se mìli aktualizovat opakovanì, tak jak se mìní obsah tabulek.</p>

<p>Indexy nejsou obyèejnì pou¾ity pro setøídìní nebo spojení
tabulek. Sekvenèní zpracování následované explicitním tøídìním je
obyèejnì rychlej¹í ne¾ indexní ètení na velké tabulce.</p>

<p>Jinak je tomu v pøípadì pou¾ití LIMIT a ORDER BY, pøi kterém se
vìt¹inou index pou¾ije, výsledkem je pouze malá èást tabulky. Funkce
MAX() a MIN() nepou¾ívají indexy, ale je mo¾né tuté¾ hodnotu získat </p>
<pre>SELECT col FROM tab
  ORDER BY col [ DESC ] LIMIT 1;
</pre>
<p>Pokud si myslíte, ¾e optimizer mylnì zvolil sekvenèní prohledávání
tabulky, pou¾ijte pøíkaz SET enable_seqscan TO 'off' a zkuste zda je
indexní prohledávání rychlej¹í.</p>

<p>Pøi vyhledávání na základì vzoru jako je napø. operátor LIKE nebo ~ se
indexy pou¾íjí pouze za urèitých skuteèností:</p>
<ul>
  <li> zaèátek hledaného vzoru musí být ukotven k zaèátku, tj.
    <ul>
     <li>vzor LIKE nesmí zaèínat %
     </li><li>regulární výraz musí zaèínat ^
    </li></ul>
  </li><li>vzor nesmí zaèínat intervalem, napø. [a-e]
  </li><li>vyhledávaní, které není Case sensitiv nepou¾ívá indexy. Mù¾ete ale
     pou¾ít funkcionální indexy, které jsou posány v sekci 4.12 
  </li><li>pøi inicializaci databáze (initdb) musí být pou¾ito C locale
     (pozn. pøekladatele - tudí¾ v na¹ich podmínkách nepou¾itelné,
     nepracovalo by èeské tøídìní). 
</li></ul>

<h3><a name="4.9">4.9</a> Jak zjistím, jak optimizer dotazu vyhodnocuje mùj dotaz?</h3>

<p>Podívejte se do manuálové stránky pøíkazu EXPLAIN.</p>

<h3><a name="4.10">4.10</a> Co to je R-tree index?</h3>

<p>R-tree index se pou¾ívá pro indexování prostorových dat. Hash index
nemù¾e obslou¾it prohledávání oblastí. B-tree index mù¾e øídit
vyhledání oblastí v jedné dimenzi. R-tree index mù¾e podporovat hledání v
multidimenzionálních datech. Pou¾ijeme-li napøíklad R-tree index na
atributy typu point, pak systém mù¾e efektivnì odpovìdìt na dotaz -
vyber v¹echny body uvnitø obdélníkù.</p>

<p>Pùvodní návrh R-tree je Guttman, A. "R-trees: A Dynamic Index
Structure for Spatial Searching." Proceedings of the 1984 ACM SIGMOD
Int'l Conf on Mgmt of Data, 45-57</p>

<p>Tyto materiály naleznete v  Stonebraker's "Readings in Database Systems".</p>

<p>Vestavìné R-tree mù¾e slou¾it k indexaci polygonù a
oblastí. Teoreticky mù¾eme R-tree pou¾ít i pro více dimenzí (jiné ne¾ 3D).
Ve skuteènosti ale takové roz¹íøení R-tree vy¾aduje trochu práce a 
ve souèastnosti chybí dokumentace jak na to.</p>

<h3><a name="4.11">4.11</a> Co je Genetic Query Optimizer?</h3>

<p>GEQO modul urychluje optimalizaci dotazù pøi spojování mno¾ství
tabulek metodou Genetických algoritmù (GA). To umo¾òuje získat
velkého mno¾ství variant spojení pøi neúplném prohledáváním.</p>

<h3><a name="4.12">4.12</a> Jak provést vyhledávání regulárního výrazu case sensitiv,
insensitiv? Jak pou¾ít index pro case insensitive vyhledávání?</h3>

<p>Operátor ~ slou¾í k porování s regulárním výrazem, jeho modifikace *~
pøedstavuje case insensitive vyhledávání. Jedná se o obdobu LIKE a
ILIKE.</p>

<p>Pro vyhledávání bez ohledu na velká malá písmena pou¾ijeme</p>
<pre>SELECT * FROM tab
  WHERE lower(col) = 'abc';
</pre>
<p>V tomto pøípadì se nepou¾ije standardní index. Nicménì, pou¾ije se
funkcionální index, pokud jej vytvoøíte </p>
<pre>CREATE INDEX tabindex ON tab (lower(col));
</pre>
<h3><a name="4.13">4.13</a> Jak v dotazu detekovat, ¾e polo¾ka je NULL?</h3>

<p>Urèíte pomocí IS NULL nebo IS NOT NULL</p>

<h3><a name="4.14">4.14</a> Jaké jsou rozdíly mezi rùznými znakovými typy?</h3>
<pre>Typ         Interní název       Poznámka
--------------------------------------------------------------------------
VARCHAR(n)  varchar		omezeno maximální délkou, bez doplnìní mezerami
CHAR(n)	    bpchar		øetìzec je doplnìn mezerami do dané délky
TEXT	    text		bez horního limitu na délku 
BYTEA	    bytea		pole bytù (bezpeènì lze ulo¾it i znak NULL)
"char"	    char		jeden znak
</pre>
<p>S interními názvy se setkáte v systémovém katalogu a v nìkterých
chybových hlá¹eních.</p>

<p>První ètyøi uvedené typy jsou tzv. varlena typy (tj. první ètyøi byty
na disku nesou údaj o délce, následují samotná data). Proto skuteèný
pou¾itý prostor je v¾dy o nìco málo vìt¹í ne¾ deklarovaná délka. Naopak, 
tyto datové typy jsou komprimovánty TOASTem, tak¾e prostor na disku
mù¾e být ni¾¹í ne¾ je oèekáváno.</p>

<p>VARCHAR(n) je vhodný pro ukládání textù prommìné délky s pevnì
stanovenou maximální délkou. TEXT je pro øetìzce bez omezení délky s
maximem jeden gigabajt.</p>

<p>CHAR(n) slou¾í k ukládání øetìzcù stejné délky. CHAR(n) doplní prázdné
znaky do specifikované délky, zatímco VARCHAR(n) ulo¾í pouze pøedané
znaky. BYTEA je urèeno pro ukládání binárních dat, vèetnì NULL
byte. V¹echny zde popsané typy mají podobné výkonnostní
charakteristiky.</p>

<h3><a name="4.15.1">4.15.1</a> Jak vytvoøit serial/auto-increment pole?</h3>

<p>PostgreSQL podporuje typ SERIAL. Pøi jeho pou¾ití se automaticky
vytvoøí SEQUENCE a index na sloupci (Pro vy¹¹í verze to neplatí
OVÌØIT). Napøíklad:</p>
<pre>CREATE TABLE person (
  id SERIAL,
  name TEXT
);
</pre>
je automaticky pøevedeno do
<pre>CREATE SEQUENCE person_id_seq;
CREATE TABLE person (
  id INT4 NOT NULL DEFAULT nextval('person_id_seq'),
  name TEXT
);
CREATE UNIQUE INDEX person_id_key ON person(id);
</pre>
<p>Viz dokumentace create_sequence v manuálových stránkách. Dále mù¾ete pou¾ít
unikátní hodnotu OID ka¾dého øádku. Potom ale musíte spou¹tìt pg_dump
s pøepínaèem -o, tak aby zùstaly zachovány hodnoty OID (u pøíkazu
copy COPY WITH OIDS).</p>

<h3><a name="4.15.2">4.15.2</a> Jak získat hodnotu SERIAL po vlo¾ení øádku?</h3>

<p>Jednou z mo¾ností je získat budoucí hodnotu SERIAL funkcí nextval pøed
samotným vlo¾ením a pak ji vlo¾it explicitnì. Napøíklad v jakémsi
pseudojazyku</p>
<pre>newid = execute("SELECT nextval('person_id_seq')");
execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");
</pre>
<p>Mù¾ete pak je¹tì pou¾ít hodnotu newid v dal¹ích dotazech, napø. jako
hodnotu cizího klíèe. Název automaticky vytvoøené sekvence je
tabulka_sloupec_seq.</p>

<p>Alternativnì mù¾ete získat hodnotu poslednì generovou sekvencí funkcí
currval() po vlo¾ení</p>
<pre>execute("INSERT INTO person (name) VALUES ('Blaise Pascal')");
new_id = execute("SELECT currval('person_id_seq')");
</pre>
<p>Koneènì mù¾ete pou¾ít OID hodnotu vrácenou pøíkazem INSERT, ale to je
pravdìpodobnì nejménì pøenositelné øe¹ení. V Perlu pøi pou¾ití DBI
modulu Edmunda Mergleho DBD:Pg oid hodnotu získáme
$sth-&gt;{pg_oid_status} po ka¾dém $sth-&gt;execute().</p>

<h3><a name="4.15.3">4.15.3</a> Nepovede currval() a nextval() k rozhození podmínek pøi soubìhu s jinými u¾ivateli?</h3>

<p>Nikoliv, currval() vrací hodnotu naposledy generovanou ve va¹em
backendu, a ta tudí¾ není spoleèná v¹em u¾ivatelùm.</p>

<h3><a name="4.15.4">4.15.4</a> Proè není vygenerované èíslo pou¾ito pøi pøeru¹ení
transakce? Proè vznikají díry v èíslování vlastní sekvencí/SERIAL
sloupce?</h3>

<p>K zaji¹tìní efektivnosti soubìhu, jsou hodnoty posloupnosti, kdy¾ se o nì
po¾ádá, a sekvence není zamèena do ukonèení transakce. To zpùsobuje
díry v èíslování ze zru¹ených transakcí.</p>

<h3><a name="4.16">4.16</a> Co to je OID? Co je to TID?</h3>

<p>Ka¾dý øádek vytvoøený v PostgreSQL získá jedineèné OID. V¹echna OID
generovaná bìhem inicializace databáze jsou men¹í ne¾ 16384
(include/access/transam.h). V¹echna OID generovaná na po¾adavek
u¾ivatele jsou rovna nebo vy¹¹í této hodnotì. Normálnì, v¹echna OID
jsou jedineèná nejen uvnitø tabulky nebo databáze, ale v rámci celé
instalace PostgreSQL</p>

<p>PostgreSQL pou¾ívá OID ve svém interním systému tabulek k vytvoøení
relací. Tato OID mohou být pou¾ita k identifikaci konkrétního
u¾ivatele a pou¾ita v spojení. Pro OID hodnoty je doporuèen typ
OID. Nad tímto sloupcem mù¾ete vytvoøit index pro urychlení pøístupu.</p>

<p>OID jsou dána v¹em øádkùm z centrální oblasti a jsou pou¾ita v ka¾dé
databázi. Pokud potøebujete zmìnit OID, nebo chcete zkopírovat tabulku
s pùvodními OID, lze pou¾ít</p>
<pre>CREATE TABLE new_table(old_oid oid, mycol int);
SELECT old_oid, mycol INTO new FROM old;
COPY new TO '/tmp/pgtable';
DELETE FROM new;
COPY new WITH OIDS FROM '/tmp/pgtable';
</pre>
<p>OID jsou ulo¾ena jako 4bajtový integer a pøeteèou po ètyøech
miliardách. Nebylo hlá¹eno, ¾e by se tak nìkdy stalo, pøesto ale plánujeme
odstranit tento limit døív ne¾ se tak stane.</p>

<p>TID se pou¾ívají i identifikaci fyzických øádkù s hodnotou bloku a
offsetu. TIDs se mìní modifikací øádkù (pou¾ívá se jako ukazatel
indexu fyzického øádku).</p>

<h3><a name="4.17">4.17</a> Jaký je význam nìkterých výrazù pou¾itých v PostgreSQL?</h3>

<p>V nìkterých zdrojových kódech nebo star¹í dokumentaci se mù¾ete setkat
s následujícími výrazy, které mají ¹ir¹í význam. Zde je pøíklad
nekterých:</p>
<ul>
<li>tabulka, relace, tøída (table, relation, class)
</li><li>øádek, záznam, ntice (row, record, tuple)
</li><li>sloupec, polo¾ka, atribut (column, field, attribute)
</li><li>vyhledání, výbìr (retrieve, select)
</li><li>náhrada, úprava (replace, update)
</li><li>pøidání, vkládání (append, insert)
</li><li>OID, serial value (OID, serial value)
</li><li>portal, kurzor (portal, cursor)
</li><li>range variable, jméno tabulky, alias tabulky (range variable, table name, table alias)
</li></ul>
<p>seznam tìchto výrazù mù¾ete nalézt na
<a href="http://hea-www.harvard.edu/MST/simul/software/docs/pkgs/pgsql/glossary/glossary.html">http://hea-www.harvard.edu/MST/simul/software/docs/pkgs/pgsql/glossary/glossary.html</a>.</p>

<h3><a name="4.18">4.18</a> Proè jsem získal chybové hlá¹ení "ERROR: Memory exhausted in
AllocSetAlloc()"?</h3>

<p>Pravdìpodobnì do¹lo k vyèerpání virtuální pamì»i na Va¹em systému, nebo
jádro má nízký limit pro urèité zdroje. Vyzkou¹ejte pøed startem
posmatera</p>
<pre>ulimit -d 262144
limit datasize 256m
</pre>
<p>Zále¾í na Va¹em shellu, zda budou tyto pøíkazy úspì¹né, mìly by zvý¹it
limit datového segmentu pro Va¹e procesy a umo¾nit tak dokonèení
dotazu. Tyto pøíkazy se aplikují na aktuální proces a v¹echny synovské
procesy vytvoøené po provedení pøíkazu. Pokud máte problémy s SQL
klientem proto¾e backend vrací pøíli¹ mnoho dat, zkuste zvý¹it limity 
pøed startem klienta.</p>

<h3><a name="4.19">4.19</a> Jak se dozvím, kterou verzi PostgreSQL pou¾ívám?</h3>

<p>V psql spus»te</p>
<pre>SELECT version();
</pre>
<h3><a name="4.20">4.20</a> Proè operace s velkými objekty konèí "invalid large obj descriptor"?</h3>

<p>V¹echny operace s velkými objekty - lo_open, lo_close, ... musíte
spou¹tìt v transakci, tj. mezi pøíkazy BEGIN WORK a COMMIT.</p>

<p>PostgreSQL uvolòuje handle velkých objektù pøi skonèení transakce. Pokud
budete pracovat s velkými objekty mimo transakci, pravdìpodobnì dostanete
toto chybové hlá¹ení, proto¾e handle ji¾ budou neplatné.</p>

<p>Pokud pou¾íváte interface podobné ODBC musíte nastavit set auto_commit off</p>

<h3><a name="4.21">4.21</a> Jak vytvoøit sloupec obsahující implicitnì aktuální datum?</h3>

<p>Pou¾ijte CURRENT_TIMESTAMP</p>
<pre>CREATE TABLE test (x int, modtime timestamp DEFAULT CURRENT_TIMESTAMP );
</pre>
<h3><a name="4.22">4.22</a> Proè jsou moje vnoøené dotazy pou¾ívající IN tak pomalé?</h3>

<p>Aktuálnì spojujeme tabulky se sekvenèním skenováním výsledku pro ka¾dý
øádek vnìj¹ího dotazu. Pokud vnoøený dotaz má pouze nìkolik øádkù a
vnìj¹í dotaz vrací hodnì øádek, IN je rychlé. V jiných pøípadech
nahraïte IN EXISTS:</p>
<pre>SELECT * FROM tab
  WHERE col IN (SELECT subcol FROM subtab);
</pre>
takto
<pre>SELECT * FROM tab
  WHERE EXISTS (SELECT subcol FROM subtab WHERE subcol = col);
</pre>
<p>Pro urychlení vytvoøete index pro subcol. Tento výkonnostní problém
byl odstranìn ve verzi 7.4.</p>

<h3><a name="4.23">4.23</a> Jak provést vnìj¹í spojení (outer join)?</h3>

<p>PostgreSQL podporuje vnìj¹í spojení tabulek standardními SQL
pøíkazy. Zde jsou dva pøíklady:</p>
<pre>SELECT * FROM t1 LEFT OUTER JOIN t2 ON (t1.col = t2.col);
</pre>
nebo
<pre>SELECT * FROM t1 LEFT OUTER JOIN USING (col);
</pre>
<p>Tyto identické dotazy napojí t1.col na t2.col a je¹tì pøidá
nepøipojené øádky z t1 (které nemají obdoby v t2). Pravé spojení
(RIGHT JOIN) pøidá nepøipojené øádky z t2. FULL JOIN vrátí v¹echny
øádky, vèetnì nepøipojených z tbulek t1 a t2. Klíèové slovo OUTER je
nepovinné a vá¾e se na LEFT, RIGHT a FULL join. Bì¾né spojení se
nazývá INNER JOIN.</p>

<p>V døívìj¹ích verzích se vnìj¹í spojení tabulek mohlo simulovat pomocí
UNION a NOT IN. Napøíklad pro spojení tabulek tab1 a tab2, je
následující dotaz ekvivalentní k vnìj¹ímu spojení dvou tabulek:</p>
<pre>SELECT tab1.col2, tab2.col2 FROM tab1, tab2
  WHERE tab1.col1 = tab2.col1
UNION ALL
SELECT tab1.col2, NULL FROM tab1
  WHERE tab1.col1 NOT IN (SELECT tab2.col1 FROM tab2)
ORDER BY col1;
</pre>
<h3><a name="4.24">4.24</a> Jak provést dotaz napøíè nìkolika databázemi?</h3>

<p>PostgreSQL nenabízí ¾ádný zpùsob, jak se dotázat do jiné databáze ne¾
do aktuální. Doplnìk contrib/dblink umo¾òuje dotaz do cizí databáze
prostøednictvím funkce. Na stranì klienta není problém si otevøít více
simultálních pøístupù do rùzných databází a spojovat výsledek na
stranì klienta.</p>

<h3><a name="4.25">4.25</a> Mù¾e funkce vrátit více øádkù nebo sloupcù?</h3>

<p>V PostgreSQL 7.3 mù¾ete jednodu¹e vracet více øádkù nebo sloupcù z
funkce, viz:
<a href="http://techdocs.postgresql.org/guides/SetReturningFunctions">http://techdocs.postgresql.org/guides/SetReturningFunctions</a>.</p> 

<h3><a name="4.26">4.26</a> Proè nelze spolehlivì vytváøet a ru¹it doèasné tabulky v
PL/pgSQL funkcích?</h3>

Pøelo¾ený kód PL/pgSQL funkce je ulo¾en ve vyrovnávací pamìti, tj. funkce 
je pøekládána pouze pøi zmìnì kódu, nikoliv pøed ka¾dým voláním funkce.
Nechtìným vedlej¹ím efektem je, ¾e volání funkce sel¾e, kdy¾ se funkce 
odkazuje na doèasnou tabulku, pokud tato tabulka byla od pøekladu funkce 
zru¹ena (aèkoliv ji¾ byla znovu vytvoøena a existuje). 
Jediným øe¹ením problému je pøístup k doèasné tabulce pomocí
EXECUTE, tj. dynamické provádìní dotazu. Tento pøíkaz zajistí opakovaný 
pøeklad dotazu pøi ka¾dém volání funkce.<p></p>

<h3><a name="4.27">4.27</a> Jaké jsou mo¾nosti replikace databází?</h3>

<p>Existuje nìkolik dostupných øe¹ení master/slave replikací. Ty povolují
modifikace master databáze a slave databázím umo¾òují pouze ètení. Na
konci  <a href="http://gborg.postgresql.org/genpage?replication_research">http://gborg.PostgreSQL.org/genpage?replication_research</a>
najdete jejich seznam. Na øe¹ení multi-master replikaci se pracuje na
<a href="http://gborg.postgresql.org/project/pgreplication/projdisplay.php">http://gborg.PostgreSQL.org/project/pgreplication/projdisplay.php</a>.</p> 

<h3><a name="4.28">4.28</a> Jaké jsou mo¾nosti ¹ifrování databází?</h3>
<ul>
<li><p>contrib/pgcrypto obsahuje ¹ifrovací funkce pou¾itelné v SQL
dotazech.</p>

</li><li><p>K ¹ifrování pøenosu dat z klienta na server, musí být
server pøelo¾en s podporou ssl a pøepínaè sslv postgresql.conf musí
být nastaven na hodnotu true. Klient musí mít vytvoøen záznam
hostssl v pg_hba.conf a také mít povolen re¾im ssl. Lze pou¾ít i jiné
prostøedky, nejen nativní podporu ssl v PostgreSQL, napø. stunel a ssh.</p>

</li><li><p>Hesla u¾ivatelù databáze jsou za¹ifrována poèínaje verzí 7.3. Ve
star¹ích verzích toto chování muselo být vynuceno volbou 
PASSWORD_ENCRYPTION v postgresql.conf</p>

</li><li><p>Server mù¾e bì¾et na ¹ifrovaném souborovém systému.</p>
</li></ul>
<hr>
<h2>Roz¹iøování PostgreSQL</h2>

<h3><a name="5.1">5.1</a> Napsal jsem UDF funkci, PostgreSQL v¹ak konèí dump core?</h3>

<p>Problém mù¾e být zpùsoben mnoha okolnostmi. Vyzkou¹ejte si svoji
funkci nejdøíve v nìjaké jednoduché aplikaci.</p>

<h3><a name="5.2">5.2</a> Jak mohu pøispìt nìjakými ¹ikovnými datovými typy a funkcemi
do PostgreSQL?</h3>

<p>Po¹lete své roz¹íøení do konference pgsql-hackers, a ono pak mo¾ná
skonèí v podadresáøi contrib.</p>

<h3><a name="5.3">5.3</a> Jak napsat funkci v C vracející ntici?</h3>

<p>Funkce vracející tabulky jsou podporované PostgreSQL 7.3 a vy¹¹í pro
jazyky C, PL/PgSQL a SQL. Více naleznete v The Programmer's
Guide. Pøíklady tìchto funkcí pro C naleznete v contrib/tablefunc.</p>

<h3><a name="5.4">5.4</a> Modifikoval jsem zdrojové soubory. Tato zmìna nebyla pøi
rekompilaci vzata v potaz. Proè?</h3>

<p>Makefile nemá informace o závislostech mezi hlavièkovými soubory. Musíte
provést make clean a pak make. Pokud pou¾íváte gcc, mù¾ete pou¾ít
pøepínaè --enable-depend pøíkazu configure k automatickému øe¹ení
závislostí pøekladaèem.</p>
</body></html>