PostgreSQL FAQسوالاتي كه اغلب در مورد PostgreSQL‌ پرسيده مي شوند
تاريخ آخرين اصلاح اين فايل: 28 شهریور 1383 هجری شمسی
نگهدارنده اصلي فايل (زبان انگليسي)در حال حاضر : Bruce Momjian 
pgman@candle.pha.pa.us
نگهدارنده فايل به زبان فارسي: m.taghizadeh@imenafzar.net  محمود تقي‌زاده مهرجردی

آخرين نسخه اين فايل را مي‌توانيد از اين آدرس بگيريد  
http://www.PostgreSQL.org/docs/faqs/FAQ.html
سوالاتي كه در مورد يك سکوی(پلتفرم) خاص است در اين آدرس جواب داده شده اند  
http://www.PostgreSQL.org/docs/index.html



سوالات عمومي
1.1) PostgreSQL چيست و چگونه بايد آن را تلفظ كرد؟
1.2) قانون كپي رايت‌ (حقوق معنوي) در مورد PostgreSQL  به چه صورت است؟
1.3) PostgreSQL‌ روي چه نوع يونيكسهايي اجرا مي‌شود؟
1.4) روي چه محيطهاي غير يونيكسي مي‌توان آن را اجرا كرد؟
1.5) PostgreSQL را از كجا مي‌توانم بگيرم؟
1.6) از كجا خدمات پشتيباني بگيرم؟
1.7) آخرين نسخه اعلام شده چيست؟
1.8) چه مستندات و راهنمائيهايي وجود دارند؟
1.9) چگونه مي‌توانم ازاشكالات شناخته شده و يا امكاناتي كه در اين پايگاه داده 
وجود ندارد  مطلع شوم؟
1.10) چگونه مي‌توانم زبان SQL را ياد بگيرم؟
1.11) آيا PostgreSQL مشكل Y2K‌ دارد يا خير؟
1.12) چگونه مي‌توانم به تيم برنامه نويس PostgreSQL ملحق شوم؟
1.13) چگونه مي‌توانم يك اشكال را به گروه برنامه نويس اعلام كنم؟
1.14)  وضعيت PostgreSQL‌ در مقايسه با ساير DBMSها به چه صورت است؟
1.15) من چگونه مي‌توانم از نظر مالي به PostgreSQL كمك كنم؟

سوالات مربوط به استفاده از پايگاه داده
2.1) آيا هيچ درايور ODBC‌ براي PostgreSQL وجود دارد؟
2.2) چه ابزارهايي براي استفاده از PostgreSQL‌ با صفحات وب وجود دارد؟
2.3) آيا PostgreSQL‌ يك واسط كاربري گرافيكي دارد؟
2.4) با چه زبانهاي برنامه‌نويسي مي‌توان با PostgreSQL‌ ارتباط برقرار كرد؟

سوالات مربوط به راهبري
3.1) چگونه مي‌توانم PostgreSQL‌ را در شاخه‌اي غير از /usr/local/pgsql/  نصب كنم؟
3.2) چرا موقعي كه من برنامه postmaster‌ را اجرا مي كنم پيام Bad system call‌ و 
يا core dump ‌مي‌گيرم؟
3.3) چرا موقعي كه من سعي مي‌كنم برنامه postmaster‌ را اجرا كنم خطاي 
IpcMemoryCreate  مي‌گيرم؟
3.4) چرا موقعي كه من سعي مي‌كنم برنامه postmaster‌ را اجرا كنم خطاي  
IpcSemaphoreCreate مي‌گيرم؟
3.5) چگونه مي‌توانم اتصالات ساير ماشينها را كنترل كنم؟
3.6) براي كارايي بالاتر و بهتر پايگاه داده من چه تنظيماتي را بايد انجام دهم؟
3.7) چه امكاناتي براي پيدا كردن اشكال‌ وجود دارد؟
3.8) چرا موقعي كه من مي‌خواهم به پايگاه داده وصل شوم پيام "Sorry, too many 
clients" ‌مي‌گيرم؟
3.9) در شاخه  pgsql_tmp  چه چيزي قرار دارد؟
3.10) چرا براي به روز كردن نسخه پايگاه داده من بايد كل داده ها را dump‌ و مجدداً 
restore كنم؟
3.11) از چه سخت افزاري بايد استفاده كنم؟

سوالات عملياتي
4.1) تفاوت بين binary cursors و Normal cursors چيست؟
4.2) من چگونه مي‌توانم فقط روي چند رديف اول يا يك رديف تصادفي درخواست SELECT‌ 
بزنم؟
4.3) من چگونه مي‌توانم ليستي از جداول يا ساير چيزهايي كه در psql‌ وجود دارد را 
ببينم؟
4.4) چگونه يك ستون جدول را حذف مي‌كنيد؟ چگونه نوع داده آن را عوض كنيم؟
4.5) حداكثر اندازه يك رديف،‌ جدول و خود پايگاه داده چقدر است؟
4.6) چقدر فضاي ديسك سخت براي ذخيره كردن داده‌‌هاي يك فايل متني مورد نياز است؟
4.7) چگونه مي‌توانم بفهمم كه چه كاربران،‌ پايگاه داده،‌ نمايه و جداولي در سيستم 
تعريف شده است؟
4.8) چرا درخواستهاي من كند اجرا مي‌شوند يا چرا از نمايه ها استفاده نمي‌كنند؟
4.9) چگونه مي‌توانم نحوه بررسي درخواست را توسط بهينه‌ساز درخواستها مشاهده كنم؟
4.10) نمايه R-tree‌ چيست؟
4.11) بهينه ساز تكويني درخواست چيست؟ (Genetic Query Optimizer)
4.12) چگونه از عبارات منظم براي جستجو استفاده كنم؟ چگونه جستجويي انجام دهم كه 
حساس به متن نباشد؟ چگونه براي يك جستجوي غير حساس به متن از نمايه استفاده كنم؟
4.13) چگونه مي‌توانم در يك درخواست تشخيص دهم كه يك فيلد NULL‌ است؟
4.14) تفاوت بين گونه‌هاي مختلف character چيست؟
4.15.1) چگونه مي‌توانم يك فيلد سريال يا افزايشي ايجاد كنم؟
4.15.2) چگونه مي‌توانم مقدار يك درج سريالي را بدانم؟
4.15.3) آیا توابع ()nextval و ()currval منجر به ایجاد شرایط race برای سایر 
کاربران می شوند؟
4.15.4) چرا اعداد سریالی مربوط به تراکنشهای abort شده مجدداً استفاده نمی شود؟ 
چرا بین اعداد سریالی یک فاصله خالی ایجاد می شود؟
4.16) OID و TID چه هستند؟
4.17) معني بعضي از ترمها و كلماتي كه در PostgreSQL‌ استفاده مي‌شود چيست؟
4.18) چرا من خطاي "ERROR: Memory exhausted in AllocSetAlloc" مي‌گيرم؟
4.19) از كجا تشخيص دهم كه ويرايش يا نسخه PostgreSQLيي كه من استفاده مي‌كنم چيست؟
4.20) چرا در حین اجرای عملیات روی large-objectها خطای "invalid large obj 
descriptor"به وجود می آید؟
4.21) چگونه يك ستون ايجاد كنم كه مقدار زمان جاري را به عنوان مقدار پيش‌فرض داشته 
باشد؟
4.22) چرا زير درخواستهايي كه از IN استفاده مي‌كنند كند هستند؟
4.23) چگونه مي‌توانم يك الحاق خارجي (outer join) انجام دهم؟
4.24) چگونه مي‌توان درخواستهايي از چند پايگاه داده توليد كرد؟
4.25) چگونه خروجي يك تابع مي‌تواند  چند رديف يا ستون باشد؟
4.26)  در توابع PL/PgSQL چرا نمي‌توان با اطمينان جداول موقت را ايجاد يا حذف كرد؟
4.27) چه گزينه‌هايي براي تكرار (replication) وجود دارد؟
4.28) چه گزينه‌هايي براي رمزنگاري وجود دارد؟

توسعه PostgreSQL
5.1) من يك تابع نوشته‌ام. چگونه آن را در psql اجرا كنم؟ چرا با اجراي آن core 
dump مي‌گيرم؟
5.2) چگونه مي‌توانم در توليد نوع‌ها و توابع جديد و جالب براي PostgreSQL‌ همكاري 
و مشاركت داشته باشم.
5.3) چگونه مي‌توانم يك تابع به زبان C بنويسم كه خروجي آن يك ‌tuple  (چند تايي) 
باشد؟
5.4) من يك فايل منبع را عوض كرده ام چرا در عمليات كامپيل مجدد آن تغيير ديده 
نمي‌شود؟




سوالات عمومي
1.1) PostgreSQL چيست و چگونه آن را بايد تلفظ كرد؟
PostgreSQL به صورت Post-Gres-Q-L‌ تلفظ مي‌شود. يك فايل صوتي در آدرس 
http://www.postfresql.org/postgresql.mp3‌ براي كساني كه مايلند تلفظ صحيح را 
بشنوند وجود دارد.
PostgreSQL از روي سيستم مديريت پايگاه داده POSTGRES توسعه داده شده است (هنوز هم 
بعضي مواقع براي سادگي به آن Postgres گفته مي‌شود) كه يك نمونه تحقيقاتي از پايگاه 
داده‌هاي نسل بعد است. PostgreSQL همان الگوي داده قوي و انواع داده  را حفظ كرده 
است ولي زبان PostQuel را با يك زيرمجموعه پيشرفته از SQL جايگزين كرده است. 
PostgreSQL متن باز بوده و متن كامل آن در دسترس است.
PostgreSQL  توسط يك تيم برنامه‌نويس كه همگي در گروه پست الكترونيك برنامه‌نويسان 
PostgreSQL  عضو هستند، انجام مي‌شود. هماهنگ كننده اصلي در حال حاضر Marc G. 
Fournier‌ به آدرس scrappy@PostgreSQL.org  مي‌باشد. (براي ديدن نحوه ملحق شدن به 
اين تيم قسمت 1.6 را ببينيد). اين تيم در حاضر مسئوليت تمام مسائل مربوط به 
برنامه‌نويسي PostgreSQL را بر عهده دارد. اين يك پروژه گروهي است و تحت كنترل هيچ 
شركتي نيست. براي اطلاعات بيشتر در مورد اين تيم به آدرس 
http://www.PostgreSQL.org/docs/faqs/FAQ_DEV.html مراجعه كنيد.
اولين نسخه PostgreSQL‌ توسط Andrew Yu and Jolly Chen به وجود آمد. افراد بسياري 
در توسعه و رفع اشكال و انتقال آن شركت كرده‌اند. متن اصلي Postgres كه PostgreSQL 
از روي آن نوشته شده است، توسط تعداد زيادي دانشجوي كارشناسي ارشدو دانشجوي 
كارشناسي و تيم برنامه‌نويسي كه تحت نظر پروفسور Michael Stonebrake در دانشگاه 
بركلي،‌كاليفرنيا كار مي‌كرده‌اند نوشته شده است.
نام اصلي نرم افزار در دانشگاه بركلي Postgres‌ بود. در سال 1995 بعد از اضافه شدن 
SQL نام آن به Postgres95 تغيير داده شد. در سال 1996 نام آن به PostgreSQL تغيير 
داده شد.
1.2) قوانين كپي رايت در مورد PostgreSQL به چه صورت است؟
PostgreSQL تحت قانون كپي رايت زير قرار دارد:
PostgreSQL Data Base Management System
Portions copyright (c) 1996-2004, PostgreSQL Global Development Group Portions 
Copyright (c) 1994-6 Regents of the University of California
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose, without fee, and without a written agreement is 
hereby granted, provided that the above copyright notice and this paragraph and 
the following two paragraphs appear in all copies.
IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR 
DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST 
PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF 
THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, 
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND 
THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, 
UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
قانون بالا ليسانس BSD كه يك ليسانس كلاسيك براي متن‌هاي باز است مي‌باشد. هيچ 
محدوديتي در مورد نحوه استفاده از متن در آن ديده نمي‌شود. ما آن را دوست داريم و 
هيچ قصدي براي تغيير آن نداريم.
1.3) PostgreSQL‌ روي چه نوع يونيكسهايي اجرا مي‌شود؟
در حالت كلي PostgreSQL روي هر پلتفرم (سكوي) سازگار با يونيكس اجرا مي‌شود. ليست 
پلتفرمهايي كه تاكنون PostgreSQL‌ روي آنها نصب و تست شده است درقسمت دستورالعملهاي 
نصب آمده است.
1.4) روي چه محيطهاي غير يونيكسي مي‌توان آن را اجرا كرد؟
Client
مي‌توان psql, كتابخانه libpq و ساير واسطها و برنامه‌هاي كاربردي را طوري كامپيل 
كرد كه روي محيطهاي ويندوز نيز اجرا شوند. در اين حالت Client روي ويندوز اجرا 
مي‌شود و از طربق شبكه و پروتكل TCP/IP با يك سرور كه روي يك پلتفرم لينوكس در حال 
اجراست ارتباط برقرار مي‌كند.يك فايل win32.mak همراه با كدهاي PostgreSQL وجود 
دارد كه براي كامپيل كردن كتابخانه libpq و برنامه psql مي‌باشد. P‌ostgreSQL‌ 
همچنين امكان ارتباط به صورت ODBC‌  را نيز دارد.
Server
با استفاده از Cygwin‌ و كتابخانه Cygnus مي‌توان پايگاه داده را روي ويندوز NT و 
يا Win2K اجرا كرد.براي ديدن اطلاعات بيشتر فايل pgsql/doc/FAQ_MSWIN ‌را كه بهمراه 
توزبع‌هاي PostgreSQL آمده است ببينيد و يا اينكه به اين صفحه 
http://www.PostgreSQL.org/docs/faqs/text/FAQ_MSWIN مراجعه كنيد.
در حال حاضر يك عمليات انتقال PostgreSQL به روي سكوهاي Win NT/2000/XP در جريان 
است. براي ديدن وضعيت اين پروژه به سايت‌هاي 
http://momjian.postgresql.org/main/writings/pgsql/win32.htm و 
http://techdocs.postgresql.org/guides/Windows مراجعه كنيد. 
همچنين يك عمليات انتقال بر روي Novell Netware 6 نيز در حال انجام است كه در سايت 
http://forge.novell.com مي‌توانيد اطلاعات بيشتر را ببينيد.
1.5) PostgreSQL را از كجا مي‌توانم بگيرم؟
PostgreSQL‌ را از سايت اصلي آن  ftp://ftp.PostgreSQL.org/pub مي‌توانيد بگيريد. 
در صفحه اصلي سايت ليست ساير آدرسهايي كه مي‌توانيد PostgreSQL‌ را از آنها بگيريد 
آمده است.
1.6) از كجا خدمات پشتيباني بگيرم؟
گروه پستي اصلي pgsql-general@PostgreSQL.org مي‌باشد. اين گروه براي بحث در مورد 
موضوعات مختلف در زمينه PostgreSQL است. براي عضو شدن در اين گروه پستي يك نامه 
الكترونيكي به آدرس گروه با محتوياتی كه در ادامه آمده است ارسال كنيد. در قسمت 
Subject چيزي ننويسيد.
    subscribe
    end
آدرس گروه: pgsql-general-request@PostgreSQL.org
همچنين يك گروه پستي هم به صورت ارسال چكيده پيامها وجود دارد. براي عضو شدن در اين 
گروه يك نامه با محتويات زير به این آدرس  ارسال كنيد. 
pgsql-general-digest-request@PostgreSQL.org 
    subscribe
    end
در اين گروه هر موقع حجم نامه‌ها به 30 كيلوبايت رسيد براي تمام اعضاء ارسال 
مي‌شود.
گروه پستي بررسي اِشكالات هم وجود دارد. براي عضو شدن در اين گروه يك نامه با 
محتويات زير به pgsql-bugs-request@PostgreSQL.org ارسال كنيد.
    subscribe
    end
گروه پستي مخصوص توسعه دهندگان (برنامه‌نويسان) نيز وجوددارد. براي عضويت در اين 
گروه يك نامه به آدرس زير با محتويات مشخص شده ارسال كنيد.  
pgsql-hackers-request@PostgreSQL.org  
    subscribe
    end
گروههاي پستي ديگري نيز در زمينه PostgreSQL‌ وجود دارد  كه مي‌توانيد در سايت 
http://www.postgresql.org ببينيد.
همچنين يك كانال IRC روي Freenode و EFNet بنام PostgreSQL# وجود دارد. شما 
مي‌توانيد از فرمان يونيكسي irc -c '#PostgreSQL' "$USER" irc.phoenix.net. يا irc 
-c '#PostgreSQL' "$USER" irc.freenode.net استفاده كنيد.
ليست شركتهايي كه از طريق آنها مي‌توانيد خدمات پشتيباني تجاري در زمينه PostgreSQL 
دريافت كنيد در اين آدرس http://techdocs.postgresql.org/companies.php موجود است.
1.7) آخرين نسخه اعلام شده چيست؟
آخرين نسخه PostgreSQL‌  كه وجود دارد 7.4.3 است.
هدف ما آن است كه هر 6 ماه تا 8 ماه يك نسخه جديد ارائه شود.
1.8) چه مستندات و راهنمائيهايي وجود دارند؟
چندين كتابچه و صفحات راهنما و مثالهاي كوچك همراه با متن اصلي PostgreSQL‌ در شاخه 
doc وجود دارد. براي ديدن صفحات راهنما مي‌توانيد به سايت 
http://www.PostgreSQL.org/docs  نيز مراجعه نماييد.
دو كتاب در زمينه PostgreSQL‌  در آدرس‌هاي 
http://www.PostgreSQL.org/docs/awbook.htm و http://www.commandprompt.com/ppbook 
وجود دارد. ليستي از كتابهايي كه قابل خريد است در آدرس 
http://techdocs.PostgreSQL.org/techdocs/bookreviews.php وجود دارد. همچنين ليستي 
از مقالات فني در مورد PostgreSQL در آدرس http://techdocs.PostgreSQL.org وجود 
دارد.
برنامه psql يك دستور d\ دارد كه اطلاعاتي در مورد انواع داده‌هاي قابل تعريف و 
عملگر‌ها و توابع و ... به ما نشان مي‌دهد. در سايت اصلي ما اطلاعات بيشتري را 
مي‌توانيد پيدا كنيد.
1.9) چگونه مي‌توانم ازاشكالات شناخته شده و يا امكاناتي كه در اين پايگاه داده 
وجود ندارد  مطلع شوم؟
PostgreSQL يك زير مجموعه پيشرفته از SQL-92 را پشتيباني مي‌كند. در ليست  TODO   
اِشكالات شناخته شده يا امكاناتي كه وجود ندارد و يا برنامه‌‌هاي آينده آمده است.
1.10) چگونه مي‌توانم زبان SQL را ياد بگيرم؟
كتاب PostgreSQL در آدرس SQL http://www.PostgreSQL.org/docs/awbook.html ‌را آموزش 
مي‌دهد. همچنين يك كتاب در آدرس http://www.commandprompt.com/ppbook وجود دارد. يك 
راهنماي خيلي خوب هم در سايت‌هاي  
http://www.intermedia.net/support/sql/sqltut.shtm و 
http://ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM و  
http://sqlcourse.com در مورد SQL وجود دارد.
كتاب ديگري كه مي‌توان براي يادگيري SQL از آن استفاده كرد كتاب "SQL را در 21 روز 
ياد بگيريد،‌ ويرايش دوم" در سايت http://members.tripod.com/er4ebus/sql/index.htm 
مي‌باشد.
تعداد زيادي از كاربران كتاب The Practical SQL را ترجيح مي‌دهند. كتاب ديگر The 
Complete Refrence SQL انتشارات McGraw-Hill مي‌باشد.
1.11) آيا PostgreSQL مشكل Y2K‌ دارد يا خير؟
خير،‌PostgreSQL‌ با تاريخ‌هاي قبل و بعد از 2000 مشكلي ندارد.
1.12) چگونه مي‌توانم به تيم برنامه نويس PostgreSQL ملحق شوم؟
ابتدا،‌آخرين سورس را دونلود كرده و مستندات مربوط به برنامه‌نويسي PostgreSQL را 
در سايت مطالعه كنيد. سپس به گروههاي پستي ‌ pgsql-patches و pgsql-hackers  عضو 
شويد. در مرحله آخر وصله‌هاي با كيفيت بالا را به pgsql-patches ارسال كنيد.
تعداد زيادي از برنامه‌نويسان وجود دارند كه امتياز انجام تغييرات در cvs‌ را 
دارند. هر كدام از آنها تعداد زيادي وصله‌‌ با كيفيت بالا به گروه ارسال كرده‌اند 
كه اعتماد گردانندگان PostgreSQL را به دست آورده‌اند.
1.13) چگونه مي‌توانم يك اِشكال را به گروه برنامه نويس اعلام كنم؟
لطفاً صفحه مربوط به اِشكالات PostgreSQL را در سايت 
http://www.PostgreSQL.org/bugs/bugs.php مشاهده‌ كنيد. در اين سايت نحوه گزارش و 
ارسال يك اشكال توضيح داده شده است.
 همچنين براي ديدن نسخه‌هاي جديدتر PostgreSQL و يا وجود يك وصله جديد از سايت 
ftp://ftp.PostgreSQL.org/pub بازديد كنيد.
1.14) وضعيت PostgreSQL‌ در مقايسه با ساير DBMSها به چه صورت است؟
راههاي مختلفي براي اندازه‌گيري و مقايسه نرم‌افزارها وجود دارد كه عبارتند از 
امكانات، كارايي، قابليت اعتماد، پشتيباني و قيمت
    امكانات 
    PostgreSQL بيشتر امكانات موجود در سيستم‌هاي پايگاه داده تجاري بزرگ نظير 
    transactions, subselets, triggers, views, foreign key referential integrity 
    و sophisticated locking‌ را دارد. در PostgreSQL‌‌ امكاناتي وجود دارد كه 
    پايگاههاي داده ديگر آن را ندارند نظير user-defined types‌و Inheritance‌و 
    rules‌و multi-version concurrency control 

  كارايي
          كارايي PostgreSQL در حد بقيه سيستم‌هاي تجاري و متن باز است. در بعضي 
  موارد سريعتر و در بعضي موارد از آنها كندتر است. در مقايسه با MySQL براي 
  كاربران بيشتر و درخواست‌هاي پيچيده و بار زياد خواندن/نوشتن سريعتر است. در 
  درخواست‌هاي ساده SELECT‌ از MySQL كندتر است. البته MySQL خيلي از امكانات 
  PostgreSQL كه در بالا به آن اشاره شد را ندارد. هدف اصلي ما امكانات و قابليت 
  اعتماد بالاست در ضمن آنكه تلاش مي‌كنيم تا كارايي آن نيز بهبود يابد. در آدرس 
  http://openacs.org/philosophy/why-not-mysql.html يك مقايسه جالب بين MySQL و 
  PostgreSQL وجود دارد. از طرف ديگر MySQL‌ يك شركت است كه محصول خود را به صورت 
  متن باز ارائه مي‌كند ولي براي نرم‌افزار غير متن باز خود احتياج به ليسانس تجاري 
  دارد بر خلاف PostgreSQL كه يك گروه كاملاً متن باز هستند.

    قابليت اطمينان 
    ما فكر مي‌كنيم كه يك سيستم پايگاه داده‌اي كه مطمئن نباشد ارزشي ندارد. ما 
    تمام تلاشمان را براي ارائه كدهاي پايداري كه به خوبي تست شده باشند و كمترين 
    اِشكالات را داشته باشند مي‌كنيم. هر نسخه جديدي كه ارائه مي‌شود حداقل يك ماه 
    را در مرحله تست بتا مي‌گذراند. ما بر اين باور هستيم كه قابليت اطمينان 
    PostgreSQL‌ در مقايسه با ساير سيستم‌هاي پايگاه داده قابل توجه است و 
    نسخه‌هايي كه تاكنون ارائه شده است نشان مي‌دهد كه ما توانايي ارائه يك سيستم 
    قوي و محكم و مطمئن را كه آماده بهره‌برداري است داريم. 
    پشتيباني 
    گروههاي پستي ما امكان ارتباط و تماس به گروه بزرگي از برنامه نويسان و كاربران 
    را مي‌دهد كه مي‌توانند در حل مشكلات به ديگران كمك كنند. دسترسي مستقيم به 
    برنامه‌نويسان و گروههاي كاربران و راهنماها و كداصلي باعث مي‌شود كه پشتيباني 
    PostgreSQL نسبت به ساير پايگاههاي داده به نحو بهتري انجام شود. همچنين امكان 
    ارائه خدمات پشتيباني به صورت تجاري نيز وجود دارد. براي ديدن اطلاعات بيشتر به 
    FAQ section 1.6  مراجعه كنيد. 
    قيمت 
    هم براي استفاده تجاري و هم غير تجاري هيچ هزينه‌اي نبايد پرداخت شود. هيچ 
    محدوديتي براي انجام تغييرات در PostgreSQL توسط استفاده كنندگان وجود ندارد به 
    جز مواردي كه در ليسانس BSD به آن اشاره شده است. 
1.15) من چگونه مي‌توانم از نظر مالي به PostgreSQL كمك كنم؟
PostgreSQL  داراي يك ساختار تشكيلاتي درجه اول است كه آن را مديون Marc Fournier‌ 
است كه اين ساختار را ايجاد كرده است.
كيفيت يك ساختار براي يك پروژه متن باز بسيار اهميت دارد. يك ساختار خوب مي‌تواند 
مانع از حوادثي شود كه در حركت روبه‌جلوي پروژه خللي وارد مي‌كنند.
البته اين ساختار تشكيلاتي ارزان نيست. هزينه‌هاي ثابت ماهانه و روزمره براي 
نگهداري و حفظ اين ساختار مورد نياز است. اگر شما يا شركت شما مايل است كه از نظر 
مالي به اين حركت كمك كند لطفاً به سايت http://store.pgsql.com/shopping مراجعه 
كرده و كمك خود را اهدا كنيد.
هر چند در صفحه اصلي عبارت PostgreSQL,Inc‌ ذكر شده است ولي مشاركت عمدتاً براي 
پشتيباني از پروژه PostgreSQL‌ مي باشد و نه براي يك شركت مشخص. اگر ترجيح مي‌دهيد 
مي‌توانيد يك چك به آدرس مشخص شده ارسال كنيد.
اگر يك استفاده موفق از PostgreSQL سراغ داريد لطفاً آن را به سايت 
http://advocacy.postgresql.org گزارش دهيد.



سوالات مربوط به استفاده از پايگاه داده
2.1) آيا هيچ درايور ODBC‌ براي PostgreSQL وجود دارد؟
دو درايور ODBC بنامهاي psqlODBC‌ و OpenLink براي PostgreSQL‌ وجود دارد.
براي گرفتن psqlODBC به سايت 
http://gborg.postgresql.org/project/psqlodbc/projdisplay.php مراجعه كنيد.
OpenLlink را از اين سايت http://www.openlinksw.com مي‌توانيد بگيريد. اين درايور 
با نرم‌افزارهاي مختلف ODBC كار مي‌كند بنابراين شما قادر خواهيد بود با استفاده از 
OpenLink روي اكثر سكو‌هايي كه نرم‌افزارODBC‌دارند بدون مشكل به PostgreSQL نيز 
متصل شويد.
اين محصول به كساني كه احتياج به خدمات پشتيباني تجاري دارند فروخته مي‌شود. ولي 
نسخه آزاد اين نرم‌افزار هميشه در درسترس مي‌باشد. براي كسب اطلاعات بيشتر سوالات 
خود را به آدرس postgres95@openlink.co.uk ‌ارسال نماييد.
2.2) چه ابزارهايي براي استفاده از PostgreSQL‌ با صفحات وب وجود دارد؟
در سايت http://www.webreview.com براي استفاده از PostgreSQL‌ در صفحات وب 
راهنماييهاي خوبي وجود دارد.
براي تركيب و استفاده در صفحات وب زبان PHP‌ يك واسط بسيار مناسب است. اطلاعات 
بيشتر راجع به PHP‌در سايت http://www.php.net وجود دارد.
مثالهايي نيز با استفاده از Perl‌ و CGI.pm و mod_perl وجود دارد.
2.3) آيا PostgreSQL‌ يك واسط كاربري گرافيكي دارد؟
چند نرم افزار گرافيكي براي PostgreSQL‌ وجود دارد كه شامل pgAccess درسايت 
http://www.pgaccess.org و pgAdmin III در سايت http://www.pgadmin.org و RHDB 
Admin در سايت http://sources.redhat.com/rhdb و Rekall در سايت 
http://www.thekompany.com/products/rekall  مي‌باشد. همچنين يك phpPgAdmin هم در 
سايت http://phppgadmin.sourceforge.net وجود دارد كه يك واسط وبي براي مديريت 
PostgreSQL مي‌باشد.
براي ديدن اطلاعات بيشتر راجع به نرم‌افزارهاي گرافيكي براي PostgreSQL به آدرس 
http://techdocs.postgresql.org/guides/GUITools مراجعه كنيد.
2.4) با چه زبانهاي برنامه‌نويسي مي‌توان با PostgreSQL‌ ارتباط برقرار كرد؟
بيشتر زبانهاي برنامه‌نويسي مي‌توانند با PostgreSQL‌ ارتباط برقرار كنند. به همراه 
 سورس PostgreSQL تعدادي از واسطهاي مورد نياز براي ارتباط با پايگاه داده از طريق 
زبانهاي مختلف آمده است كه در زير ليست آنها را مشاهده مي‌كنيد.
  C (libpq) 
  Embedded C (ecpg) 
  Java (jdbc) 
  Python (PyGreSQL) 
  TCL (libpgtcl) 
واسطهاي ديگر در سايت http://gborg.postgresql.org در قسمت Drivers/Interfaces وجود 
دارد.



سوالات مديريتي
3.1) چگونه مي‌توانم PostgreSQL‌ را در شاخه‌اي غير از /usr/local/pgsql/  نصب كنم؟
موقع اجراي دستور configure از گزينه prefix-- استفاده كنيد.
3.2) چرا موقعي كه من برنامه postmaster‌ را اجرا مي كنم پيام Bad system call‌ و 
يا core dump ‌مي‌گيرم؟
به دلايل مختلف ممكن است اين اتفاق بيفتد. اما در قدم اول شما مطمئن شويد كه كه 
امكانات اضافه System V‌ در كرنل شما نصب شده باشد. PostgreSQL براي اجرا شدن نياز 
به استفاده از امكانات حافظه مشترك و سمافورها دارد.
3.3) چرا موقعي كه من سعي مي‌كنم برنامه postmaster‌ را اجرا كنم خطاي 
IpcMemoryCreate  مي‌گيرم؟
احتمالاً‌ قسمت ايجاد حافظه مشترك در كرنل به درستي تنظيم نشده است و يا اينكه بايد 
فضاي حافظه اشتراكي در كرنل را زياد كرد. ميزان دقيق حافظه مشترك مورد نياز بسته به 
معماري و نحوه استفاده از بافرها توسط برنامه postmaster دارد. براي بيشتر سيستم‌ها 
كه با تنظيمات پيش‌فرض كار مي‌كنند مقدار اين حافظه حدود 1 مگابايت است. براي ديدن 
اطلاعات بيشتر راجع به حافظه مشترك و سمافور به PostgreSQL Administrator's Guide 
مراجعه كنيد.
3.4) چرا موقعي كه من سعي مي‌كنم برنامه postmaster‌ را اجرا كنم خطاي  
IpcSemaphoreCreate مي‌گيرم؟
اگر پيغام خطا (‌pcSemaphoreCreate: semget failed (No space left on device  باشد 
به اين معني است كه تعداد سمافورهاي تنظيم شده در كرنل كافي نيست. PostgreSQL‌ براي 
هر فرايندي كه در backend اجرا مي‌شود به يك سمافور نياز دارد. يك راه حل موقت براي 
اين مسئله آن است كه postmaster را با اعمال محدوديت روي تعداد فرايندهايي كه 
مي‌تواند ايجاد كند اجرا كنيم. براي اينكار از گزينه N- و يك عدد كمتر از 32 
استفاده كنيد. راه حل دائمي اين مشكل آن است كه پارامترهاي SEMMNS, SEMMNI كرنل را 
افزايش دهيم.
در زمان دسترسي خيلي زياد به پايگاه داده، ‌ سمافورهاي نامعتبر مي‌توانند باعث 
crash‌ كردن سيستم شوند.
اگر پيغام خطا چيز ديگري باشد احتمالاً به دليل آن است كه كرنل از سمافورها 
پشتيباني نمي‌كند. براي ديدن اطلاعات بيشتر راهنماي مديريتي PostgreSQL را مطالعه 
كنيد.
3.5) چگونه مي‌توانم اتصالات ساير ماشينها را كنترل كنم؟
به صورت پيش فرض فقط از ماشيني كه PostgreSQL روي آن در حال اجراست مي‌توان با 
استفاده از سوكت‌هاي يونيكسي به آن متصل شد. ساير ماشين‌ها قادر نيستند به 
PostgreSQL متصل شوند مگر آنكه گزينه tcp_sockets در فايل postgresql.conf فعال شده 
و همچنين با اصلاح فايل PGDATA/ph_hba.conf هويت‌شناسي مبتني بر ميزبان نيز فعال 
شود. با اين كار مي‌توان اتصالات TCP/IP به PostgreSQL‌ ايجاد كرد.
3.6) براي كارايي بالاتر و بهتر پايگاه داده من چه تنظيماتي را بايد انجام دهم؟
به طور حتم استفاده از انديس‌ها باعث بالا رفتن سرعت پاسخ‌گويي به درخواست‌ها خواهد 
شد. دستور EXPLAIN ANALYZE به شما امكان ديدن نحوه پردازش يك دستور توسط PostgreSQL 
را مي‌دهد.
اگر شما تعداد زيادي INSERT‌ داريد سعي كنيد آنها را با قرار دادن در يك فايل با 
دستور COPY‌ اجرا كنيد. اين دستور به مراتب از INSERT سريعتر است. حتي‌الامكان سعي 
كنيد از تراكنشها استفاده نكنيد. تراكنشها مجموعه دستوراتي هستند كه بيند BEGIN و 
‍COMMIT مي‌آيند. اگر يك دستور به صورت عادي اجرا شود PostgreSQL خود آن دستور را 
به صورت يك تراكنش مستقل نگاه كرده و اجرا مي‌كند. موقعی كه تغييرات زيادي در 
پايگاه داده انجام مي‌شود انديسهاي قبلي را حذف و مجدداً‌ ايجاد كنيد.
استفاده از گزينه o -F- در فرمان postmaster باعث غير فعال كردن ()fsync مي‌شود. 
اين دستور بعد از هر تراكنش اطلاعات را روي هاردديسك منتقل مي‌كند.
براي افزايش تعداد بافرهاي حافظه اشتراكي از گزينه B- به همراه فرمان postmaster 
استفاده كنيد. توجه كنيد كه اگر اين عدد خيلي بزرگ باشد ممكن است postmaster اصلاً‌ 
اجرا نشود. هر بافر 8 كيلو بايت حافظه نياز دارد و تعداد بافرها به طور پيش فرض 64 
است.
همچنين مي‌توان با گزينه S-  ميزان حافظه‌اي كه براي مرتب‌سازي‌هاي موقت توسط 
PostgreSQL استفاده مي‌شود را افزايش داد. مقدار پيش فرض 512 كيلو بايت است.
استفاده از دستور CLUSTER نيز براي بالا بردن كارايي موثر ا ست. دستور راهنماي 
CLUSTER اطلاعات بيشتري در اين زمينه به شما مي‌دهد.
3.7) چه امكاناتي براي پيدا كردن اشكال‌ وجود دارد؟
PostgerSQL‌ امكانات مختلفي براي گزارش دادن وضعيت خود دارد كه براي اشكال زدايي 
مي‌توان از آنها استفاده كرد.
با استفاده از گزينه enable-assert-- تعداد زيادي ()assert براي مونيتور كردن و 
توقف برنامه در صورت بروز خطاهاي ناخواسته فعال مي‌شود.
هم Postmaster و هم postgres گزينه‌هاي زيادي براي اشكال زدايي دارند. موقعي كه 
postmaster را اجرا مي‌كنيد خروجي استاندارد و خطا را سمت فايل log ارسال كنيد.
    cd /usr/local/pgsql
    ./bin/postmaster >server.log 2>&1 &
اين كار يك فايل log در بالاترين شاخه PostgreSQL‌ ايجاد مي‌كند. اين فايل حاوي 
اطلاعات مفيدي در مورد مسائل و خطاهايي است كه براي سرور اتفاق افتاده است. براي 
ديدن جزئيات بيشتر مي‌توان از d-  به همراه فرمان postmaster‌ استفاده كرد. گزينه 
d- همچنين يك عدد مي‌گيرد كه نشان دهنده سطح جزئياتي است كه در Log‌فايل نوشته 
مي‌شود. با بالابردن اين عدد حجم اطلاعات توليد شده در Logفايل نيز افزايش مي‌يابد.
اگر postmaster در حال اجرا نباشد، مي‌توانيم postgres را به طور مستقيم از خط 
فرمان اجرا كرده و  دستورات SQL را به آن بدهيم. اين كار فقط براي اشكال‌يابي توصيه 
مي‌شود. توجه كنيد كه در اين حالت يك دستور با كاراكتر newline خاتمه پيدا مي‌كند و 
نه با ;. اگر postmaster را با امكانات اشكال‌يابي كامپيل كرده باشيد مي‌توانيد با 
استفاده از يك برنامه اشكال‌ياب اجراي برنامه را مونيتور كنيد. 
اگر postmaster در حال اجرا باشد با دستور psql مي‌توان به postgres متصل شد. با 
پيدا كردن PID فرايند postgres كه psql به آن متصل شده است مي‌توان آن را مونيتور 
كرد. براي اينكار بايد يك برنامه اشكال‌ياب را به آن pid متصل كرد. اگر بخواهيم 
بالا آمدن postgres را مونيتور كنيم كافي است "PGOPTIONS="-W n و psql را اجرا 
كنيم. اين كار باعث مي‌شود كه postgres با n ثانيه تاخير اجرا شود و در اين فاصله 
شما مي‌توانيد برنامه اشكال‌ياب را به آن متصل كرده و با قرار دادن يك نقطه توقف  
روند اجراي آن را مونيتور كنيد.
postgres گزينه‌هاي s-‌ و A- و t-‌ دارد كه براي پيدا كردن اشكالات بسيار مناسب 
هستند.
شما مي‌توانيد postgreSQL را با امكانات profiling كامپيل كنيد. اين كار باعث 
مي‌شود كه زمان اجراي دقيق هر تابع در برنامه مشخص شود. خروجي‌هاي توليد شده در اين 
حالت در فايل DLINUX_PROFILE. ريخته مي‌شود.
3.8) چرا موقعي كه من مي‌خواهم به پايگاه داده وصل شوم پيام "Sorry, too many 
clients" ‌مي‌گيرم؟
شما بايد حداكثر تعداد فرايندهاي همزمان postmaster را افزايش دهيد. مقدار پيش فرض 
32 است. براي افزايش آن مي‌توان از گزينه N- استفاده كرد و يا فايل postgresql.conf 
را اصلاح نمود
توجه كنيد كه اگر N- مقداري بيشتر از 32 داشته باشد بايد مقدار B- را نيز افزايش 
دهيم. اين مقدار بايد حداقل دو برابر مقدار N-‌ باشد. براي اعداد خيلي بالا بايد 
بعضي از پارامترهاي كرنل را نيز اصلاح كرد. پارامترهايي نظير حداكثر اندازه حافظه 
اشتراكي SHMMAX ، حداكثر تعداد سمافورها SEMMNI‌ و SEMMNS ، حداكثر تعداد فرايندها 
NPROC، حداكثر فرايندهاي يك كاربر MAXUPRC و حداكثر فايلهاي باز NFILE و NINODE. 
يكي از دلايلي كه تعداد اتصالات همزمان postgreSQL محدود است آن است كه نيازهاي 
PostgreSQL بيش از منابع موجود سيستم نباشد.
3.9) در شاخه  pgsql_tmp  چه چيزي قرار دارد؟
دراين شاخه فايلهاي موقتي قرار دارد كه با اجراي درخواستها به وجود آمده است. به 
عنوان مثال اگر براي اجراي دستور order by نياز به انجام مرتب سازي باشد و در صورتي 
كه حافظه مشخص شده با گزينه S- براي اينكار كافي نباشد سيستم يك فايل موقت در اين 
شاخه ايجاد مي‌كند تا عمل مرتب سازي را انجام دهد.
فايلهاي موقت معمولاً به صورت اتوماتيك پاك مي‌شود اما اگر postgreSQL در حين مرتب 
سازي crash‌ كند آن فايلها باقي مي‌مانند. با stop و start كردن برنامه postmaster 
اين فايلها پاك مي‌شوند.
3.10) چرا براي به روز كردن نسخه پايگاه داده من بايد كل داده ها را dump‌ و مجدداً 
restore كنم؟
تيم برنامه نويس postgreSQL در نسخه‌هاي ارائه شده كه فقط minor آنها متفاوت است 
فقط تغييرات كوچكي اعمال مي‌كنند؛ بنابراين براي به روز كردن از نسخه 7.2‌به 7.2.1 
نيازي به dump و restore نيست. اما در نسخه‌هايي كه major آنها تغيير مي‌كند غالباً 
ساختار داخلي جداول و فايلهاي داده تغيير مي‌كند. اين تغييرات معمولاً‌ پيچيده 
هستند. براي انتقال داده‌هاي موجود در پايگاه داده در اين حالت بايد ‌از dump و 
restore استفاده كرد.
در نسخه‌هايي كه ساختار روي ديسك تغييري نمي‌كند مي توان از برنامه pg_upgrade براي 
به روز كردن پايگاه داده استفاده كرد بدون اينكه نيازي به استفاده از dump و 
restore  باشد. در يادداشتي كه به همراه هر توزيع مي‌آيد ذكر شده است كه آيا برنامه 
pg_upgrade براي اين توزيع وجود دارد يا خير.
3.11) از چه سخت افزاري بايد استفاده كنم؟

چون اكثر سخت‌افزارهاي PC  سازگار هستند مردم فكر مي‌كنند كه كيفيت آنها نيز يكسان 
است. در حاليكه اينطور نيست. استفاده از هاردهاي SCSI و حافظه‌هاي ECC و مادربردهاي 
با كيفيت بالا نسبت به سخت افزارهاي ارزانتر نتايج بهتري از نظر كارايي و پايداري 
سيستم بهمراه خواهد داشت. PostgreSQL روي بيشتر سخت افزارها اجرا مي‌شود اما اگر 
كارايي و اطمينان فاكتورهاي مهمي هستند بايد سخت افزار مناسب استفاده شود. در 
گروههاي پستي در مورد سخت افزار مناسب  و انتخاب آن بحث شده است. 



سوالات عملياتي
4.1) تفاوت بين binary cursors و Normal cursors چيست؟
راهنماي دستور DECLARE‌ را مطالعه كنيد.
4.2) من چگونه مي‌توانم فقط روي چند رديف اول يا يك رديف تصادفي درخواست SELECT‌ 
بزنم؟
راهنماي دستور FETCH  يا SELECT...LIMIT را ببينيد.
در واقع كل درخواست بايد بررسي و ارزيابي شود حتي اگر شما فقط چند رديف اول را 
بخواهيد. براي مثال درخواست ORDER BY را در نظر بگيريد. اگر انديس يا نمايه‌اي براي 
ORDER BY وجود داشته باشد،‌postgreSQL‌ ممكن است بتواند فقط چند سطر اول درخواستي 
را ارزيابي كند و يا اينكه كل درخواست پردازش شود تا تعداد رديف‌هاي درخواستي توليد 
شود.
براي انتخاب يك سطر تصادفي به روش زير عمل مي‌كنيم:
    SELECT col
    FROM tab
    ORDER BY random()
    LIMIT 1;
4.3) من چگونه مي‌توانم ليستي از جداول يا ساير چيزهايي كه در psql‌ وجود دارد را 
ببينم؟
براي ديدن ليست جداول دستور  dt\ را در برنامه psql‌ استفاده كنيد. براي ديدن ليست 
كامل فرمانها ?\ را اجرا كنيد. راه ديگر خواندن متن برنامه psql‌ است كه در شاخه 
pgsql/src/bin/psql/describe.c ‌قرار دارد. اين فايل حاوي فرامين SQLيي است كه 
خروجي را براي  دستوراتي كه با \‌در psql شروع مي‌شوند توليد مي‌كنند. راه ديگر 
اجراي psql با گزينه E-‌است. اينكار باعث مي‌شود كه psql قبل از اجرا هر دستور 
SQL‌متناظر آن را نشان دهد. PostgreSQL‌همچنين يك برنامه SQLi دارد كه مي‌توان با 
استفاده از آن  اطلاعات داخلي پايگاه داده را استخراج كرد.
4.4) چگونه يك ستون جدول را حذف مي‌كنيد؟ چگونه نوع داده آن را عوض كنيم؟
حذف يك ستون در توزيع 7.3 با استفاده از دستور ALTER TABLE DROP COLUMN اضافه شده 
است. در نسخه‌هاي قبلي به روش زير عمل كنيد:
    BEGIN;
    LOCK TABLE old_table;
    SELECT ...  -- تمام ستونها غير از ستوني كه مي‌خواهيد آن را حذف كنيد را در اينجا بياوريد
    INTO TABLE new_table
    FROM old_table;
    DROP TABLE old_table;
    ALTER TABLE new_table RENAME TO old_table;
    COMMIT;
براي عوض كردن نوع داده يك ستون به روش زير عمل كنيد:
    BEGIN;
    ALTER TABLE tab ADD COLUMN new_col new_data_type;
    UPDATE tab SET new_col = CAST(old_col AS new_data_type);
    ALTER TABLE tab DROP COLUMN old_col;
    COMMIT;
4.5) حداكثر اندازه يك رديف،‌ جدول و خود پايگاه داده چقدر است؟
محدوديتها عبارتند از:
    حداكثر اندازه پايگاه داده             نامحدود (تا 32 ترابايت وجود دارد)
    حداكثر اندازه يك جدول               32 ترابايت
    حداكثر ا ندازه يك رديف              1.6 ترابايت
    حداكثر اندازه يك فيلد                1 گيگا بايت
    حداكثر اندازه رديفهاي يك جدول  نا محدود
    حداكثر ستونهاي يك جدول 	بسته به نوع جدول بين 250 تا 6000 
    حداكثر انديسهاي يك جدول	نا محدود
البته در حالت نامحدود نيز ما محدود به حجم هاردديسك و فضاي حافظه خواهيم بود. در 
صورتي که مقادير مشخص شده به عنوان نامحدود به صورت غير معمولي بزرك شوند كارايي 
سيستم كاهش خواهد يافت.
براي ذخيره كردن جداول با اندازه خيلي بزرگ نيازي نيست كه سيستم عامل امكان ايجاد 
فايلهاي بزرگ را داشته باشد. بلكه جداول خيلي بزرگ به صورت فايلهايي به حجم يك گيگا 
بايت نگاهداري مي‌شوند.
اگر اندازه بلوكهاي داده را برابر 32 كيلو بايت قرار دهيم حداكثر اندازه جدول و 
حداكثر تعداد ستونها 4 برابر خواهد شد.
4.6) چقدر فضاي ديسك سخت براي ذخيره كردن داده‌‌هاي يك فايل متني مورد نياز است؟
يك پايگاه داده PostgreSQL‌ تا 5 برابر فضايي روي هاردديسك براي نگاهداري يك فايل 
متني نياز دارد.
به عنوان مثال يك فايل با 100000 خط را در نظر بگيريد كه در هر خط يك عدد صحيح و يك 
توضيح متني آمده است. فرض كنيد كه رشته متني به طور متوسط 20 بايت باشد. اندازه 
فايل برابر 2.8 مگا بايت خواهد بود ولي PostgreSQL براي نگاهداري اين فايل به 6.4 
مگا بايت اطلاعات نياز خواهد داشت.
    32 bytes: اندازه سرايند هر خط به طور تقريبي
    24 bytes: يك عدد صحيح و يك رشته 24 بايتي
   + 4 bytes: اشاره گر روي صفحه به يك چندتايي
   ----------------------------------------
    60 bytes در هر رديف

اندازه صفحات داده در PostgreSQL برابر با 8 كيلو بايت است
   8192 تعداد بايت‌ها در هر صفحه
   -------------------   =  136 تعداد رديف‌ها در يك صفحه پايگاه داده
     60  تعداد بايت‌هاي هر رديف

   100000  تعداد رديفها
   --------------------  = تعدادصفحات پايگاه داده
      128 تعداد رديفها در هر صفحه

735 تعداد صفحات * 8192 تعداد بايت‌هاي هر صفحه  =  6,021,120 مگا بايت
سربار انديسها يا نمايه‌ها از اين مقدار كمتر است ولي چون شامل خود داده‌ها هم هست 
ممکن است اندازه آنها هم بزرگ شود.
NULLها به صورت bitmap ذخيره مي‌شوند و از اينرو فضاي بسيار كمي را اشغال مي‌كنند.
4.7) چگونه مي‌توانم بفهمم كه چه كاربران،‌ پايگاه داده،‌ نمايه و جداولي در سيستم 
تعريف شده است؟
psql تعداد زيادي دستور دارد كه با \ شروع مي‌شوند و اين اطلاعات را در اختيار ما 
قرار مي‌دهند. براي ديدن آنها دستور ?\  را اجرا كنيد.  همچنين جداول سيستمي كه نام 
آنها با pg_ ‌شروع مي‌شود نيز اين اطلاعات را در خود دارند. اجراي برنامه psql با 
گزينه l-  نيز باعث نشان دادن ليست تمام پايگاههاي داده مي‌شود.
همچنين فايل pgsql/src/tutorial/syscat.source نيز فرمانهاي SELECT كه با استفاده 
از آن مي‌توان اطلاعات پايگاه داده را استخراج كرد شرح داده است.
4.8) چرا درخواستهاي من كند اجرا مي‌شوند يا چرا از نمايه ها استفاده نمي‌كنند؟
به طور معمول براي درخواستها از نمايه‌ها استفاده نمي‌شود. تنها در صورتي از 
نمايه‌ها استفاده مي‌شود كه اندازه جدول از يك اندازه حداقل بزرگتر باشد و درخواست 
هم فقط قسمتي از رديف‌هاي جدول را انتخاب كرده باشد. دليل اين كار آن است كه 
دسترسي‌هاي تصادفي به هاردديسك كه به خاطر نمايه‌ها ايجاد مي‌شود ممكن است از 
خواندن مستقيم جدول يا خواندن ترتيبي ركوردها كندتر باشد.
براي تعيين اينكه از نمايه استفاده شود يا خير، PostgreSQL بايد اطلاعات آماري را 
در مورد يك جدول بداند. اين اطلاعات توسط دستور ANALYZE و VACUUM ANALYZE به دست 
مي‌آيد. با استفاده از اين اطلاعات،‌ بهينه ساز از تعداد رديف‌هاي يك جدول اطلاع 
پيدا مي‌كند و بهتر مي‌تواند تعيين كند كه آيا از نمايه استفاده شود يا خير. 
اطلاعات آماري همچنين براي تعيين ترتيب الحاق و روشهاي الحاق به صورت بهينه نيز 
كاربرد دارد. جمع آوري اطلاعات آماري بايد به صورت دوره‌اي همزمان با تغيير 
داده‌هاي جدول انجام شود.
نمايه‌ها به طور معمول همراه با دستور ORDER BY به كار برده نمي‌شوند. براي يك جدول 
بزرگ يك پيمايش ترتيبي همراه با دستور مرتب سازي از به كار بردن نمايه‌ها سريعتر 
خواهد بود.
اما اگر همراه با ORDER BY‌ از LIMIT استفاده شود اغلب از نمايه‌ها استفاده مي‌شود 
چون فقط قسمتي از جدول برگردانده مي‌شود. در حقيقت هر چند توابع ()MIN‌ و ()MAX از 
نمايه‌ها استفاده نمي‌كنند ولي مي‌توانيم با استفاده از دستور زير با استفاده از 
نمايه‌ها و دستور ORDER BY و LIMIT‌ ، آنها را به دست آوريم.
    SELECT col
    FROM tab
    ORDER BY col [ DESC ]
    LIMIT 1;
اگر شما فكر مي‌كنيد كه بهينه ساز سيستم در انتخاب پيمايش ترتيبي اشتباه كرده است 
با دستور 'SET enable_seqscan TO 'off'  مي‌توانيد ببينيد آيا استفاده از نمايه‌ها 
باعث افزايش سرعت درخواست‌ها خواهد شد يا خير.
استفاده از نمايه‌ها هنگامي كه از علائم ويژه نظير LIKE و ~ استفاده مي‌كنيد فقط در 
بعضي شرايط خاص كه در اينجا ذكر شده است ممكن است:
  ابتداي رشته جستجو بايد به طور صريح مشخص باشد براي مثال: 
- دستورات LIKE نبايد با علامت % شروع شوند
- الگوهاي منظمي كه با ~ مي‌آيد حتماً بايد با علامت ^ شروع شود
  رشته جستجو نبايد با يك مجموعه از كاراكتر‌ها  مثل [a-e] شروع شود 
  جستجوهاي غيرحساس به متن مثل  ILIKE‌ و *~ از نمايه‌ها استفاده نمي‌كنند. در عوض 
  از توابع نمايه‌اي كه در قسمت 4.12 توضيح داده شد استفاده مي‌كنند. 
  مقدار پيش فرض locale‌ بايد در initdb استفاده شود. 
4.9) چگونه مي‌توانم نحوه بررسي درخواست را توسط بهينه‌ساز درخواستها مشاهده كنم؟
راهنماي دستور EXPLAIN را نگاه كنيد.
4.10) نمايه R-tree‌ چيست؟
از نمايه R-Tree  براي انديس كردن داده‌هاي فاصله‌اي استفاده مي‌شود. يك نمايه hash 
نمي‌تواند جستجوهاي محدوده‌اي را انجام دهد. نمايه "B-tree" نيز براي انجام جستجوي 
محدوده‌اي در يك جهت قابل استفاده است. اما R-Tree مي‌تواند داده‌هاي چند بعدي را 
نيز پشتيباني كند. براي مثال اگر از نمايه R-tree‌ براي گونه Point استفاده شود 
سرعت درخواست‌هايي نظير "select all points within a bounding rectangle" به مراتب 
افزايش مي‌يابد.
مقاله‌اي كه طراحي R-tree را توضيح داده است 
Guttman, A. "R-trees: A Dynamic Index Structure for Spatial Searching." 
Proceedings of the 1984 ACM SIGMOD Int'l Conf on Mgmt of Data, 45-57.
R-tree‌ مي‌تواند چندضلعيها و چند وجهي را پشتيباني كند. در تئوري، R-tree مي‌تواند 
تعداد  بعدهاي  بالاتري را نيز  پشتيباني كند. در  عمل  توسعه R-tree‌ نياز به كار 
بيشتري دارد.
4.11) بهينه ساز تكويني درخواست چيست؟ (Genetic Query Optimizer)
استفاده از GEQO سرعت بهينه سازي درخواست را هنگاميكه تعداد زيادي جدول را با 
استفاده از الگوريتم ژنتيك الحاق مي‌كنيم افزايش مي‌دهد.
4.12) چگونه از عبارات منظم براي جستجو استفاده كنم؟ چگونه جستجويي انجام دهم كه 
حساس به متن نباشد؟ چگونه براي يك جستجوي غير حساس به متن از نمايه استفاده كنم؟
براي جستجوي عبارت منظم از عملگر ~‌ استفاده مي‌كنيم. براي جستجوي غير حساس به متن 
از عملگر *~ و يا ILIKE‌ استفاده مي‌كنيم.
روش ديگر انجام جستجوي غير حساس به متن در زير نشان داده شده است.
    SELECT *
    FROM tab
    WHERE lower(col) = 'abc';
اين از نمايه‌هاي استاندارد استفاده نمي‌كند. ولي شما مي توانيد با دستور زير يك 
نمايه ايجاد كنيد و از آن استفاده كنيد.
    CREATE INDEX tabindex ON tab (lower(col));
4.13) چگونه مي‌توانم در يك درخواست تشخيص دهم كه يك فيلد NULL‌ است؟
با استفاده از توابع IS NULL و IS NOT NULL مي‌توانيم NULL بودن يك فيلد را تست 
كنيم.
4.14) تفاوت بين گونه‌هاي مختلف character چيست؟
Type            Internal Name   Notes
--------------------------------------------------
VARCHAR(n)      varchar      اندازه، حداكثر طول را نشان مي دهد بدون اضافه شدن كاراكتر اضافه
CHAR(n)            bpchar       كاراكترهاي بلانك براي پر شدن طول مشخص شده استفاده مي‌شود
TEXT                text            حداكثر طول را مشخص نمي‌كند
BYTEA               bytea         آرايه‌اي از بايت با طول متغير
"char"               char           يك كاراكتر
نام داخلي گونه‌ها را در system catalogue ‌و بعضي از پيغامهاي خطا مي‌توان ديد.
چهار گونه اول همگي از نوع varlena هستند (4 بايت اول روي ديسك طول را مشخص مي‌كند 
كه به دنبال آن داده‌ها قرار دارند.)‌بنابراين فضاي واقعي استفاده شده روي ديسك از 
اندازه تعريف شده بيشتر است. اما اين گونه‌ها را مي‌توان فشرده كرد كه اينكار باعث 
مي‌شود فضاي كمتري روي ديسك اشغال كنند.
براي ذخيره رشته‌هاي با طول متغير(VARCHAR(n‌ بهترين انتخاب است. در اين گونه 
حداكثر طول رشته محدود است بر خلاف text كه هيچ محدوديتي روي حداكثر اندازه رشته 
نمي‌گذارد.(در اين گونه حداكثر طول يك رشته يك گيگا بايت خواهد بود)
گونه (CHAR(n  براي ذخيره داده‌هاي با طول يكسان است.يك گونه‌ي (CHAR(n با 
كاراكترهاي بلانك (خالي) پر مي‌شود تا به طول مشخص شده برسد در حاليكه گونه VARCHAR 
كاراكترها را به همان صورت كه هستند ذخيره مي‌كند. گونه BYTEA براي ذخيره داده‌هاي 
باينري است به خصوص داده‌هاي باينري كه شامل بايت‌هاي NULL هستند. از نظر كارايي 
تمام اين گونه‌ها يكسان هستند.
4.15.1) چگونه مي‌توانم يك فيلد سريال يا افزايشي ايجاد كنم؟
PostgreSQL از داده‌هاي سريال پشتيباني مي‌كند. براي ايجاد يك فيلد سريال (براي 
داشتن يك فيلد منحصر به فرد براي هر رديف )به روش زير عمل كنيد:
    CREATE TABLE person ( 
        id   SERIAL, 
        name TEXT 
    );
دستور بالا به طور اتوماتيک به دستور زير تبديل مي‌شود:
    CREATE SEQUENCE person_id_seq;
    CREATE TABLE person ( 
        id   INT4 NOT NULL DEFAULT nextval('person_id_seq'),
        name TEXT 
    );
براي ديدن اطلاعات بيشتر به راهنماي دستور create_sequence  مراجعه كنيد. همچنين 
مي‌توان از OID‌هر رديف به عنوان يك مقدار منحصر به فرد استفاده كرد. اما در اين 
حالت براي dump كردن و reload‌كردن پايگاه داده بايد دستور pg_dumps‌ را با گزينه 
o-‌ اجرا كنيد.
4.15.2) چگونه مي‌توانم مقدار يك درج سريالي را بدانم؟
يك روش براي گرفتن مقدار بعدي يك فيلد سريال استفاده از تابع ()nextval است. در شبه 
كُدي كه در ادامه آمده است روش انجام اين كار نشان داده شده است:
    new_id = execute("SELECT nextval('person_id_seq')");
    execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");
با اجراي دستور فوق مقدار جديد را در متغير new_id نيز خواهيدداشت كه مي‌توانيد آن 
را در بقيه درخواست‌ها نيز استفاده كنيد. توجه داشته باشيد كه نام SEQUENCEيي كه به 
طور اتوماتيك ايجاد شده است به صورت table_serialcolumn_seq‌ خواهد بود. كه در آن 
table‌ نام جدول و serialcolumn نام فيلد سريال جدول مي‌باشد.
براي ديدن مقدار نسبت داده شده به فيلد سريال نيز مي‌توان از تابع () currval به 
صورت زير استفاده كرد. 
    execute("INSERT INTO person (name) VALUES ('Blaise Pascal')");
    new_id = execute("SELECT currval('person_id_seq')");
و سرانجام شما مي‌توانيد از مقدار OID كه خروجي دستور INSERT  است براي ديدن مقدار 
پيش فرض استفاده كنيد. هر چند اين روش در همه پلتفرمها قابل استفاده نيست و ضمن 
اينكه فيلد oid‌ بعد از عدد 4 ميليارد دوباره صفر مي‌شود. در زبان perl با استفاده 
از DBI و DBD::Pg مقدار oid‌را مي‌توانيد به اين شكل استخراج كنيد: بعد از اجراي 
()st->execute$ مقدار oid‌ در متغير  sth->pg_oid_status$ ذخيره خواهد شد.
4.15.3) آیا توابع ()nextval و ()currval منجر به ایجاد شرایط race برای سایر 
کاربران می شوند؟
خیر، استفاده از این توابع شرایط race را به وجود نمی آورد.
4.15.4) چرا اعداد سریالی مربوط به تراکنشهای abort شده مجدداً استفاده نمی شود؟ 
چرا بین اعداد سریالی یک فاصله خالی ایجاد می شود؟
برای بالا بردن امکان اجرای همزمان تراکنشها، اعداد سریالی به محض اجرای تراکنش به 
آنها تخصیص می یابد در این حالت اگر بعضی از تراکنشها abort شوند بین اعداد سریالی 
استفاده شده یک فاصله خالی به وجود می آید.
4.16) OID و TID چه هستند؟
OID راه حل PostgreSQL برای داشتن یک شناسه منحصر به فرد برای هر ردیف است. هر ردیف 
جدیدی که ایجاد می شود یک OID منحصر به فرد به آن اختصاص می یابد. تمام OIDهایی که 
در حین initdb ایجاد می شوند از 16384 کمتر هستند و OIDهایی بعداً تولید می شود از 
این عدد بزرگتر خواهد بود. نکته مهم آن است که OIDها نه تنها در یک جدول شبیه 
نیستند بلکه در کل پایگاه داده هیچ دو ردیفی دارای OID یکسان نخواهد بود.
PostgreSQL از OID در سیستم داخلی خود برای ایجاد ارتباط بین ردیفهای جداول مختلف 
استفاده می کند. توصیه می شود که یک ستون از نوع OID برای ذخیره این فیلد در جدول 
ایجاد کنید. ساختن یک نمایه برای این فیلد باعث دسترسی سریعتر به آن خواهد شد.
تمام پایگاههای داده در PostgreSQL برای گرفتن OID جدید از یک ناحیه مرکزی استفاده 
می کند. ولی اگر بخواهیم OID را به روش دیگری بگیریم و یا اینکه در حین کپی کردن یک 
جدول بخواهیم OIDهای اصلی آن تغییر نکند به روش زیر می توانیم عمل کنیم:

        CREATE TABLE new_table(mycol int);
        SELECT oid AS old_oid, mycol INTO tmp_table FROM old_table;
        COPY tmp_table TO '/tmp/pgtable';
        COPY new_table WITH OIDS FROM '/tmp/pgtable';
        DROP TABLE tmp_table;
OID یک عدد صحیح 4 بایتی است و بنابراین حداکثر مقدار آن 4 میلیارد خواهد بود و بعد 
از آن مقدار آن سرریز خواهد شد.  البته تا کنون برای  کسی  این اتفاق نیفتاده است و 
تصمیم گرداندگان PostgreSQL آن است که قبل از آنکه این اتفاق رخ دهد این مشکل را 
برطرف کنند.
TIDها برای شناسایی محل فیزیکی یک ردیف بر اساس بلوک و آفست می باشد. TIDها بعد از 
تغییر پیدا کردن یک  ردیف و یا  بازخوانی  آن  عوض  می شوند. TIDها توسط نمایه ها 
استفاده می شوند.
4.17) معني بعضي از ترمها و كلماتي كه در PostgreSQL‌ استفاده مي‌شود چيست؟
لیست برخی از ترمها و کلماتی که استفاده می شوند:
  table, relation, class :کلاس، رابطه، جدول
  row, record, tuple چندتایی، رکورد، ردیف
  column, field, attribute صفت، فیلد، ستون
  retrieve, select انتخاب، خواندن
  replace, updateبه روز کردن، جایگزینی 
  append, insert درج، اضافه کردن
  OID, serial value مقدار سریال
  portal, cursor 
  range variable, table name, table alias 
یک لیست عمومی از ترمهای مورد استفاده در پایگاه داده در آدرس  
http://hea-www.harvard.edu/MST/simul/software/docs/pkgs/pgsql/glossary/glossary.htm 
وجود دارد.
4.18) چرا من خطاي "ERROR: Memory exhausted in AllocSetAlloc" مي‌گيرم؟
این خطا احتمالاً یا به خاطر تمام شدن حافظه مجازی سیستم شماست و یا اینکه کرنل 
برای برنامه ها در مورد میزان استفاده از حافظه مجازی محدودیت اعمال کرده است. قبل 
از اجرای برنامه اصلی یکی از دستورات زیر را اجرا کنید.
    ulimit -d 262144
    limit datasize 256m
بسته به نوع شل یکی از این دستورات ممکن است با موفقیت اجرا شود. با اجرای آن دستور 
محدودیت حافظه مجازی برای برنامه ها برداشته شده و با این کار احتمالاً درخواستی که 
قبلاً خطا می داده است اجرا خواهد شد.
4.19) از كجا تشخيص دهم كه ويرايش يا نسخه PostgreSQLيي كه من استفاده مي‌كنم چيست؟
با اجرای دستور ()SELECT version
4.20) چرا حین اجرای عملیات روی large-objectها خطای "invalid large obj 
descriptor"به وجود می آید؟
شما باید قبل از شروع دستوراتی که با large-objectها کار می کنند BEGIN  و بعد از 
آنها هم یک END بگذارید. در حال حاضر PostgreSQL هندل large-objectها را در زمان 
نهایی شدن تراکنش (commitشدن) می بندد. به همین دلیل اولین تلاش برای انجام هر کاری 
با هندل منجر به خطای invalid large obj descriptor خواهد شد. برای جلوگیری از این 
خطا حتماً باید از یک تراکنش استفاده کنید. این کار همانطور که قبلاً گفته شد با 
استفاده از قرار دادن BEGIN و END در ابتدا و انتهای دستورات انجام می شود.
اگر این خطا را در حین استفاده از یک درایور ODBC دریافت کردید احتمالاً باید این 
دستور را اجرا کنید: set auto-commit off
4.21) چگونه يك ستون ايجاد كنم كه مقدار زمان جاري را به عنوان مقدار پيش‌فرض داشته 
باشد؟
از CURRENT_TIMESTAMP  استفاده کنید در مثال زیر نحوه انجام این کار نشان داده شده 
است:
CREATE TABLE test (x int, modtime timestamp DEFAULT CURRENT_TIMESTAMP );

4.22) چرا "زير درخواستهايي" كه از IN استفاده مي‌كنند كند هستند؟
در نسخه های قبل از 7.4 عمل الحاق زیر درخواست و درخواست اصلی به این صورت انجام می 
شود که نتایج به دست آمده از زیر درخواست به صورت ترتیبی برای هر ردیف اعمال می 
شود. اگر زیردرخواست ردیف های کمی را به عنوان خروجی برگرداند و درخواست بیرونی 
ردیف های زیادی را شامل شود استفاده از IN بهترین روش است در غیر اینصورت بهتر است 
از EXISTS استفاده شود
    SELECT *
    FROM tab
    WHERE col IN (SELECT subcol FROM subtab);
به:
    SELECT *
    FROM tab
    WHERE EXISTS (SELECT subcol FROM subtab WHERE subcol = col);
برای اجرای سریع این درخواست باید برای ستون subcol نمایه ایجاد شده باشد.
در نسخه های بعد از 7.4 IN برای الحاق از همان تکنیک پیچیده مورد استفاده در 
دستورات معمولی استفاده می کند و بنابراین استفاده از آن نسبت به EXISTS ارجحیت 
دارد.
4.23) چگونه مي‌توانم يك الحاق خارجي (outer join) انجام دهم؟
برای انجام الحاق خارجی به روش زیر عمل کنید:
    SELECT *
    FROM t1 LEFT OUTER JOIN t2 ON (t1.col = t2.col);
یا
    SELECT *
    FROM t1 LEFT OUTER JOIN t2 USING (col);
درخواستهای بالا t1.col , t2.col را به هم الحاق می کند و همچنین ردیفهای t1 که 
نظیر آنها در t2 نبوده است را نیز برمی گرداند. اگر از RIGHT استفاده شود نتیجه بر 
عکس است. یعنی ردیفهای t2 که نظیر آنها در t1 نباشد را نشان می دهد و اگر از FULL 
استفاده شود نتیجه هم شامل ردیفهای t1 است  و هم شامل ردیفهای t2. استفاده از کلمه 
OUTER اختیاری است چرا که این کلمه به طور ضمنی در دستورهای LEFT, RIGHT, FULL وجود 
دارد.
در نسخه های قبلی پایگاه داده می توانیم الحاق خارجی را به کمک دستورهای UNION, NOT 
IN شبیه سازی کنیم. این کار در مثال زیر نشان داده شده است:

    SELECT tab1.col1, tab2.col2
    FROM tab1, tab2
    WHERE tab1.col1 = tab2.col1
    UNION ALL
    SELECT tab1.col1, NULL
    FROM tab1
    WHERE tab1.col1 NOT IN (SELECT tab2.col1 FROM tab2)
    ORDER BY col1
4.24) چگونه مي‌توان درخواستهايي از چند پايگاه داده توليد كرد؟
در حال حاضر این کار امکان پذیر نیست. PostgreSQL فقط امکان درخواست از پایگاه داده 
ای را می دهد که در حال حاضر به آن متصل باشید و نمی‌توان به طور همزمان از دو 
پایگاه داده استفاده کرد. البته یک برنامه کاربردی خود می تواند به طور همزمان دو  
پایگاه داده را مورد استفاده قرار داده و نتایج را با هم ترکیب کند ولی نمی تواند 
در یک درخواست به هر  دو پایگاه داده رجوع کند.
4.25) چگونه خروجي يك تابع مي‌تواند  چند رديف يا ستون باشد؟
در نسخه 7.3 خروجی یک تابع می تواند چند ردیف یا چند ستون باشد. برای دیدن  اطلاعات 
بیشتر به سایت زیر مراجعه 
کنید:http://techdocs.postgresql.org/guides/SetReturningFunctions  
4.26) در توابع PL/PgSQL چرا نمي‌توان با اطمينان جداول موقت را ايجاد يا حذف كرد؟
PL/PgSQL محتوای توابع را ذخیره (cache) می کند. یک اثر بد جانبی این کار آن است که 
اگر در تابع از یک جدول موقت استفاده شود و بعداً آن جدول حذف و یک جدول جدید به 
جای آن ایجاد شود، در فراخوانی مجدد  آن تابع، محتوای ذخیره شده تابع  هنوز به جدول 
قدیمی اشاره می کند و بنابراین اجرای تابع با اشکال مواجه می شود. راه حل این مشکل 
آن است که برای جداول موقت از دستور EXECUTE استفاده شود که این کار سبب می شود که 
درخواست برای هر بار اجرا مجدداً پیمایش و تفسیر شود.
4.27) چه گزينه‌هايي براي تكرار (replication) وجود دارد؟ 
There are several master/slave replication options available. These allow only 
the master to make database changes and the slave can only do database reads. 
The bottom of http://gborg.PostgreSQL.org/genpage?replication_research lists 
them. A multi-master replication solution is being worked on at 
http://gborg.PostgreSQL.org/project/pgreplication/projdisplay.php.
4.28) چه گزينه‌هايي براي رمزنگاري وجود دارد؟ 
  contrib/pgcrypto شامل توابع رمزنگاری زیادی است که می توان از آنها در دستورات 
  SQL استفاده کرد.
  برای رمز کردن ارتباط بین client و server  پایگاه داده حتماً گزینه SSL را بر 
  روی پایگاه داده فعال کنیم.
  در نسخه 7.3 به بعد کلمات عبور کاربران به طور اتوماتیک به صورت رمز شده ذخیره می 
  شود ولی در نسخه های قبلی باید گزینه PASSWORD_ENCRYPTION را در 
  فایلpostgresql.conf فعال کنیم. 
  می توان پایگاههای داده را روی یک فایل سیستم رمزشده نگاهداری کرد



Extending PostgreSQL
5.1) من يك تابع نوشته‌ام. چگونه آن را در psql اجرا كنم؟ چرا با اجراي آن core 
dump مي‌گيرم؟
دلایل مختلفی می تواند باعث بروز این مشکل شود. اما قبل از همه، تابع خود را به 
صورت جدا تست کنید.
5.2) چگونه مي‌توانم در توليد نوع‌ها و توابع جديد و جالب براي PostgreSQL‌ همكاري 
و مشاركت داشته باشم؟
کد خود را به گروه پستی pgsql-hackers   ارسال کنید.
5.3)  چگونه مي‌توانم يك تابع به زبان C بنويسم كه خروجي آن يك ‌tuple  (چند تايي) 
باشد؟
در نسخه های 7.3 به بعد یک تابع می تواند یک جدول را به عنوان خروجی برگرداند. این 
ویژگی در توابعی که به زبانهای C و PL/PgSQL نوشته می‌شوند به طور کامل وجود دارد. 
راهنما برنامه نویسان را مطالعه کنید. یک مثال از نحوه برگرداندن یک جدول به عنوان 
خروجی در contrib/tablefunc آمده است.
5.4) من يك فايل منبع را عوض كرده ام چرا در عمليات كامپيل مجدد آن، تغيير ديده 
نمي‌شود؟
Makefile برای فایلهای include شده وابستگیها را به درستی نشان نمی دهد. برای 
اطمینان از اینکه فایلی که عوض کرده اید حتماً دوباره کامپیل می‌شود دستور make 
clean را اجرا کنید. اگر از کامپیلر gcc استفاده می کنید می توانید از گزینه 
enable-depend-- در موقع اجرای برنامه configure استفاده کنید این گزینه باعث می 
شود که وابستگیها به طور اتوماتیک تولید شود.