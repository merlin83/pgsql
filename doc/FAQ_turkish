		PostgreSQL için Sýkça Sorulan Sorular (SSS)
                                       
   Son güncelleme : 19.05.2003 Cuma 05:03

   Bruce Momjian (pgman@candle.pha.pa.us)
   Çeviren : Devrim GÜNDÜZ (devrim@gunduz.org), Nicolai Tufar (ntufar@yahoo.com), Volkan Yazýcý (volkany@celiknet.com)
   
   Bu belgenin en güncel hali, http://www.gunduz.org/seminer/pg/FAQ_turkish ve 
   http://www.PostgreSQL.org/docs/faq-turkish.html 
   adreslerinde gorülebilir.
   
   Platforma özel sorularýnýz, 
   http://www.PostgreSQL.org/users-lounge/docs/faq.html adresinde yanýtlanýr.
     _________________________________________________________________
   
                             Genel Sorular
                                      
   1.1) PostgreSQL nedir? Nasýl okunur?
   1.2) PostgreSQL' in haklarý nedir?
   1.3) PostgreSQL, hangi Unix platformlarýnda çalýsýr?
   1.4) Hangi Unix olmayan uyarlamalarý bulunmaktadýr?
   1.5) PostgreSQL'i nereden indirebilirim?
   1.6) Desteði nereden alabilirim?
   1.7) En son sürümü nedir?
   1.8) Hangi belgelere ulasabilirim?
   1.9) Bilinen hatalar ya da eksik özelliklere nereden ulasabilirim?
   1.10) Nasýl SQL ögrenebilirim?
   1.11) PostgreSQL 2000 yýlýna uyumlu mudur?
   1.12) Geliþtirme takýmýna nasýl katýlabilirim?
   1.13) Bir hata raporunu nasýl gönderebilirim?
   1.14) PostgreSQL, diger DBMS'lerle nasýl karþýlaþtýrýlabilir?
   1.15) PostgreSQL'e maddi açýdan nasýl destek olabilirim?
   
                      Kullanýcý/istemci Sorularý
                                      
   2.1) PostgreSQL icin ODBC sürücüleri var mý?
   2.2) PostgreSQL'i web sayfalarýnda kullanabilmek için hangi araçlar bulunmaktadýr?
   2.3) PostgreSQL'in grafik kullanýcý arabirimi var mýdýr? 
        Report generator var mýdýr? Gömülü sorgu dili arabirimi var mýdýr?
   2.4) PostgreSQL ile iletiþimi kurabilmek için hangi dilleri kullanabilirim?
   
                   Yönetimsel Sorular
                                      

   3.1) PostgreSQL'i, /usr/local/pgsql dizininden baþka dizinlere nasýl kurabilirim?
   3.2) Postmaster'i baslattýgýmda, Bad System Call ya da core dumped mesajý 
	alýyorum. Neden?
   3.3) Postmaster'i baþlattýðýmda, IpcMemoryCreate hatasý alýyorum. Neden?
   3.4) Postmaster'i baþlattýðýmda, IpcSemaphoreCreate hatasý alýyorum. Neden?
   3.5) Diðer bilgisayarlarýn benim PostgreSQL veritabaný sunucuma baðlantýlarýný nasýl 
	kontrol edebilirim?
   3.6) Veritabaný motorunu daha iyi baþarým icin nasýl ayarlayabilirim?
   3.7) Hangi hata ayýklama özellikleri bulunmaktadýr?
   3.8) Baðlanmaya çalýþýrken, neden "Sorry, too many clients" hatasýný alýyorum?
   3.9) pgsql_tmp dizininin içindeki dosyalar nelerdir?
   3.10) PostgreSQL sürümlerini yükselmek için neden bir dump/reload iþlemi gerçekleþtirmek 
	zorundayým?

                        Ýþletimsel Sorular
                                      
   4.1) Binary cursor ve normal cursor arasýndaki fark nedir?
   4.2) Sorgunun sadece ilk birkaç satýrýný nasýl SELECT edebilirim?
   4.3) psql'in içinde gördüðüm tablolarýn ya da diðer þeylerin listesini nasil alabilirim?
   4.4) Bir tablodan bir kolonu nasýl kaldýrabilirim?
   4.5) Bir satýr, tablo ve veritabaný icin en fazla büyüklük nedir? 
   4.6) Tipik bir metin dosyasýndaki veriyi saklamak için ne kadar disk alaný gereklidir?
   4.7) Veritabanýnda hangi tablo ya da indexlerin tanýmlandýgýný nasýl görebilirim?
   4.8) Sorgularým cok yavaþ, ya da indexlerimi kullanmýyorlar. Neden?
   4.9) Query-optimizer in sorgularýmý nasýl deðerlendirdigini, iþleme soktuðunu nasýl görebilirim?
   4.10) R-tree index nedir?
   4.11) Genetic Query Optimizer nedir?
   4.12) Düzenli ifade (Regular Expression) aramalarýný ve büyük/küçük harfe duyarsýz aramalarý nasil yapabilirim?
	Bu büyük(küçük harfe duyarlý aramalar için indeksi nasil kullanabilirim?

   4.13) Bir sorguda, bir alanýn "NULL" olduðunu nasýl ortaya çýkarabilirim?
   4.14) Çesitli karakter tipleri arasýndaki farklar nelerdir?
   4.15.1) Nasýl serial/otomatik artan(auto-incrementing) bir alan yaratabilirim?
   4.15.2) SERIAL giriþinin deðerini nasýl alabilirim?
   4.15.3) currval() ve  nextval() diðer kullanýcýlara sorun yaratmaz mý?
   4.15.4) Neden sequence sayýlarýn transaction iþleminin iptalinden sonra yeniden kullanýlýyor? Neden sequence/SERIAL 
	kolonumdaki sayýlarda atlamalar oluyor?
   4.16) OID nedir? TID nedir?
   4.17) PostgreSQL' de kullanýlan bazý terimlerin anlamlarý nelerdir?
   4.18) Neden  "ERROR: Memory exhausted in AllocSetAlloc()"? hatasýný alýyorum?
   4.19) Hangi PostgreSQL sürümünü çalýstýrdýðýmý nasýl görebilirim?
   4.20) Neden large-object iþlemlerim, "invalid large obj descriptor"? hatasýný veriyor?
   4.21) Þu andaki zamaný öntanýmlý deðer olarak kabul eden kolonu nasýl yaratýrým?
   4.22) Neden IN kullanan subquerylerim çok yavaþ?
   4.23) Outer join iþlemini nasýl yapabilirim?
   4.24) Ayný anda birden fazla veritabanýnda nasýl iþlem yapabilirim?
   4.25) Bir fonksiyondan nasýl çoklu satýr ya da kolon döndürebilirim?
   4.26) Neden Pl/PgSQL fonksiyonlarý içinden güvenli bir þekilde tablo yaratma/kaldýrma iþlemlerini yapamýyoruz?
   4.27) Hangi replikasyon seçenekleri bulunmaktadýr?
   4.28) Hangi þifreleme seçenekleri bulunmaktadýr?
	
	PostgreSQL Özelliklerini Geniþletmek
                                      
   5.1) Kullanýcý-tanýmlý bir fonksiyon yazdým. psql'de çalýþtýrdýðým zaman neden 
	core dump ediyor?
   5.2) PostgreSQL'e nasýl yeni veri tipleri/fonksiyonlar ekleyebilirim?
   5.3) Bir tuple döndürmek için bir C fonksiyonunu nasýl yazarým?
   5.4) Bir kaynak dosyasýnda deðisiklik yaptým. Yeniden derlememe raðmen 
	deðiþiklik geçerli olmuyor. Neden?
     _________________________________________________________________
   
                             Genel sorular
                                      
    1.1) PostgreSQL nedir?
    
   PostgreSQL, Post-Gres-Q-L olarak okunur.
   
   PostgreSQL, yeni-nesil VTYS arastýrma prototipi olan POSTGRES veritabaný 
   yönetim sisteminin geliþtirilmesidir. POSTGRES' in zengin veri 
   tiplerini ve güçlü veri modelini tutarken, SQL'in geliþtirilmis alt kümesi 
   olan PostQuel dilini kullanýr. PostgreSQL ücretsizdir ve kaynak kodu açýk daðýtýlýr.

   PostgreSQL, PostgreSQL gelistirme listesine üye olan bir ýnternet gelistirici
   takýmý tarafýndan geliþtirilir. Þu andaki koordinatör, Marc G. Fournier 
   (scrappy@PostgreSQL.org). (Bu takýma nasýl katýlacagýnýzý ögrenmek için  
   1.6 numaralý maddeyi okuyunuz.) Bu takým, tüm PostgreSQL geliþiminden sorumludur.

   PostgreSQL 1.01 sürümünün yazarlarý Andrew Yu ve Jolly Chen idi. Bunlarýn dýsýnda bir kaç kisi de uyarlama,
   hata ayýklama ve kodun gelistirilmesi için çalýsmýstý. PostgreSQL'in türedigi orijinal Postgres kodu, 
   lisans, lisansüstü ve akademisyenler tarafindan, Professor Michael Stonebraker ) University of
   California, Berkeley) koordinatörlügünde yazýlmýstýr.
   
   Berkley'deki yazýlýmým adý Postgres idi. SQL uyumlulugu 1995'te eklenince, adý Postgres 95
   oldu. 1996 yýlýnýn sonlarýnda adý PostgreSQL olarak degistirildi.
   
       1.2) PostgreSQL'in haklarý nedir?
       
   PostgreSQL Data Base Management System
   
   Portions copyright (c) 1996-2002, PostgreSQL Global Development Group
   Portions Copyright (c) 1994-6 Regents of the University of California
   
   Permission to use, copy, modify, and distribute this software and its
   documentation for any purpose, without fee, and without a written
   agreement is hereby granted, provided that the above copyright notice
   and this paragraph and the following two paragraphs appear in all
   copies.
   
   IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
   FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
   INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND
   ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN
   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   
   THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
   INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
   PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
   CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
   UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
   
   Üstteki metin klasik açýk-kod lisansý olan BSD lisansýdýr. Kaynak kodun nasýl 
   kullanýlabileceðine dair sýnýrlamalarý yoktur. Bu lisansi seviyoruz ve deðiþtirme 
   niyetimiz bulunmamaktadýr.
   
       1.3) PostgreSQL, hangi Unix platforlarýnda çalýsýr?
    
   Genel olarak, modern bir Unix-uyumlu platform PostgreSQL'i çalýstýracaktýr.
   Ayrýntýlý bilgi için kurulum belgelerine bakabilirsiniz
   
       1.4) Hangi Unix olmayan uyarlamalarý bulunmaktadýr?
    
   Ýstemci
   
   libpq C kütüphanesini, psql ve diger arabirimleri ve binary dosyalarý, MS
   Windows ortamlarýnda çalýsmasý için derlemeniz mümkündür. Bu örnekte  istemcide
   MS Windows çalýsýyor ve desteklenen Unix platformlarýndan birinde çalýsan PostgreSQL
   sunucuna TCP/IP ile baglanmaktadýr. Daðýtým içindeki win31.mak dosyasý ile,
   Win32 libpg kütüphanesi ve psql yaratabilirsiniz. PostgreSQL ayný zamanda ODBC
   istemcileri ile haberlesebilmektedir.

   Sunucu

   Veritabaný sunuucsu Cygwin kullanarak Windows NT, 2K ya da XP üzerinde calistirilabilir.
   Dagýtým içindeki pgsql/doc/FAQ_MSWýN dosyasýný ya da web sitemizdeki MS Windows FAQ'u
   inceleyebilirsiniz. 
	
   Doðal Windows NT/2000/XP portu için þu anda çalýþmalar devam etmektedir. Windows sürümü  
   hakkýnda güncel bilgi için, http://techdocs.postgresql.org/guides/Windows adresini 
   ziyaret edebilirsiniz.
 	
   Ayrýca, http://forge.novell.com adresinde Novell Netware 6 portu bulunmaktadýr.  

       1.5) PostgreSQL'in nereden indirebilirim?
    
   PostgreSQL için ana anonim ftp sitesi ftp://ftp.PostgreSQL.org/pub ' dur.
   Yansýlar için, ana web sayfamýza bakabilirsiniz.
   
   1.6) Desteði nereden alabilirim?
    
   Ana e-posta listesi : pgsql-general@PostgreSQL.org. PostgreSQL konusundaki tartýsmalara
   açýktýr. Üye olmak için, asagýdaki satýrlarý e-postanizin body kýsmýna (konu kýsmýna degil)
   yazýp, pgsql-general-request@PostgreSQL.org adresine gönderin:

    subscribe
    end

   Ayný zamanda, bir digest listesi bulunmaktadýr. Bu listeye üye olmak için, 
    pgsql-general-digest-request@PostgreSQL.org adresine, body kýsmýnda
   
    subscribe
    end

   yazan bir e-posta atmanýz yeterli olacaktýr.

   Digest postalar, ana liste 30k civarýnda e-postaya ulastiginda üyelere gönderilmektedir.

   Buglar için bir e-posta listesi bulunmaktadýr. Bu listeye üye olmak için,
   email to pgsql-bugs-request@PostgreSQL.org adresine, body kýsmýnda

    subscribe
    end

    yazan bir e-posta atmanýz yeterli olacaktýr.

   Ayný zamanda, gelistiriciler için tartýsma listesi bulunmaktadýr. Bu listeye üye olmak
   için,  pgsql-hackers-request@PostgreSQL.org adresine,  body kýsmýnda

    subscribe
    end

   yazan bir e-posta atmanýz yeterli olacaktýr.

   Bunun dýsýndaki e-posta listelerine ve PostgreSQL hakkýnda bilgiye, PostgreSQL WWW 
   ana sayfasýndan ulasabilirsiniz:
   
     http://www.PostgreSQL.org

   Ayný zamanda, EFNet üzerinde, #PostgreSQL adlý bir ýRC kanalý bulunmaktadýr. Bunun için,
    irc -c '#PostgreSQL' "$USER" irc.phoenix.net Unix komutunu kullanabilirsiniz.
   
   Ticari destek veren firmalarýn listesine,

   http://www.postgresql.org/users-lounge/commercial-support.html
 
   adresinden ulasabilirsiniz.
   
       1.7) En son sürümü nedir?
    
   PostgreSQL'in son sürümü 7.3.3'tür. 

   Her 4 ayda major release çýkarýlmasý planlanmaktadýr.
   
       1.8) Hangi belgelere ulasabilirim?
    
   Daðýtýmýn icinde, kitapciklar, kitapcik sayfalari ve bazi küçük örnekler verilmektedir.
   /doc dizinine bakýnýz. Ayrica, bu el kitapçýklarýný online olarak
   http://www.PostgreSQL.org/docs/ adresinden inceleyebilirsiniz. 

   http://www.PostgreSQL.org/docs/awbook.html ve http://www.commandprompt.com/ppbook 
   adreslerinde PostgreSQL kitaplarý bulunmaktadýr. PostgreSQL kitablarýnýn listesine, 
   http://www.ca.PostgreSQL.org/books/ adresinden ulaþaiblirsiniz. Ayrýca, PostgreSQL 
   konusundaki teknik makalelere de http://techdocs.PostgreSQL.org/ adresinden 
   ulaþabilirsiniz.

   psql'in, \d ile baslayan veri tipler, operatorler, fonksiyonlar, aggregateler,vb. ile 
   ilgili güzel komutlarý vardýr.
   
   Web sitemiz daha fazla belgeyi içermektedir.
   
       1.9) Bilinen hatalar ya da eksik özelliklere nereden ulasabilirim?
    
   PostgreSQL SQL-92 uyumlugugu icindedir, standartlardan fazla da özellikleri
   bulunmaktadýr. Bilinen hatalar, eksik özellikler ve gelecek ile ilgili planlar için
   TODO listesine bakýnýz.
   
       1.10) Nasýl SQL ögrenebilirim?
    
   http:/www.PostgreSQL.org/docs/awbook.html adresindeki kitap SQL ögretecektir.
   http://www.commandprompt.com/ppbook adresinde de bir baska PostgreSQL kitabý bulunmaktadýr.

   http://www.intermedia.net/support/sql/sqltut.shtm,
   http://ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM
   http://sqlcourse.com ve http://sqlcourse2.com adreslerinde de güzel belgeler bulunmaktadýr.

   Bir baþkasý da,  http://members.tripod.com/er4ebus/sql/index.htm adresinde bulunan
   "Teach Yourself SQL in 21 Days, Second Edition" kitabýdýr.
   
   Bazý kullanýcýlarýmýz da þu kitabý önermektedirler: 
	The Practical SQL Handbook, Bowman, Judith S., et al.,Addison-Wesley. Others 
	like The Complete Reference SQL, Groff et al., McGraw-Hill.    

   1.11) PostgreSQL 2000 yýlýna uyumlu mudur?
    
   Evet. 
   
       1.12) Gelistirme takýmýna nasýl katýlabilirim?
    
   Öncelikle, en son kaynak kodunu indirin ve web sitemizdeki ya da dagýtýmýn içindeki 
   PostgreSQL Developer belgesini okuyun. Ardindan, pgsql-hackers ve pgsql-patches 
   listelerine üye olun. Üçüncü olarak da, pgsql-pacthes listesine yüksek kalitede 
   yamalar gönderin.

   PostgreSQL CVS arsivine erisim izni olan, 10 kadar gelistirici bulunmaktadir.
   Hepsi defalarca, diger kisilerin yaptigindan cok daha  yüksek-kaliteli patchler 
   gondermislerdir. Ayrica biz de bu gelistiricilerin ekledikleri yamalarin yüksek
   kalitede olduguna güveniyoruz.
   
       1.13) Bir hata raporunu nasýl gönderebilirim? 

  PostgreSQL BugTool sayfasina gidiniz. O sayfada bir bug bildirmek icin neleri 
  yapmanýz gerektigi anlatilmistir.
   
  Ayrýca, ftp://ftp.PostgreSQL.org/pub ftp adresimizde, yeni bir PostgreSQL sürümü 
  ya da yamasi olup olmadigini kontrol ediniz.
   
       1.14) PostgreSQL, diger DBMS'lerle nasýl karsilastýrýlabilir?
    
   Bir yazilimin gücünü ölçmek için çesitli yollar vardir: Yazilimin özellikleri, 
   basarýmý, güvenilirligi, destegi ve ücreti.
   
   Özellikler

   PostgreSQL mevcut büyük ticari veritabanlarinin, transaction, subselect, 
   trigger, view, foreign key referential integrity ve sophisticated locking gibi
   tüm özelliklerine sahiptir. Onlarin sahip olmadiklari, kullanici-tanimli tipler 
   (user-defined types), rules, inheritance  ve lock cakýsmalarini düsürmek icin 
   multi-version uyumluluk özellikleri bulunmaktadir.
          
   Performans (Baþarým)

   PostgreSQL, diðer ticari ve açýk kaynak kodlu veritabanlarýyla yakýn baþarýmý saðlar. 
   Bazý açýlardan daha hýzlýdýr, diðer açýlardan da yavaþtýr. MySQL ya da daha zayýf 
   veritabanlarý ile karþýlaþtýrýldýðýnda,insert/update islemlerinde, transaction bazlý 
   çalýstýðýmýz için daha yavaþýz. MySQL, yukarýdaki "Özellikler" kýsmýnda belirtilenlerden
   hiç birine sahip deðildir. Biz, baþarýmýmýzý her sürümde arttýrsak da, esneklik ve 
   geliþmiþ özellikler için yapýlanmýs durumdayýz . PostgreSQL'i MySQL ile karþýlaþtýran  
   þu web sitesine bakabilirsiniz: http://openacs.org/why-not-mysql.html
          
   Güvenilirlik
   DBMSlerin güvenilir olmasý gerketigi, yoksa degerleri olmayacagini düsünüyoruz
   Çok iyi test edilmis, dengeli çalýsan minimum sayýda hata içeren kod sunmaya çalýsýyoruz.
   Her bir sürüm en az 1 aylýk beta testlerinden geçirilmektedir. Sürüm geçmiþine bakarsanýz,
   üretime hazýr, dengeli ve kararlý kodlar sundugumuzu görebilirsiniz. Bu alanda, diger 
   veritabaný yaZýlýmlarýna üstünlügümüz olduguna inanmaktayýz

   Destek
   E-posta listemiz, olusan herhangi bir sorunu çözebilecek büyük sayýda kullanýcý
   ve gelistirici grubunu içerir. Sorununuz için, en az bir ticari veritabaný kadar
   rahat çözüm bulabilirsiniz. Gelistiricilere, kullanýcý grubuna, belgelere ve
   kaynak koda direk olarak erisebilme, PostgreSQL destegini, diger DBMSlere göre daha
   önemli kýlar. Gereksinimi olanlara, ticari destek verilebilir. (Destek için 1.6 bölümüne bakýnýz.)
          
   Fiyat
   Ticari ve ticari olmayan tüm kullanýmlarýnýz için PostgreSQL ücretsizdir. Kodumuzu, yukarýda belirtilen
   BSD-stili lisanstaki sýnýrlamalar hariç, ürününüzün içine ekleyebilirsiniz.
          
       1.15) PostgreSQL'e maddi açýdan nasýl destek olabilirim?
    
   PostgreSQL, 1996 yýlýndan beri 1.sýnýf altyapýya ashiptir. Bunun için, yýllar boyu çalýsýp bu altyapýyý
   olusturup yöneten Marc Fournier'e tesekkürler.

   Bir açýk kaynak kodlu proje için, kaliteli altyapý çok önemlidir. Bu altyapý, projenin
   kesilmesini önler ve projenin ilerlemesini hýzlandýrýr.
   
   Tabii ki bu altyapý ucuz degildir. ýslerin yürümesi için çeþitli yýlýk ve anlýk 
   harcamalarýmýz olmaktadýr. Eger siz ya da sirketinizin bu çabamýza bagýsta 
   bulunabilecek parasý varsa, lütfen http://www.pgsql.com/pg_goodies adresine 
   gidiniz ve bagýsta, hibede bulununuz.

   Web sayfasýnýn PostgreSQL, ýnc.' den bahsetmesine ragmen, "katkýda bulunanlar" 
   (contributors) maddesi sadece PostgreSQL projesini desteklemek içindir ve belirli bir 
   sirketin para kaynagý degildir. isterseniz, baglantý adresine bir çek gönderebilirsiniz.

   ____________________________________________________________________________
   
                      Kullanýcý/istemci Sorularý
                                      
   2.1) PostgreSQL icin ODBC sürücüleri var mý?
    
   iki tane ODBC sürücüsü bulunmaktadýr:  PsqlODBC ve OpenLink ODBC.
   
   PsqlODBC'i http://gborg.postgresql.org/project/psqlodbc/projdisplay.php adresinden 
   indirebilirsiniz.
  
  OpenLink ODBC http://www.openlinksw.com adresinden alýnabilir.Bu sürücü,
  kendi standart ODBC istemci yazýlýmý ile çalýstýðýndan, destekledikleri 
  her platformda (Win, Mac, Unix, VMS) PostgreSQL ODBC bulunmalidir.
   
  Ücretsiz sürümü olmakla beraber, ticari kalitede destek almak isteyenlere satmak isteyeceklerdir. 
  Sorularýnýzý lütfen postgres95@openlink.co.uk adresine gönderiniz.
   
        2.2) PostgreSQL'i web sayfalarýnda kullanabilmek için hangi araçlar bulunmaktadýr?

   http://www.webreview.com adresinde, arka planda veritabaný çalýstýran Web sayfalarý
   için giris seviyesinde bilgi bulunmaktadýr.
   
   Web ile bütünlesme için, PHP mükemmel bir arabirim sunar. http://www.php.net .
   
   Karmaþýk sorunlar için, çoðu kisi Perl arabirimini ve  CGI.pm  ya da mod_perl kullanýr.
   

       2.3) PostgreSQL'in grafik kullanýcý arabirimi var mýdýr? 
    
   Çeþitli grafik arabirimlerimiz bulunmaktadýr. Bunlarýn arasýnda, PgAccess (http://www.pgaccess.org),
   PgAdmin II (http://www.pgadmin.org, sadece Win32 için), RHDB Admin (http://sources.redhat.com/rhdb/ )
   ve Rekall (http://www.thekompany.com/products/rekall/) bulunmaktadýr. Ayrýca, PostgreSQL için web
   tabanlý bir arabirim olan PHPPgAdmin (  http://phppgadmin.sourceforge.net/ ) bulunmaktadýr.
   
   Daha ayrýntýlý liste için http://techdocs.postgresql.org/guides/GUITools adresine bakabilirsiniz.

       2.4) PostgreSQL ile iletiþimi kurabilmek için hangi dilleri kullanabilirim?

     * C (libpq)
     * Embedded C (ecpg)
     * Java (jdbc)
     * Python (PyGreSQL)
     * TCL (libpgtcl)

     Diðerleri için, http://gborg.postgresql.org adresindeki Drivers/Interfaces bölümüne 
     bakabilirsiniz.
     _________________________________________________________________
   
                       Yönetimsel Sorular
                                      
   3.1) PostgreSQL'i, /usr/local/pgsql dizininden baska dizinlere nasýl kurabilirim?
    
   configure betigini çalýstýrýrken, --prefix seçenegini veriniz.
   
       3.2) postmaster'i baslattýgýmda, a Bad System Call ya da core dumped mesajý 
	alýyorum. Neden?
    
   Bunun birçok nedeni olabilir. Ancak ilk kontrol edilmesi gereken sey, çekirdeginize
   System V uzantýlarýnýn kurulu olup olmadýgýný kontrol etmek olabilir. PostgreSQL 
   shared memory ve semaphores için çekirdek destegine gereksinim duyar.

       3.3) postmaster'i baslattýgýmda, a ýpcMemoryCreate hatasý alýyorum. Neden?
    
   Ya çekirdeginizde shared memory desteginiz düzgünce yapýlandýrýlmamýstýr, ya da 
   çekirdeginizdeki mevcut shared memory miktarýný büyütmeniz gerekecektir. Gereksinim
   duyacagýnýz miktar, mimarinize ve postmaster için ayarladýgýnýz tampon ile backend 
   islemi sayýsýna baglýdýr. Tüm sistemler için, tamponlar ve islemlerde öntanýmlý sayýlarla,
   ~ 1MB kadar yere gereksinmeniz olacaktir.PostgreSQL Administrator's Guide' a, shared memory 
   ve semaphorelar  hakkýndaki ayrýntýlý bilgi için bakabilirsiniz.

       3.4) postmaster'i baslattýgýmda, a ýpcSemaphoreCreate hatasý alýyorum. Neden?
    
   Eger hata, "ýpcSemaphoreCreate: semget failed (No space left on device)" ise, 
   çekirdeginiz yeterli semaphore ile yapýlandýrýlmamýs demektir. Postgres, her 
   bir potansiyel backend için bir semaphore gereksinmesi duyar. Geçici bir çözüm, 
   postmasterý backend islemleri için daha az miktarda sýnýrla baslatmak olabilir. 
   -N i varsaýlan deger olan 32'den küçük bir degerle baslatýnýz. Daha kalýcý bir 
    çözüm, çekirdeðinizin SEMMNS ve SEMMNI parametrelerini yükseltmek olacaktýr.
   
   Çalýþmayan semaphorelar aðýr veritabaný islemlerinde çökme yaratabilirler.

   Eger hata mesajýnýz baska birsey ise, çekirdeginizde semaphore destegini 
   yapýlandýrmamýs olabilirsiniz. Shared memory ve semaphorelar hakkýndaki daha 
   ayrýntýlý bilgi için PostgreSQL Administrator's Guide'a bakabilirsiniz.
   
       3.5) Diger bilgisayarlarýn benim PostgreSQL veritabaný sunucuma baglantýlarýný 
	nasýl kontrol edebilirim?
    
   Ön tanýmlý olarak, PostgreSQL sadece yerel makineden Unix domain sockets kullanarak 
   baglanýlmasýna izin verir. Diger makineler, postmaster'a -i etiketini geçirmezseniz 
   ve $PGDATA_pg_hba.conf dosyasýný düzenleyerek  host-based authentication'a 
   olanak vermezseniz, baglantý yapamayacaklardýr. 
   
       3.6) Veritabani motorunu daha iyi basarim icin nasil ayarlayabilirim?
  
   Indexler sorgularý hýzlandýrabilir. EXPLAIN komutu, PostgreSQL'in sorgunuzu nasýl
   yorumladýðýný ve hangi indexleri kullandigini görmenize izin verir.

   Eðer cok fazla INSERT islemi yapiyorsaniz, bunlarý büyük bir toplu islem dosyasi kullanýp
   COPY komutu ile veritabanina girmeyi deneyiniz. Bu, tekil ýNSERTlerden daha hýzlýdýr.
   ikinci olarak,  BEGýN WORK/COMMýT transaction blogu içinde olmayan  ifadeler kendi 
   transactionlarindaymis gibi düsünülür. Çoklu ifadeleri tek bir transaction bloðu içinde 
   yapabilirsiniz. Bu, transaction overheadini düþürecektir. Tek bir 
   transaction bloðu içinde  birden çok ifadeyi çalýþtýrmayý 
   deneyebilirsiniz. Bu, transaction overhead ini düþürür.
   
   Çeþitli ayarlama seçenekleri mevcuttur. fsync() iþlemini, postmaster'ý -o -F seçeneði ile 
   baþlatarak devre dýþý býrakabilirsiniz. Bu iþlem, fsync()'lerin her transactiondan sonra 
   diske flush etmesini engelleyecektir.

   Ayný zamanda, postmaster'i -B seçeneði ile baþlatýp, backend iþlemleri tarafýndan kullanýlan 
   shared memorf buffers sayýlarýný arttýrabilirsiniz. Eger bu parametreyi çok yüksek tutarsanýz, 
   çekirdeðinizin shared memory bölgesindeki limiti aþma olasýlýðýnýz yüzünden postmaster 
   baþlayamayabilir. Her bir tampon (buffer) 8K'dýr. Öntanýmlý sayý ise 64 tampondur.
   
   Ayný þekilde, backend'in -S seçeneðini geçici sýralamalar için backend süreçleri tarafýndan
   kullanýlacak hafýzayý arttýrmak amacýyla kullanabilirsiniz. -S seçeneði kilobayt cinsinden deðer alýr 
   ve ön tanýmlý deðeri 512'dir (512 K)
     
   Tablolardaki veriyi bir indekse eþlemek amacýyla gruplama için CLUSTER komutunu kullanabilirsiniz.
   Ayrýntýlý bilgi için CLUSTER komutunun yardým sayfasýna bakabilirsiniz.

       3.7) Hangi hata ayýklama özellikleri bulunmaktadýr?

   PostgreSQL, hata ayýklama amacýyla kullanýlabilecek durum bilgisi rapor eden çeþitli 
   özeliklere sahiptir.
 
   Öncelikle, configure betiðini --enable-cassert seçeneðiyle çalýþtýrýrsanýz, bir çok assert() backend calýþmasýný 
   gözlemler ve beklenmeyen bir durumda programý durdurur.

   Postmaster ve postgres çeþitli hata ayýklama seçeneklerine sahiptir. Öncelikle, 
   postmaster'i baþlattýðýnýzda, standart çýktýyý ve hatalarý bir log dosyasýna 
   yönlendirdiðinize emin olun:

    cd /usr/local/pgsql
    ./bin/postmaster >server.log 2>&1 &

    Bu iþlem PostgreSQL ana dizinine server.log dosyasý yerleþtirecektir. Bu dosya sunucunun 
    yaþadýðý sorunlar ya da hatalar hakkýnda yararlý bilgiler içerir. -d seçeneði, hata 
    ayýklama seviyesini belirten bir rakam ile kullanýlýr. Yüksek hata ayýklama 
    seviyelerinin büyük log dosyalarý oluþturacaðýný unutmayýnýz.
  
    Eðer postmaster çalýþmýyorsa, postgres backend'ini komut satýrýndan çalýþtýrabilir ve SQL ifadenizi
    direk olarak yazabilirsiniz. Bu sadece hata ayýklama amacýyla önerilir. Burada, noktalý virgülün deðil de
    yeni bir satýrýn sorguyu sonlandýrdýðýný unutmayýnýz. Eðer hata ayýklama sembolleri ile derlediyseniz,
    ne olduðunu görmek için bir hata ayýklayýcý kullanabilirsiniz. backend postmasterdan baþlatýlmadýðýndan,
    eþdeðer bir ortamda çalýþmamaktadýr ve locking/backend etkileþim sorunlarý artabilir.
   
    Eðer postmaster çalýþýyorsa, bir pencerede psql'i çalýþtýrýn ve psql tarafýndan kullanýlan postgres sürecinin süreç 
    numarasýný (PID) bulun. Postgres süreci ile iliþkilendirmek için bir hata ayýklarýcý kullanýn. Sorgularý psql 
    aracýlýðý ile çalýþtýrabilirsiniz. Eðer postgres baþlangýcýnda hata ayýklamak istiyorsanýz, PGOPTIONS="-W n" 
    seçeneðini ayarlayabilir ve psql'i baþlatabilirsiniz. Bu iþlem, baþlangýcýn n saniye kadar gecikmesini 
    saðlayacaktýr; böylece hata ayýklayýcýyý sürece iliþkilendirdikten sonra baþlangýç sürecinin devam etmesini 
    saðlayabilirsiniz.

    postgres programý hata ayýklama ve baþarým ölçümleri için -s, -A ve -t seçeneklerine sahiptir.
      
       3.8) Baglanmaya çalýsýken, neden "Sorry, too many clients" hatasýný alýyorum?
    
   Postmaster'in  eþzamanlý olarak baþlatabileceði backend süreçleri sýnýrlarýný 
   arttýrmanýz gerekmektedir.
   
   Ön tanýmlý deðer 32 süreçtir. Bunu, postmaster'i uygun -N deðeri ile ya da 
   postgresql.conf dosyasýný düzenleyerek yeniden baþlatmakla arttýrabilirsiniz.

   Eðer -N deðerini 32'den büyük yapacaksanýz, ayný zamanda -B deðerini de deðiþtirmeniz
   gerektiðini unutmayýn. -B -N'nin en az 2 katý kadar olmalýdýr; daha iyi baþarým için 
   bu sayýyý daha da arttýrmalýsýnýz. Yüksek sayýdaki backend süreçleri için, çeþitli çekirdek yapýlandýrma
   parametrelerini arttýrmanýz gerekecektir. Yapýlmasý gerekenler, SHMMAX, SEMMNS, SEMMNI, NPROC, MAXUPRC ve 
   açýlabilecek dosyalarýn maksimum sayýsý olan NFILE ve NINODE deðerlerini karýþtýrmaktýr. Bunun nedeni, PostgreSQL'in 
   izin verilen backend süreçlerinin sayýsý üzerinde bir sýnýrý olmasýdýr. Böylelikle sistem kaynaklarýnýn dýþýna 
   çýkýlmayacaktýr.

   PostgreSQL'in 6.5 sürümüne kadar, en fazla backend sayýsý 64 idi ve bunu deðiþtirmek için 
   include/storage/sinvaladt.h dosyasý içindeki MaxBAckendid sabitini deðiþtirdek sonra 
   yazýlýmý yeniden derlemek gerekiyordu.
   
   	3.9) pgsql_tmp dizinin içindeki dosyalar nelerdir?
    
   Sorgu çalýstýrýcý (query executer) tarafýndan yaratýlan geçici dosyalardýr. Örnegin,
   bir sýralama ORDER BY ile yapilacaksa ve sýralama backend'in -s parametresinin izin
   verdiginden daha fazla alana gereksinim duyuyorsa, ekstra veriyi tutmak için geçici
   dosyalar yaratýlýr.

   Geçici dosyalar, eger sýralama sýrasýnda backend göçmezse otomatik olarak silinecektir.
   Eger çalýsan durumda bir backendiniz yoksa, pg_tempNNN.NN dosyalarýný silmeniz güvenlidir..

   3.10) PostgreSQL sürümlerini yükselmek için neden bir dump/reload iþlemi gerçekleþtirmek zorundayým?

   PostgreSQL takýmý ara sürümlerde sadece küçük deðiþiklikler yapmaktadýr; bu yüzden 7.2 
   sürümünden 7.2.1'e yükseltmek dump/restore iþlemi gerekmemektedir. Ancak, esas sürümlerde 
   (örnek: 7.2'den 7.3'e) çoðunlukla sistem tablolarýnýn ve veri dosyalarýnýn iç yapýsý 
   deðiþtirilir. Bu deðiþiklikler çoðunlukla karmaþýktýr; dolayýsýyla veri dosyalarýnýn 
   geriye dönük uyumluluðu iþlemlerini yapmýyoruz. Dump iþlemi, veriyi genel biçimde 
   alacaðýndan yeniden yükleme esnasýnda veri, yeni iç biçime uygun þekilde 
   yerleþtirilecektir.

   Disk biçiminin deðiþmediði sürümlerde, pg_upgrade betiði güncellemenin bir dump/restore 
   gerektirmeden yapýlmasýný saðlayacaktýr. pg_upgrade betiðinin o sürüm için bulunup 
   bulunmadýðýný sürüm notlarý içinde bulabilirsiniz.

     _________________________________________________________________
   
			Ýþletimsel Sorular

                                      
       4.1) Binary cursor ve normal cursor arasindaki fark nedir?
    
   DECLARE yardým sayfasina bakiniz.
   
       4.2) Sorgunun sadece ilk birkaç satýrýný nasil SELECT edebilirim?
	    
   FETCH yardým sayfasina bakiniz, aya da  SELECT ... LIMIT.... kullanýnýz.
   
   The entire query may have to be evaluated, even if you only want the
   first few rows. Consider a query that has an ORDER BY. ýf there is an
   index that matches the ORDER BY, PostgreSQL may be able to evaluate
   only the first few records requested, or the entire query may have to
   be evaluated until the desired rows have been generated.
   
       4.3) psql'in içinde gördügüm tablolarin ya da diger seylerin listesini nasil alabilirim?
    
   pgsql/src/bin/psql/describe.c içindeki psql kaynak kodunu okuyabilirsiniz. Bu kod, 
   psql'in \ ile baslayan komutlarýnýn çýktýsýný olusturan SQL komutlarini içerir. Ayný 
   zamanda, psql'i -E seçeneði ile baþlatýp, verdiðiniz komutlarý çalýþtýrmak için yaptýðý 
   sorgularýn çýktýlarýný görebilirsiniz.

       4.4) Bir tablodan bir kolonu nasýl kaldýrabilirim?
    
   Bu özellik (ALTER TABLE DROP COLUMN)  7.3 sürümü ile gelmiþtir. Eski sürümlerde 
   aþaðýdakileri uygulamalýsýnýz: 

    BEGIN;
    LOCK TABLE old_table;
    SELECT ...  -- select all columns but the one you want to remove
    INTO TABLE new_table
    FROM old_table;
    DROP TABLE old_table;
    ALTER TABLE new_table RENAME TO old_table;
    COMMIT;

       4.5) Bir satýr, tablo ve veritabaný icin en fazla büyüklük nedir? 
  
    Sýnýrlar:   
 
    Veritabani icin en fazla büyüklük nedir?			Sýnýrsýz (4 TB'lýk veritabaný bulunmaktadýr)
    Bir tablo icin en fazla büyüklük nedir?			16 TB
    Bir satýr için en fazla büyüklük nedir?			1.6 TB
    Bir alan için en fazla büyüklük nedir?			1 GB
    Tabloda en fazla satýr sayýsý kaçtýr?			Sýnýrsýz
    Bir tabloda olabilecek en fazla kolon sayýsý kaçtýr? 	Kolon tiplerine baðlý olarak  250-1600 
    Bir tabloda olabilecek en fazla index sayýsý kaçtýr?	sýnýrsýz

   Tabii ki bunlar aslinda sýnýrsýz degildir. Burada belirtilen sýnýrlar, fiziksel 
   sýnýrlarýn haricindeki sýnýrlardýr. Boþ disk alaný, hafýza/takas alaný na baðlý 
   sýnýrlamalar vardýr. Baþarým, sýnýr deðerlere yaklastýkça, ya da deðerler cok büyük 
   olduðunda düþebilir.
   
   Bir tablo için büyüklük sýnýrý olan 16 TB, iþletim sisteminin büyük dosya desteði olup
   olmamasýndan baðýmsýzdýr. Büyük tablolar, 1 GB'lik dosyalarda saklandýðý için, dosya 
   sistemi sýnýrlarýnin bir önemi yoktur.
   
   Tablo ve kolon sayýsý büyüklükleri, ön tanýmlý blok büyüklüðü 32k ya çýkarýlarak 
   arttýrýlabilir.
   
      4.6) Tipik bir metin dosyasýndaki veriyi saklamak için ne kadar disk alaný gereklidir?
    
   Bir PostgreSQL veritabaný, veriyi "flat" metin dosyasýnda saklamak için gereken 
   alanýn 5 kat fazla disk alanýna gereksinim duyabilir.

   Her satýrýnda bir tamsayý ve metin (text) içeren, 100.000 satýrlýk bir dosya düþünün. 
   Her satýrýn ortalama 20 byte olduðunu farzedelim. Metin dosyasý 2.8 MB olacaktýr. Bu veriyi
   tutan PostgreSQL veritabaný yaklaþýk 6.4 MB yer kaplayacaktýr.

     36 byte: Her bir satýr baslýgý (yaklasik)
   + 24 byte: Bir tamsayý (int) alani ve bir metin (text) alaný 
   +  4 byte: Sayfada tuple a pointer
   ----------------------------------------
    64 byte -> kayýt basýna

   PostgreSQL'de data page büyüklüðü 8192 byte (8k)dir, dolayýsýyla:

   8192 byte -> page basýna
   -------------------------  =  Her bir veritabani page i baþýna 128 satýr (yaklaþýk)
     Satýr basýna 64 byte

   100000 veri satýrý
   --------------------  =  782 veritabaný sayfasý
       128 satýr

    782 veritabaný sayfasý * sayfa baþýna 8192 byte =  6,406,144 bytes (6.4 MB)

   Indexler cok fazla yere gereksinim duymazlar, ama indexlenmis veriyi tutacaklarýndan
   büyük olabilirler.
   
   NULL deðerler bitmapler içinde tutulur; dolayýsýyla çok az yer kaplarlar.

       4.7) Veritabanýnda hangi tablo ya da indexlerin tanýmlandýgýný nasil görebilirim?
    
    psql, bu tür bilgileri göstermek için, \ ile baþlayan bir çok komut sunmaktadýr. 
    \? komutu ile bu komutlarý görebilirsiniz. Ayrýca, bunlarý açýklayan ve pg_ ile baþlayan 
    çok sayýda sistem tablosu bulunmaktadýr. Ayný zamanda, psql -l ile tüm veritabanlarýný 
    listeyelebirsiniz.
   
   Ayrýca, pgsql/src/tutorial/syscat.source kodunu inceleyebilirsiniz. Bu dosya, veritabaný 
   sistem dosyalarindan bilgiyi almak için gereksinim duyulan  bir çok SELECTleri gösterir.

    4.8) Sorgularým cok yavaþ, ya da indexlerimi kullanmýyorlar. Neden? 

 Indexes are not automatically used by every query. Indexes are only used if the table is larger than a minimum size,
and the query selects only a small percentage of the rows in the table. This is because the random disk access caused
by an index scan can be slower than a straight read through the table, or sequential scan.

To determine if an index should be used, PostgreSQL must have statistics about the table. These statistics are
collected using VACUUM ANALYZE, or simply ANALYZE. Using statistics, the optimizer knows how many rows are in the
table, and can better determine if indexes should be used. Statistics are also valuable in determining optimal join
order and join methods. Statistics collection should be performed periodically as the contents of the table change.

Indexes are normally not used for ORDER BY or to perform joins. A sequential scan followed by an explicit sort is
usually faster than an index scan of a large table.
However, LIMIT combined with ORDER BY often will use an index because only a small portion of the table is returned.
In fact, though MAX() and MIN() don't use indexes, it is possible to retrieve such values using an index with ORDER
BY and LIMIT:

    SELECT col
    FROM tab
    ORDER BY col [ DESC ]
    LIMIT 1;

   Eðer optimizer'in sequential scan iþleminde hata yaptýðýný düþünüyorsanýz, SET enable_seqscan TO 'off' 'u kullanýnýz 
   ve index scan'in hala hýzlý olup olmadýðýný görmek için testler yapýnýz.

   LIKE ya da ~ gibi operatorler kullaniyorsanýz, indeksler sadece aþaðýdaki koþullarda kullanýlabilir:

    * Arama dizininin baþý, dizinin baþý ile baðlanmalýdýr. Yani, 
	  o LIKE sorgularý % ile baþlamamalýdýr.
	  o Düzenli ifade sorgularý ^ iþe baþlamamalýdýr.
    * Arama metni bir karakter sýnýfý ile baþlayamaz. Örnek: [a-e]
    * ILIKE ve ~* gibi  büyük/küçük harfe duyarsýz  aramalar indekslerden yararlanmazlar. Onun yerine, bölüm 4.12'de 
anlatýlan fonksiyonel indeksleri kullanabilirsiniz.
    * initdb sýrasýnda öntanýmlý C localei kullanýlmalýdýr.

 4.9) query-optimizer in sorgularýmý nasýl deðerlendirdiðini, iþleme soktuðunu nasýl görebilirim?
    
   EXPLAIN yardým sayfasýna bakýnýz.	
   
       4.10) R-tree index nedir?

   An R-tree index is used for indexing spatial data. A hash index can't handle range searches. A B-tree index only
handles range searches in a single dimension. R-trees can handle multi-dimensional data. For example, if an R-tree
index can be built on an attribute of type point, the system can more efficiently answer queries such as "select all
points within a bounding rectangle."

The canonical paper that describes the original R-tree design is:

Guttman, A. "R-trees: A Dynamic Index Structure for Spatial Searching." Proceedings of the 1984 ACM SIGMOD Int'l Conf
on Mgmt of Data, 45-57.

Bu paperi, Stonebraker'ýn "Readings in Database Systems" kitabýnda bulabilirsiniz.

Built-in R-trees can handle polygons and boxes. In theory, R-trees can be extended to handle higher number of
dimensions. In practice, extending R-trees requires a bit of work and we don't currently have any documentation on
how to do it.
    
       4.11) Genetic Query Optimizer nedir?
  
   GEQO modülü, Genetic Algorith(GA) kullanýlarak tablolar birleþtirildiðinde sorgu optimizasyonunu hýzlandýrýr. 
   It  allows the handling of large   join queries through nonexhaustive search.
   
    4.12) Düzenli ifade (Regular Expression) aramalarýný ve büyük/küçük harfe duyarsýz aramalarý nasil yapabilirim?
	Bu büyük(küçük harfe duyarlý aramalar için indeksi nasil kullanabilirim?
    
   ~ operatörü düzenli ifade eþleþmesi ve ~*  büyük/küçük harfe duyarsýz düzenli ifade eþleþmesi yapar.
   Büyük/küçük harfe duyarlý olan LIKE'in  büyük/küçük harfe duyarsýz olan biçini ILIKE'týr ve PostgreSQL
   7.1 sürümü ile birlikte gelmiþtir.
     
   Büyük-küçük harfe duyarsýz eþitlik karþýlaþtýrmalarý aþaðýdaki gibi ifade edilir:

    SELECT *
    FROM tab
    WHERE lower(col) = 'abc'

   Bu standart bir indeks yaratmayacaktýr. Ancak eðer fonksiyonel bir indeks yaratýrsanýz; o kullanýlacaktýr:

    CREATE INDEX tabindex on tab (lower(col));

    4.13)  Bir sorguda, bir alanin "NULL" oldugunu nasil ortaya çýkarabilirim?
    
   Kolonu, IS NULL ve IS NOT NULL ile test edebilirsiniz.
   
       4.14) Çesitli karakter tipleri arasýndaki farklar nelerdir?
    
Veri Tipi	Ýç Adý              Not
--------------------------------------------------
VARCHAR(n)      varchar         boyut en büyük uzunluðu verir; sadece verilen kadar veri tutulur.
CHAR(n)         bpchar          belirtilen uzunlupa kadar sonuna  boþluk eklenir.
TEXT            text            uzunlukta herhangi bir üst sýnýr yoktur. 
BYTEA           bytea           variable-length byte array (null-byte safe)
"char"          char            bir karakter 

Ýç adlarý (internal name) sistem kataloglarýný ve bazý hata meajlarýný incelerken göreceksiniz.
  
   Ýlk dört veri tipi "varlena" tipidir (yani, diskteki ilk 4 bayt uzunluktur; devamý da veridir.) Dolayýsýyla,
   Böylece, kullanýlan gerçek alan, belirtilen alandan biraz daha büyüktür. Ancak, bu veri tipleri, sýkýþtýrýlmaya tabi 
   tutulabilir; dolayýsýyla disk alaný beklenilenden kücük olabilir. VARCHAR(n) büyüklüðü artabilen ama en büyük 
   uzunluðu sýnýrlý oan verileri saklamak için en uygun yöntemdir. TEXT, 1 GB büyüklüðe kadar olan verileri tutmak için 
   kullanýlýr.

   CHAR(n), ayný uzunluktaki dizilerin saklanmasý için kullanýmýr. CHAR(n) belirtilen uzunluða kadar boþluk ile 
   doldurur; ancak VARCHAR(n) sadece verilen karakterleri saklar.BYTEA binary veri saklamak içindir; ayrýca "NULL" bayt 
   içeren deðerleri de saklar. Burada anlatýlan üç veri tipi de benzer baþarým karakteristiklere sahiptir.
   
       4.15.1) Nasil serial/otomatik artan(auto-incrementing) bir alan yaratabilirim?
    
     PostgreSQL'de SERIAL veri tipi vardýr. Bu veri tipi bir sequence ve kolon üzerinde bir indeks yaratýr.

    Örnek, aþaðýdaki sorgu:

    CREATE TABLE person (
        id   SERýAL,
        name TEXT
    );

    buna çevrilir:

    CREATE SEQUENCE person_id_seq;
    CREATE TABLE person (
        id   ýNT4 NOT NULL DEFAULT nextval('person_id_seq'),
        name TEXT
    );
    CREATE UNIQUE ýNDEX person_id_key ON person ( id );

  Sequenceler hakkýnda daha fazla bilgi için create_sequence yardým sayfasýna bakabilirsiniz. Her satýrýn OID alanýný 
  tekil bir sayý olarak alabilirsiniz. Ancak, veritabanýnýzýn dump'ýný alýp yeniden yüklerseniz, OID deðerlerini
  koruyabilmek için pg_dump'ýn -o parametresini ya da "COPY WITH OIDS" seçeneðini kullanmanýz gerekecektir.
   
   4.15.2) SERIAL giriþinin degerini nasil alabilirim?
    
One approach is to retrieve the next SERIAL value from the sequence object with the nextval() function before
inserting and then insert it explicitly. Using the example table in 4.15.1, an example in a pseudo-language would
look like this:

    new_id = execute("SELECT nextval('person_id_seq')");
    execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");

You would then also have the new value stored in new_id for use in other queries (e.g., as a foreign key to the
person table). Note that the name of the automatically created SEQUENCE object will be named
<table>_<serialcolumn>_seq, where table and serialcolumn are the names of your table and your SERIAL column,
respectively.

 Alternatif olarak, atanmýþ SERIAL deðerini, deðer girildikten sonra currval() fonksiyonu ile alabilirsiniz:

    execute("INSERT INTO person (name) VALUES ('Blaise Pascal')");
    new_id = execute("SELECT currval('person_id_seq')");

  Son olarak, ön tanýmlý deðeri bulmak için INSERT ifadesinden dönen OID deðerini kullanabilirsiniz; ancak bu
  en az taþýnabilir çözüm olacaktýr. Perl'de, Edmund Mergl'in DBD:Pg mödülü ile birlikte DBI kullanarak, oid deðeri
  $sth->execute() çalýþtýrýldýktan sonra $sth->(pg_oid_status) ile alýnabilir.

       4.15.3) currval() ve  nextval() diger kullanicilara sorun yaratmaz mý?
    
   Hayýr. curval(), tüm kullanýcýlar degil, backend tarafýndan atanan geçerli  
   degeri döndürür.
   
      4.15.4) Neden sequence sayýlarýn transaction iþleminin iptalinden sonra yeniden kullanýlýyor? Neden sequence/SERIAL 
		kolonumdaki sayýlarda atlamalar oluyor?

   Uyumluluðu arttýrmak için, sequence deðerleri çalýþan transactionlara gerektiði þekilde aktarýlýr ve transaction 
   bitene kadar o deðer kilitlenmez. Bu, iptal edilen transaction iþlemleri nedeniyle boþluklara neden olur. 

    4.16) OID nedir? TID nedir?
    
   OýDs are PostgreSQL's answer to unique row ids. Every row that is
   created in PostgreSQL gets a unique OýD. All OýDs generated during
   initdb are less than 16384 (from backend/access/transam.h). All
   user-created OýDs are equal to or greater than this. By default, all
   these OýDs are unique not only within a table or database, but unique
   within the entire PostgreSQL installation.
   
   PostgreSQL uses OýDs in its internal system tables to link rows
   between tables. These OýDs can be used to identify specific user rows
   and used in joins. ýt is recommended you use column type OýD to store
   OýD values. You can create an index on the OýD field for faster
   access.
   
   OýDs are assigned to all new rows from a central area that is used by
   all databases. ýf you want to change the OýD to something else, or if
   you want to make a copy of the table, with the original OýDs, there is
   no reason you can't do it:
        CREATE TABLE new_table(old_oid oid, mycol int);
        SELECT old_oid, mycol ýNTO new FROM old;
        COPY new TO '/tmp/pgtable';
        DELETE FROM new;
        COPY new WýTH OýDS FROM '/tmp/pgtable';

   OýDs are stored as 4-byte integers, and will overflow at 4 billion. No
   one has reported this ever happening, and we plan to have the limit
   removed before anyone does.
   
   TIDs are used to identify specific physical rows with block and offset
   values. TýDs change after rows are modified or reloaded. They are used
   by index entries to point to physical rows.
   
       4.17) PostgreSQL'de kullanýlan bazý terimlerin anlamlarý nelerdir?
    
   Kaynak kodun bir kýsmý ve eski belgeler, daha genis kullaným alaný olan terimleri
   kullanýrlar. Bunlarýn bazýlarý:

     * table, relation, class
     * row, record, tuple
     * column, field, attribute
     * retrieve, select
     * replace, update
     * append, insert
     * OID, serial value
     * portal, cursor
     * range variable, table name, table alias

  Genel veritabaný terimleri,

    http://hea-www.harvard.edu/MST/simul/software/docs/pkgs/pgsql/glossary/glossary.html
   adresinde bulunabilir.
   
       4.18) Neden  "ERROR: Memory exhausted in AllocSetAlloc()"? hatasýný alýyorum?
    
   Sisteminizde sanal belleginizi tüketmis olabilirsiniz, ya da çekirdeginiz
   belli kaynaklar icin düþük bir sýnýra sahip olabilir. postmasteri baslatmadan önce 
   asagidakileri deneyebilirsiniz:

    ulimit -d 262144
    limit datasize 256m

   Kabuðunuza baðlý olarak, bunlardan sadece biri olumlu sonuç verecektir, ama
   bu iþlem veri segment sýnýrýnýzý arttýracak, ve belki de sorgunuzun tamamlanmasýný
   saglayacaktýr. Bu komut, varolan isleme (current process) ve komut çalýstýrýldýktan
   sonraki tüm alt islemlere uygulanir. Eger SQL istemcinizle, backendin çok fazla veri 
   döndürmesi nedeniyle bir sorun yasýyorsanýz, bunu istemciyi baslatmadan önce deneyiniz.
   
       4.19) Hangi PostgreSQL sürümünü çalýstýrdýgýmý nasil görebilirim?
    
   psql arabiriminde, select version(); yazýnýz.
   
   4.20) Neden large-object islemlerim, "invalid large obj descriptor"? hatasýný veriyor?

   Large object islemlerinizin uclarina, yani  lo_open ... lo_close komutlarýnýn çevresine, 
    BEGIN WORK ve COMMIT koymanýz gerekmektedir;

   Eger ODBC gibi bir istemci arabirimi kullanýyorsanýz, auto-commit'i kapatmanýz gerekebilir.
   
   4.21) Su andaki zamaný öntanýmlý deger olarak kabul eden How do ý create a column that will default to the current time?
    
   Alttakini kullanabilirsiniz:

   CURRENT_TIMESTAMP:
	CREATE TABLE test (x int, modtime timestamp DEFAULT CURRENT_TIMESTAMP );

   4.22) Neden IN kullanan subquerylerim çok yavas?
    
   Currently, we join subqueries to outer queries by sequentially scanning the result of the subquery for 
   each row of the outer query. IN' i EXISTS ile deðiþtirerek bir çözüme ulaþýlabilir.

SELECT *
    FROM tab
    WHERE col1 ýN (SELECT col2 FROM TAB2)

   to:
SELECT *
    FROM tab
    WHERE EXýSTS (SELECT col2 FROM TAB2 WHERE col1 = col2)

   Bu sýnýrlamayý ilerdeki sürümlerimizde düzeltmeyi planlamaktayýz.
   
       4.23) Outer join islemini nasil yapabilirim?
    
   PostgreSQL outer joins islemlerini SQL standartlarýný kullanarak gerçeklestirmektedir.
   Asagida 2 örnek bulunmaktadýr:

    SELECT *
    FROM t1 LEFT OUTER JOýN t2 ON (t1.col = t2.col);

   ya da 

    SELECT *
    FROM t1 LEFT OUTER JOýN t2 USýNG (col);

   Bu özdes sorgular t1.col ' i  t2.col'ye join ederler ve ayný zamanda t1'deki unjoined satýrlarý 
   (t2'de eslenmenis olanlarla) döndürürler. RýGHT JOýN t2'nin unjoined satýrlarýný ekleyecektir.
   Bir FULL join, eþleþmiþ btün satýrlarý ve t1 ile t2'den tüm baðlanmamýþ (unjoined) satýrlarý alýr.
   OUTER sözcüðü seçimseldir ve LEFT, RIGHT ve FULL join iþlemlerinde olduðu kabul edilir. Sýradan 
   join iþlemleri INNER join olarak adlandýrýlýr.

   Önceki sürümlerde, OUTER JOINler UNION ve NOT IN kullanýlarak simüle edilebiliyordu. Örneðin, tab1 
   ve tab2'yi birleþtirirken, aþaðýdaki sorgu iki tablonun dýþtan baðlanmasýný saðlar:

    SELECT tab1.col1, tab2.col2
    FROM tab1, tab2
    WHERE tab1.col1 = tab2.col1
    UNION ALL
    SELECT tab1.col1, NULL
    FROM tab1
    WHERE tab1.col1 NOT ýN (SELECT tab2.col1 FROM tab2)
    ORDER BY col1

       4.24) Ayni andan birden fazla veritabaninda nasil islem yapabilirim?
    
   Mevcut veritabanýnýz dýsýndaki baska bir veritabanýnýzý sorgulamanýzýn bir yolu bulunmamaktadýr.
   bunun nedeni, PostgreSQL'in veritabanýna özel sistem kataloglarý yüklemesidir. Bu nedenle, 
   cross-database bir sorgunun nasil davranacagýný kestirmek zordur.
   
   contrib/dblink fonksiyon çaðrýlarýný kullanarak cross-database sorgulara izin verid. Tabii ki, 
   bir istemci degisik veritabanlarýna ayný anda erisim saglayabilir ve bilgiyi bu sekilde
   birlestirebilir.

   4.25) Bir fonksiyondan nasýl çoklu satýr ya da kolon döndürebilirim?

   7.3 sürümünde, bir fonksiyondan kolaylýkla çoklu satýr ya da sütun döndürebilirsiniz.

	http://techdocs.postgresql.org/guides/SetReturningFunctions.

   4.26) Neden Pl/PgSQL fonksiyonlarý içinden güvenli bir þekilde tablo yaratma/kaldýrma iþlemlerini yapamýyoruz?

   PL/PgSQL fonksiyon içerikleri cacheler. Bunun istenmeyen bir tarafý, eðer bir PL/PgSQL fonksiyonu geçici bir
   tabloya eriþiyorsa ve bu tablo ileride kaldýrýlýp yeniden oluþturulduktan sonra fonksiyon yeniden çaðrýlýrsa,
   fonksiyon çalýþmayacaktýr; çünkü cachelenmiþ fonksiyon hala eski geçici tabloyu gösteriyor olacaktýr. Çözüm,
   geçici tablo eriþimleri için PL/PgSQL'de EXECUTE kullanmaktýr. Bu, sorgunun her seferinde yeniden iþlenmesini
   saðlayacaktýr.

   4.27) Hangi replikasyon seçenekleri bulunmaktadýr?

   Çeþitli master/slave replikasyon seçenekleri bulunmaktadýr. Bunlar master veritabanýnýn veritabaný deðiþikliklerini 
   yaparken, slave sunucunun sadece veritabanýnda okuma yapmasýna izin verir. 
   http://gborg.PostgreSQL.org/genpage?replication_research sayfasýnýn altýnda bunlarýn listesini bulabilirsiniz.
   http://gborg.PostgreSQL.org/project/pgreplication/projdisplay.php adresinde, çoklu-master replikasyon çözümü 
   üzerinde çalýþýlýyor.

   4.28) Hangi þifreleme seçenekleri bulunmaktadýr?

    * contrib/pgcrypto SQL sorgularýnda kullanýlabilmesi için þifreleme fonksiyonlarý içermektedir.
    * Ýstemciden sunucuya iletiþimi þifrelemenin tek yolu, pg_hba.conf içinde hostssl kullanmaktýr.
    * Veritabaný kullanýcý adý ve þifreleri 7.3 sürümü ile birlikte otomatik olarak þifrelenirler. Önceki 
     sürümlerde, postgresql.conf içindeki PASSWORD_ENCRYPTION seçeneðini aktif hale getirmeniz gerekmektedir.
    * Sunucunun kendisini þifreli dosya sistemi üzerinde çalýþtýrabilirsiniz.

     _________________________________________________________________
   
    		PostgreSQL Özelliklerini Geniþletmek

    5.1)  Kullanici-tanimli bir fonksiyon yazdim. psql'de çalistirdigim zaman neden core dump ediyor?
    
   Sorunun nedeni birden fazla sey olabilir. Kullanici-tanimli fonksiyonunuzu stand-alone bir programda
   calistirmayi deneyiniz.
   
    5.2) PostgreSQL'e nasil yeni tipler/fonksiyonlar ekleyeiblirim?
    
   Çalýsmalarýnýzý pgsql-hackers e-posta listesine gönderiniz. Kodunuz incelendikten sonra
   /contrib dizinine konacaktýr.
   
    5.3) Bir tuple dondürmek icin bir C fonksiyonunu nasil yazarým?
    
     PostgreSQL 7.3 sürümü ile birlikte, C, PL/PgSQL ve SQL kullanýlarak tablo-döndüren 
     fonksiyonlar tamamen desteklenmektedir. Ayrýntýlý bilgi için "Programmer's Guide" a 
    bakabilrisiniz. Bir örneði contrib/tablefunc içinde bulabilirsiniz.

    5.4) Bir kaynak dosyasýnda deðiþiklik yaptým. Yeniden derlememe raðmen deðiþiklik 
geçerli olmuyor. Neden?
    
   Makefile'lar include dosyalarý için tam bir baðýmlýlýk içermezler. 
   Öncelikle make clean, ardýndan da baska bir make iþlemi yapmanýz gerekir.
   GCC kullanýyorsaniz, configure betiðinin --enable-depend seçeneðini, derleyicinin
   baðýmlýlýklarý otomatik olarak hesaplamasý için kullanabilirsiniz. 

