		PostgreSQL için Sýkça Sorulan Sorular (SSS)
                                       
   Son güncelleme : 23 Þubat 2004  Pazartesi - 13:34:26

   Bruce Momjian (pgman@candle.pha.pa.us)
   Çeviren : Devrim GÜNDÜZ (devrim@gunduz.org), Nicolai Tufar (ntufar@yahoo.com), Volkan YAZICI (vyazici@phreaker.net)
   
   Bu belgenin en güncel hali, http://www.gunduz.org/seminer/pg/FAQ_turkish.html ve 
   http://www.PostgreSQL.org/docs/faq-turkish.html 
   adreslerinde gorülebilir.
   
   Platforma özel sorularýnýz, 
   http://www.PostgreSQL.org/users-lounge/docs/faq.html adresinde yanýtlanýr.
     _________________________________________________________________
   
                             Genel Sorular
                                      
   1.1) PostgreSQL nedir? Nasýl okunur?
   1.2) PostgreSQL' in haklarý nedir?
   1.3) PostgreSQL, hangi Unix platformlarýnda çalýsýr?
   1.4) Hangi Unix olmayan uyarlamalarý bulunmaktadýr?
   1.5) PostgreSQL'i nereden indirebilirim?
   1.6) Desteði nereden alabilirim?
   1.7) En son sürümü nedir?
   1.8) Hangi belgelere ulasabilirim?
   1.9) Bilinen hatalar ya da eksik özelliklere nereden ulasabilirim?
   1.10) Nasýl SQL ögrenebilirim?
   1.11) PostgreSQL 2000 yýlýna uyumlu mudur?
   1.12) Geliþtirme takýmýna nasýl katýlabilirim?
   1.13) Bir hata raporunu nasýl gönderebilirim?
   1.14) PostgreSQL, diger DBMS'lerle nasýl karþýlaþtýrýlabilir?
   1.15) PostgreSQL'e maddi açýdan nasýl destek olabilirim?
   
                      Kullanýcý/istemci Sorularý
                                      
   2.1) PostgreSQL icin ODBC sürücüleri var mý?
   2.2) PostgreSQL'i web sayfalarýnda kullanabilmek için hangi araçlar bulunmaktadýr?
   2.3) PostgreSQL'in grafik kullanýcý arabirimi var mýdýr? 
        Report generator var mýdýr? Gömülü sorgu dili arabirimi var mýdýr?
   2.4) PostgreSQL ile iletiþimi kurabilmek için hangi dilleri kullanabilirim?
   
                   Yönetimsel Sorular
                                      

   3.1) PostgreSQL'i, /usr/local/pgsql dizininden baþka dizinlere nasýl kurabilirim?
   3.2) Postmaster'i baslattýgýmda, Bad System Call ya da core dumped mesajý 
	alýyorum. Neden?
   3.3) Postmaster'i baþlattýðýmda, IpcMemoryCreate hatasý alýyorum. Neden?
   3.4) Postmaster'i baþlattýðýmda, IpcSemaphoreCreate hatasý alýyorum. Neden?
   3.5) Diðer bilgisayarlarýn benim PostgreSQL veritabaný sunucuma baðlantýlarýný nasýl 
	kontrol edebilirim?
   3.6) Veritabaný motorunu daha iyi baþarým icin nasýl ayarlayabilirim?
   3.7) Hangi hata ayýklama özellikleri bulunmaktadýr?
   3.8) Baðlanmaya çalýþýrken, neden "Sorry, too many clients" hatasýný alýyorum?
   3.9) pgsql_tmp dizininin içindeki dosyalar nelerdir?
   3.10) PostgreSQL sürümlerini yükselmek için neden bir dump/reload iþlemi gerçekleþtirmek 
	zorundayým?

                        Ýþletimsel Sorular
                                      
   4.1) Binary cursor ve normal cursor arasýndaki fark nedir?
   4.2) Sorgunun sadece ilk birkaç satýrýný nasýl SELECT edebilirim?
   4.3) psql'in içinde gördüðüm tablolarýn ya da diðer þeylerin listesini nasýl alabilirim?
   4.4) Bir tablodan bir kolonu nasýl kaldýrabilirim?
   4.5) Bir satýr, tablo ve veritabaný icin en fazla büyüklük nedir? 
   4.6) Tipik bir metin dosyasýndaki veriyi saklamak için ne kadar disk alaný gereklidir?
   4.7) Veritabanýnda hangi tablo ya da indexlerin tanýmlandýgýný nasýl görebilirim?
   4.8) Sorgularým cok yavaþ, ya da indexlerimi kullanmýyorlar. Neden?
   4.9) Query-optimizer in sorgularýmý nasýl deðerlendirdigini, iþleme soktuðunu nasýl görebilirim?
   4.10) R-tree index nedir?
   4.11) Genetic Query Optimizer nedir?
   4.12) Düzenli ifade (Regular Expression) aramalarýný ve büyük/küçük harfe duyarsýz aramalarý nasýl yapabilirim?
	Bu büyük(küçük harfe duyarlý aramalar için indeksi nasýl kullanabilirim?

   4.13) Bir sorguda, bir alanýn "NULL" olduðunu nasýl ortaya çýkarabilirim?
   4.14) Çesitli karakter tipleri arasýndaki farklar nelerdir?
   4.15.1) Nasýl serial/otomatik artan(auto-incrementing) bir alan yaratabilirim?
   4.15.2) SERIAL giriþinin deðerini nasýl alabilirim?
   4.15.3) currval() ve  nextval() diðer kullanýcýlara sorun yaratmaz mý?
   4.15.4) Neden sequence sayýlarýn transaction iþleminin iptalinden sonra yeniden kullanýlýyor? Neden sequence/SERIAL 
	kolonumdaki sayýlarda atlamalar oluyor?
   4.16) OID nedir? TID nedir?
   4.17) PostgreSQL' de kullanýlan bazý terimlerin anlamlarý nelerdir?
   4.18) Neden  "ERROR: Memory exhausted in AllocSetAlloc()"? hatasýný alýyorum?
   4.19) Hangi PostgreSQL sürümünü çalýstýrdýðýmý nasýl görebilirim?
   4.20) Neden large-object iþlemlerim, "invalid large obj descriptor"? hatasýný veriyor?
   4.21) Þu andaki zamaný öntanýmlý deðer olarak kabul eden kolonu nasýl yaratýrým?
   4.22) Neden IN kullanan subquerylerim çok yavaþ?
   4.23) Outer join iþlemini nasýl yapabilirim?
   4.24) Ayný anda birden fazla veritabanýnda nasýl iþlem yapabilirim?
   4.25) Bir fonksiyondan nasýl çoklu satýr ya da kolon döndürebilirim?
   4.26) Neden PL/pgSQL fonksiyonlarý içinden güvenli bir þekilde tablo yaratma/kaldýrma iþlemlerini yapamýyoruz?
   4.27) Hangi replikasyon seçenekleri bulunmaktadýr?
   4.28) Hangi þifreleme seçenekleri bulunmaktadýr?
	
	PostgreSQL Özelliklerini Geniþletmek
                                      
   5.1) Kullanýcý-tanýmlý bir fonksiyon yazdým. psql'de çalýþtýrdýðým zaman neden 
	core dump ediyor?
   5.2) PostgreSQL'e nasýl yeni veri tipleri/fonksiyonlar ekleyebilirim?
   5.3) Bir tuple döndürmek için bir C fonksiyonunu nasýl yazarým?
   5.4) Bir kaynak dosyasýnda deðisiklik yaptým. Yeniden derlememe raðmen 
	deðiþiklik geçerli olmuyor. Neden?
     _________________________________________________________________
   
                             Genel sorular
                                      
    1.1) PostgreSQL nedir?
    
   PostgreSQL, Post-Gres-Q-L olarak okunur.
   
   PostgreSQL, yeni-nesil VTYS arastýrma prototipi olan POSTGRES veritabaný 
   yönetim sisteminin geliþtirilmesidir. POSTGRES' in zengin veri 
   tiplerini ve güçlü veri modelini tutarken, SQL'in geliþtirilmis alt kümesi 
   olan PostQuel dilini kullanýr. PostgreSQL ücretsizdir ve kaynak kodu açýk daðýtýlýr.

   PostgreSQL, PostgreSQL gelistirme listesine üye olan bir ýnternet gelistirici
   takýmý tarafýndan geliþtirilir. Þu andaki koordinatör, Marc G. Fournier 
   (scrappy@PostgreSQL.org). (Bu takýma nasýl katýlacagýnýzý ögrenmek için  
   1.6 numaralý maddeyi okuyunuz.) Bu takým, tüm PostgreSQL geliþiminden sorumludur.

   PostgreSQL 1.01 sürümünün yazarlarý Andrew Yu ve Jolly Chen idi. Bunlarýn dýsýnda bir kaç kisi de uyarlama,
   hata ayýklama ve kodun gelistirilmesi için çalýsmýstý. PostgreSQL'in türedigi orijinal Postgres kodu, 
   lisans, lisansüstü ve akademisyenler tarafindan, Professor Michael Stonebraker ) University of
   California, Berkeley) koordinatörlügünde yazýlmýstýr.
   
   Berkley'deki yazýlýmým adý Postgres idi. SQL uyumlulugu 1995'te eklenince, adý Postgres 95
   oldu. 1996 yýlýnýn sonlarýnda adý PostgreSQL olarak degistirildi.
   
       1.2) PostgreSQL'in haklarý nedir?
       
   PostgreSQL Data Base Management System
   
   Portions copyright (c) 1996-2002, PostgreSQL Global Development Group
   Portions Copyright (c) 1994-6 Regents of the University of California
   
   Permission to use, copy, modify, and distribute this software and its
   documentation for any purpose, without fee, and without a written
   agreement is hereby granted, provided that the above copyright notice
   and this paragraph and the following two paragraphs appear in all
   copies.
   
   IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
   FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
   INCLUDING LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND
   ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN
   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   
   THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
   INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
   PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
   CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
   UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
   
   Üstteki metin klasik açýk-kod lisansý olan BSD lisansýdýr. Kaynak kodun nasýl 
   kullanýlabileceðine dair sýnýrlamalarý yoktur. Bu lisansi seviyoruz ve deðiþtirme 
   niyetimiz bulunmamaktadýr.
   
       1.3) PostgreSQL, hangi Unix platforlarýnda çalýsýr?
    
   Genel olarak, modern bir Unix-uyumlu platform PostgreSQL'i çalýstýracaktýr.
   Ayrýntýlý bilgi için kurulum belgelerine bakabilirsiniz
   
       1.4) Hangi Unix olmayan uyarlamalarý bulunmaktadýr?
    
   Ýstemci
   
   libpq C kütüphanesini, psql ve diger arabirimleri ve binary dosyalarý, MS
   Windows ortamlarýnda çalýsmasý için derlemeniz mümkündür. Bu örnekte  istemcide
   MS Windows çalýsýyor ve desteklenen Unix platformlarýndan birinde çalýsan PostgreSQL
   sunucuna TCP/IP ile baglanmaktadýr. Daðýtým içindeki win32.mak dosyasý ile,
   Win32 libpg kütüphanesi ve psql yaratabilirsiniz. PostgreSQL ayný zamanda ODBC
   istemcileri ile haberlesebilmektedir.

   Sunucu

   Veritabaný sunucusu Cygwin kullanarak Windows NT, 2K ya da XP üzerinde çalýþtýrýlabilir.
   Daðýtým içindeki pgsql/doc/FAQ_MSWýN dosyasýný ya da web sitemizdeki MS Windows FAQ'u
   inceleyebilirsiniz. 
	
   Doðal Windows NT/2000/XP portu için þu anda çalýþmalar devam etmektedir. Windows sürümü  
   hakkýnda güncel bilgi için, http://techdocs.postgresql.org/guides/Windows adresini 
   ziyaret edebilirsiniz.
 	
   Ayrýca, http://forge.novell.com adresinde Novell Netware 6 portu bulunmaktadýr.  

       1.5) PostgreSQL'i nereden indirebilirim?
    
   PostgreSQL için ana anonim ftp sitesi ftp://ftp.PostgreSQL.org/pub ' dur.
   Yansýlar için, ana web sayfamýza bakabilirsiniz.
   
   1.6) Desteði nereden alabilirim?
    
   Ana e-posta listesi : pgsql-general@PostgreSQL.org. PostgreSQL konusundaki tartýþmalara
   açýktýr. Üye olmak için, asaðýdaki satýrlarý e-postanýzýn gövde kýsmýna (konu kýsmýna deðil)
   yazýp, pgsql-general-request@PostgreSQL.org adresine gönderin:

    subscribe
    end

   Ayný zamanda, bir digest listesi bulunmaktadýr. Bu listeye üye olmak için, 
    pgsql-general-digest-request@PostgreSQL.org adresine, body kýsmýnda
   
    subscribe
    end

   yazan bir e-posta atmanýz yeterli olacaktýr.

   Digest postalar, ana liste 30k civarýnda e-postaya ulastýðýnda üyelere gönderilmektedir.

   Buglar için bir e-posta listesi bulunmaktadýr. Bu listeye üye olmak için,
   pgsql-bugs-request@PostgreSQL.org adresine, body kýsmýnda

    subscribe
    end

    yazan bir e-posta atmanýz yeterli olacaktýr.

   Ayný zamanda, geliþtiriciler için tartýþma listesi bulunmaktadýr. Bu listeye üye olmak
   için,  pgsql-hackers-request@PostgreSQL.org adresine,  gövde kýsmýnda

    subscribe
    end

   yazan bir e-posta atmanýz yeterli olacaktýr.

   Bunlarýn dýþýndaki e-posta listelerine ve PostgreSQL hakkýnda bilgiye, PostgreSQL WWW 
   ana sayfasýndan ulaþabilirsiniz:
   
     http://www.PostgreSQL.org

   Ayný zamanda, EFNet ve OpenProjects üzerinde, #PostgreSQL adlý bir IRC kanalý bulunmaktadýr. Bunun için,
    irc -c '#PostgreSQL' "$USER" irc.phoenix.net Unix komutunu kullanabilirsiniz.
   
   Ticari destek veren firmalarýn listesine,

   http://www.postgresql.org/users-lounge/commercial-support.html
 
   adresinden ulasabilirsiniz.
   
       1.7) En son sürümü nedir?
    
   PostgreSQL'in son sürümü 7.3.3'tür. 

   Her 4 ayda major release çýkarýlmasý planlanmaktadýr.
   
       1.8) Hangi belgelere ulasabilirim?
    
   Daðýtýmýn icinde, kitapciklar, kitapcik sayfalari ve bazi küçük örnekler verilmektedir.
   /doc dizinine bakýnýz. Ayrica, bu el kitapçýklarýný online olarak
   http://www.PostgreSQL.org/docs/ adresinden inceleyebilirsiniz. 

   http://www.PostgreSQL.org/docs/awbook.html ve http://www.commandprompt.com/ppbook 
   adreslerinde PostgreSQL kitaplarý bulunmaktadýr. PostgreSQL kitablarýnýn listesine, 
   http://www.ca.PostgreSQL.org/books/ adresinden ulaþaiblirsiniz. Ayrýca, PostgreSQL 
   konusundaki teknik makalelere de http://techdocs.PostgreSQL.org/ adresinden 
   ulaþabilirsiniz.

   psql'in, \d ile baslayan veri tipler, operatorler, fonksiyonlar, aggregateler,vb. ile 
   ilgili güzel komutlarý vardýr.
   
   Web sitemiz daha fazla belgeyi içermektedir.
   
       1.9) Bilinen hatalar ya da eksik özelliklere nereden ulasabilirim?
    
   PostgreSQL SQL-92 uyumlugugu icindedir, standartlardan fazla da özellikleri
   bulunmaktadýr. Bilinen hatalar, eksik özellikler ve gelecek ile ilgili planlar için
   TODO listesine bakýnýz.
   
       1.10) Nasýl SQL ögrenebilirim?
    
   http:/www.PostgreSQL.org/docs/awbook.html adresindeki kitap SQL ögretecektir.
   http://www.commandprompt.com/ppbook adresinde de bir baska PostgreSQL kitabý bulunmaktadýr.

   http://www.intermedia.net/support/sql/sqltut.shtm,
   http://ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM
   http://sqlcourse.com ve http://sqlcourse2.com adreslerinde de güzel belgeler bulunmaktadýr.

   Bir baþkasý da,  http://members.tripod.com/er4ebus/sql/index.htm adresinde bulunan
   "Teach Yourself SQL in 21 Days, Second Edition" kitabýdýr.
   
   Bazý kullanýcýlarýmýz da þu kitabý önermektedirler: 
	The Practical SQL Handbook, Bowman, Judith S., et al.,Addison-Wesley. Others 
	like The Complete Reference SQL, Groff et al., McGraw-Hill.    

   1.11) PostgreSQL 2000 yýlýna uyumlu mudur?
    
   Evet. 
   
       1.12) Gelistirme takýmýna nasýl katýlabilirim?
    
   Öncelikle, en son kaynak kodunu indirin ve web sitemizdeki ya da dagýtýmýn içindeki 
   PostgreSQL Developer belgesini okuyun. Ardindan, pgsql-hackers ve pgsql-patches 
   listelerine üye olun. Üçüncü olarak da, pgsql-pacthes listesine yüksek kalitede 
   yamalar gönderin.

   PostgreSQL CVS arsivine erisim izni olan, 10 kadar gelistirici bulunmaktadir.
   Hepsi defalarca, diger kisilerin yaptigindan cok daha  yüksek-kaliteli patchler 
   gondermislerdir. Ayrica biz de bu gelistiricilerin ekledikleri yamalarin yüksek
   kalitede olduguna güveniyoruz.
   
       1.13) Bir hata raporunu nasýl gönderebilirim? 

  PostgreSQL BugTool sayfasina gidiniz. O sayfada bir bug bildirmek icin neleri 
  yapmanýz gerektigi anlatilmistir.
   
  Ayrýca, ftp://ftp.PostgreSQL.org/pub ftp adresimizde, yeni bir PostgreSQL sürümü 
  ya da yamasi olup olmadigini kontrol ediniz.
   
       1.14) PostgreSQL, diger DBMS'lerle nasýl karsilastýrýlabilir?
    
   Bir yazilimin gücünü ölçmek için çesitli yollar vardir: Yazilimin özellikleri, 
   basarýmý, güvenilirligi, destegi ve ücreti.
   
   Özellikler

   PostgreSQL mevcut büyük ticari veritabanlarinin, transaction, subselect, 
   trigger, view, foreign key referential integrity ve sophisticated locking gibi
   tüm özelliklerine sahiptir. Onlarin sahip olmadiklari, kullanici-tanimli tipler 
   (user-defined types), rules, inheritance  ve lock cakýþmalarýný düþürmek için 
   multi-version uyumluluk özellikleri bulunmaktadir.
          
   Performans (Baþarým)

   PostgreSQL, diðer ticari ve açýk kaynak kodlu veritabanlarýyla yakýn baþarýmý saðlar. 
   Bazý açýlardan daha hýzlýdýr, diðer açýlardan da yavaþtýr. MySQL ya da daha zayýf 
   veritabanlarý ile karþýlaþtýrýldýðýnda,insert/update islemlerinde, transaction bazlý 
   çalýstýðýmýz için daha yavaþýz. MySQL, yukarýdaki "Özellikler" kýsmýnda belirtilenlerden
   hiç birine sahip deðildir. Biz, baþarýmýmýzý her sürümde arttýrsak da, esneklik ve 
   geliþmiþ özellikler için yapýlanmýs durumdayýz . PostgreSQL'i MySQL ile karþýlaþtýran  
   þu web sitesine bakabilirsiniz: http://openacs.org/why-not-mysql.html
          
   Güvenilirlik
   DBMSlerin güvenilir olmasý gerketigi, yoksa degerleri olmayacagini düsünüyoruz
   Çok iyi test edilmis, dengeli çalýsan minimum sayýda hata içeren kod sunmaya çalýsýyoruz.
   Her bir sürüm en az 1 aylýk beta testlerinden geçirilmektedir. Sürüm geçmiþine bakarsanýz,
   üretime hazýr, dengeli ve kararlý kodlar sundugumuzu görebilirsiniz. Bu alanda, diger 
   veritabaný yaZýlýmlarýna üstünlügümüz olduguna inanmaktayýz

   Destek
   E-posta listemiz, olusan herhangi bir sorunu çözebilecek büyük sayýda kullanýcý
   ve gelistirici grubunu içerir. Sorununuz için, en az bir ticari veritabaný kadar
   rahat çözüm bulabilirsiniz. Gelistiricilere, kullanýcý grubuna, belgelere ve
   kaynak koda direk olarak erisebilme, PostgreSQL destegini, diger DBMSlere göre daha
   önemli kýlar. Gereksinimi olanlara, ticari destek verilebilir. (Destek için 1.6 bölümüne bakýnýz.)
          
   Fiyat
   Ticari ve ticari olmayan tüm kullanýmlarýnýz için PostgreSQL ücretsizdir. Kodumuzu, yukarýda belirtilen
   BSD-stili lisanstaki sýnýrlamalar hariç, ürününüzün içine ekleyebilirsiniz.
          
       1.15) PostgreSQL'e maddi açýdan nasýl destek olabilirim?
    
   PostgreSQL, 1996 yýlýndan beri 1.sýnýf altyapýya ashiptir. Bunun için, yýllar boyu çalýsýp bu altyapýyý
   olusturup yöneten Marc Fournier'e tesekkürler.

   Bir açýk kaynak kodlu proje için, kaliteli altyapý çok önemlidir. Bu altyapý, projenin
   kesilmesini önler ve projenin ilerlemesini hýzlandýrýr.
   
   Tabii ki bu altyapý ucuz degildir. ýslerin yürümesi için çeþitli yýlýk ve anlýk 
   harcamalarýmýz olmaktadýr. Eger siz ya da sirketinizin bu çabamýza bagýsta 
   bulunabilecek parasý varsa, lütfen http://www.pgsql.com/pg_goodies adresine 
   gidiniz ve bagýsta, hibede bulununuz.

   Web sayfasýnýn PostgreSQL, ýnc.' den bahsetmesine ragmen, "katkýda bulunanlar" 
   (contributors) maddesi sadece PostgreSQL projesini desteklemek içindir ve belirli bir 
   sirketin para kaynagý degildir. isterseniz, baglantý adresine bir çek gönderebilirsiniz.

   ____________________________________________________________________________
   
                      Kullanýcý/istemci Sorularý
                                      
   2.1) PostgreSQL icin ODBC sürücüleri var mý?
    
   iki tane ODBC sürücüsü bulunmaktadýr:  PsqlODBC ve OpenLink ODBC.
   
   PsqlODBC'i http://gborg.postgresql.org/project/psqlodbc/projdisplay.php adresinden 
   indirebilirsiniz.
  
  OpenLink ODBC http://www.openlinksw.com adresinden alýnabilir.Bu sürücü,
  kendi standart ODBC istemci yazýlýmý ile çalýstýðýndan, destekledikleri 
  her platformda (Win, Mac, Unix, VMS) PostgreSQL ODBC bulunmalidir.
   
  Ücretsiz sürümü olmakla beraber, ticari kalitede destek almak isteyenlere satmak isteyeceklerdir. 
  Sorularýnýzý lütfen postgres95@openlink.co.uk adresine gönderiniz.
   
        2.2) PostgreSQL'i web sayfalarýnda kullanabilmek için hangi araçlar bulunmaktadýr?

   http://www.webreview.com adresinde, arka planda veritabaný çalýstýran Web sayfalarý
   için giris seviyesinde bilgi bulunmaktadýr.
   
   Web ile bütünlesme için, PHP mükemmel bir arabirim sunar. http://www.php.net .
   
   Karmaþýk sorunlar için, çoðu kisi Perl arabirimini ve  CGI.pm  ya da mod_perl kullanýr.
   

       2.3) PostgreSQL'in grafik kullanýcý arabirimi var mýdýr? 
    
   Çeþitli grafik arabirimlerimiz bulunmaktadýr. Bunlarýn arasýnda, PgAccess (http://www.pgaccess.org),
   PgAdmin II (http://www.pgadmin.org, sadece Win32 için), RHDB Admin (http://sources.redhat.com/rhdb/ )
   ve Rekall (http://www.thekompany.com/products/rekall/) bulunmaktadýr. Ayrýca, PostgreSQL için web
   tabanlý bir arabirim olan PHPPgAdmin (  http://phppgadmin.sourceforge.net/ ) bulunmaktadýr.
   
   Daha ayrýntýlý liste için http://techdocs.postgresql.org/guides/GUITools adresine bakabilirsiniz.

       2.4) PostgreSQL ile iletiþimi kurabilmek için hangi dilleri kullanabilirim?

     * C (libpq)
     * Embedded C (ecpg)
     * Java (jdbc)
     * Python (PyGreSQL)
     * TCL (libpgtcl)

     Diðerleri için, http://gborg.postgresql.org adresindeki Drivers/Interfaces bölümüne 
     bakabilirsiniz.
     _________________________________________________________________
   
                       Yönetimsel Sorular
                                      
   3.1) PostgreSQL'i, /usr/local/pgsql dizininden baska dizinlere nasýl kurabilirim?
    
   configure betigini çalýstýrýrken, --prefix seçenegini veriniz.
   
       3.2) postmaster'i baslattýgýmda, a Bad System Call ya da core dumped mesajý 
	alýyorum. Neden?
    
   Bunun birçok nedeni olabilir. Ancak ilk kontrol edilmesi gereken sey, çekirdeginize
   System V uzantýlarýnýn kurulu olup olmadýgýný kontrol etmek olabilir. PostgreSQL 
   shared memory ve semaphores için çekirdek destegine gereksinim duyar.

       3.3) postmaster'i baslattýgýmda, a ýpcMemoryCreate hatasý alýyorum. Neden?
    
   Ya çekirdeginizde shared memory desteginiz düzgünce yapýlandýrýlmamýstýr, ya da 
   çekirdeginizdeki mevcut shared memory miktarýný büyütmeniz gerekecektir. Gereksinim
   duyacagýnýz miktar, mimarinize ve postmaster için ayarladýgýnýz tampon ile backend 
   islemi sayýsýna baglýdýr. Tüm sistemler için, tamponlar ve islemlerde öntanýmlý sayýlarla,
   ~ 1MB kadar yere gereksinmeniz olacaktir.PostgreSQL Administrator's Guide' a, shared memory 
   ve semaphorelar  hakkýndaki ayrýntýlý bilgi için bakabilirsiniz.

       3.4) postmaster'i baslattýgýmda, a ýpcSemaphoreCreate hatasý alýyorum. Neden?
    
   Eger hata, "ýpcSemaphoreCreate: semget failed (No space left on device)" ise, 
   çekirdeginiz yeterli semaphore ile yapýlandýrýlmamýs demektir. Postgres, her 
   bir potansiyel backend için bir semaphore gereksinmesi duyar. Geçici bir çözüm, 
   postmasterý backend islemleri için daha az miktarda sýnýrla baslatmak olabilir. 
   -N i varsaýlan deger olan 32'den küçük bir degerle baslatýnýz. Daha kalýcý bir 
    çözüm, çekirdeðinizin SEMMNS ve SEMMNI parametrelerini yükseltmek olacaktýr.
   
   Çalýþmayan semaphorelar aðýr veritabaný islemlerinde çökme yaratabilirler.

   Eger hata mesajýnýz baska birsey ise, çekirdeginizde semaphore destegini 
   yapýlandýrmamýs olabilirsiniz. Shared memory ve semaphorelar hakkýndaki daha 
   ayrýntýlý bilgi için PostgreSQL Administrator's Guide'a bakabilirsiniz.
   
       3.5) Diger bilgisayarlarýn benim PostgreSQL veritabaný sunucuma baglantýlarýný 
	nasýl kontrol edebilirim?
    
   Ön tanýmlý olarak, PostgreSQL sadece yerel makineden Unix domain sockets kullanarak 
   baglanýlmasýna izin verir. Diger makineler, postmaster'a -i etiketini geçirmezseniz 
   ve $PGDATA_pg_hba.conf dosyasýný düzenleyerek  host-based authentication'a 
   olanak vermezseniz, baglantý yapamayacaklardýr. 
   
       3.6) Veritabani motorunu daha iyi basarim icin nasýl ayarlayabilirim?
  
   Indexler sorgularý hýzlandýrabilir. EXPLAIN komutu, PostgreSQL'in sorgunuzu nasýl
   yorumladýðýný ve hangi indexleri kullandigini görmenize izin verir.

   Eðer cok fazla INSERT islemi yapiyorsaniz, bunlarý büyük bir toplu islem dosyasi kullanýp
   COPY komutu ile veritabanina girmeyi deneyiniz. Bu, tekil ýNSERTlerden daha hýzlýdýr.
   ikinci olarak,  BEGýN WORK/COMMýT transaction blogu içinde olmayan  ifadeler kendi 
   transactionlarindaymis gibi düsünülür. Çoklu ifadeleri tek bir transaction bloðu içinde 
   yapabilirsiniz. Bu, transaction overheadini düþürecektir. Tek bir 
   transaction bloðu içinde  birden çok ifadeyi çalýþtýrmayý 
   deneyebilirsiniz. Bu, transaction overhead ini düþürür.
   
   Çeþitli ayarlama seçenekleri mevcuttur. fsync() iþlemini, postmaster'ý -o -F seçeneði ile 
   baþlatarak devre dýþý býrakabilirsiniz. Bu iþlem, fsync()'lerin her transactiondan sonra 
   diske flush etmesini engelleyecektir.

   Ayný zamanda, postmaster'i -B seçeneði ile baþlatýp, backend iþlemleri tarafýndan kullanýlan 
   shared memorf buffers sayýlarýný arttýrabilirsiniz. Eger bu parametreyi çok yüksek tutarsanýz, 
   çekirdeðinizin shared memory bölgesindeki limiti aþma olasýlýðýnýz yüzünden postmaster 
   baþlayamayabilir. Her bir tampon (buffer) 8K'dýr. Öntanýmlý sayý ise 64 tampondur.
   
   Ayný þekilde, backend'in -S seçeneðini geçici sýralamalar için backend süreçleri tarafýndan
   kullanýlacak hafýzayý arttýrmak amacýyla kullanabilirsiniz. -S seçeneði kilobayt cinsinden deðer alýr 
   ve ön tanýmlý deðeri 512'dir (512 K)
     
   Tablolardaki veriyi bir indekse eþlemek amacýyla gruplama için CLUSTER komutunu kullanabilirsiniz.
   Ayrýntýlý bilgi için CLUSTER komutunun yardým sayfasýna bakabilirsiniz.

       3.7) Hangi hata ayýklama özellikleri bulunmaktadýr?

   PostgreSQL, hata ayýklama amacýyla kullanýlabilecek durum bilgisi rapor eden çeþitli 
   özeliklere sahiptir.
 
   Öncelikle, configure betiðini --enable-cassert seçeneðiyle çalýþtýrýrsanýz, bir çok assert() backend calýþmasýný 
   gözlemler ve beklenmeyen bir durumda programý durdurur.

   Postmaster ve postgres çeþitli hata ayýklama seçeneklerine sahiptir. Öncelikle, 
   postmaster'i baþlattýðýnýzda, standart çýktýyý ve hatalarý bir log dosyasýna 
   yönlendirdiðinize emin olun:

    cd /usr/local/pgsql
    ./bin/postmaster >server.log 2>&1 &

    Bu iþlem PostgreSQL ana dizinine server.log dosyasý yerleþtirecektir. Bu dosya sunucunun 
    yaþadýðý sorunlar ya da hatalar hakkýnda yararlý bilgiler içerir. -d seçeneði, hata 
    ayýklama seviyesini belirten bir rakam ile kullanýlýr. Yüksek hata ayýklama 
    seviyelerinin büyük log dosyalarý oluþturacaðýný unutmayýnýz.
  
    Eðer postmaster çalýþmýyorsa, postgres backend'ini komut satýrýndan çalýþtýrabilir ve SQL ifadenizi
    direk olarak yazabilirsiniz. Bu sadece hata ayýklama amacýyla önerilir. Burada, noktalý virgülün deðil de
    yeni bir satýrýn sorguyu sonlandýrdýðýný unutmayýnýz. Eðer hata ayýklama sembolleri ile derlediyseniz,
    ne olduðunu görmek için bir hata ayýklayýcý kullanabilirsiniz. backend postmasterdan baþlatýlmadýðýndan,
    eþdeðer bir ortamda çalýþmamaktadýr ve locking/backend etkileþim sorunlarý artabilir.
   
    Eðer postmaster çalýþýyorsa, bir pencerede psql'i çalýþtýrýn ve psql tarafýndan kullanýlan postgres sürecinin süreç 
    numarasýný (PID) bulun. Postgres süreci ile iliþkilendirmek için bir hata ayýklarýcý kullanýn. Sorgularý psql 
    aracýlýðý ile çalýþtýrabilirsiniz. Eðer postgres baþlangýcýnda hata ayýklamak istiyorsanýz, PGOPTIONS="-W n" 
    seçeneðini ayarlayabilir ve psql'i baþlatabilirsiniz. Bu iþlem, baþlangýcýn n saniye kadar gecikmesini 
    saðlayacaktýr; böylece hata ayýklayýcýyý sürece iliþkilendirdikten sonra baþlangýç sürecinin devam etmesini 
    saðlayabilirsiniz.

    postgres programý hata ayýklama ve baþarým ölçümleri için -s, -A ve -t seçeneklerine sahiptir.
      
       3.8) Baglanmaya çalýsýken, neden "Sorry, too many clients" hatasýný alýyorum?
    
   Postmaster'in  eþzamanlý olarak baþlatabileceði backend süreçleri sýnýrlarýný 
   arttýrmanýz gerekmektedir.
   
   Ön tanýmlý deðer 32 süreçtir. Bunu, postmaster'i uygun -N deðeri ile ya da 
   postgresql.conf dosyasýný düzenleyerek yeniden baþlatmakla arttýrabilirsiniz.

   Eðer -N deðerini 32'den büyük yapacaksanýz, ayný zamanda -B deðerini de deðiþtirmeniz
   gerektiðini unutmayýn. -B -N'nin en az 2 katý kadar olmalýdýr; daha iyi baþarým için 
   bu sayýyý daha da arttýrmalýsýnýz. Yüksek sayýdaki backend süreçleri için, çeþitli çekirdek yapýlandýrma
   parametrelerini arttýrmanýz gerekecektir. Yapýlmasý gerekenler, SHMMAX, SEMMNS, SEMMNI, NPROC, MAXUPRC ve 
   açýlabilecek dosyalarýn maksimum sayýsý olan NFILE ve NINODE deðerlerini karýþtýrmaktýr. Bunun nedeni, PostgreSQL'in 
   izin verilen backend süreçlerinin sayýsý üzerinde bir sýnýrý olmasýdýr. Böylelikle sistem kaynaklarýnýn dýþýna 
   çýkýlmayacaktýr.

   PostgreSQL'in 6.5 sürümüne kadar, en fazla backend sayýsý 64 idi ve bunu deðiþtirmek için 
   include/storage/sinvaladt.h dosyasý içindeki MaxBAckendid sabitini deðiþtirdek sonra 
   yazýlýmý yeniden derlemek gerekiyordu.
   
   	3.9) pgsql_tmp dizinin içindeki dosyalar nelerdir?
    
   Sorgu çalýstýrýcý (query executer) tarafýndan yaratýlan geçici dosyalardýr. Örnegin,
   bir sýralama ORDER BY ile yapilacaksa ve sýralama backend'in -s parametresinin izin
   verdiginden daha fazla alana gereksinim duyuyorsa, ekstra veriyi tutmak için geçici
   dosyalar yaratýlýr.

   Geçici dosyalar, eger sýralama sýrasýnda backend göçmezse otomatik olarak silinecektir.
   Eger çalýsan durumda bir backendiniz yoksa, pg_tempNNN.NN dosyalarýný silmeniz güvenlidir..

   3.10) PostgreSQL sürümlerini yükselmek için neden bir dump/reload iþlemi gerçekleþtirmek zorundayým?

   PostgreSQL takýmý ara sürümlerde sadece küçük deðiþiklikler yapmaktadýr; bu yüzden 7.2 
   sürümünden 7.2.1'e yükseltmek dump/restore iþlemi gerekmemektedir. Ancak, esas sürümlerde 
   (örnek: 7.2'den 7.3'e) çoðunlukla sistem tablolarýnýn ve veri dosyalarýnýn iç yapýsý 
   deðiþtirilir. Bu deðiþiklikler çoðunlukla karmaþýktýr; dolayýsýyla veri dosyalarýnýn 
   geriye dönük uyumluluðu iþlemlerini yapmýyoruz. Dump iþlemi, veriyi genel biçimde 
   alacaðýndan yeniden yükleme esnasýnda veri, yeni iç biçime uygun þekilde 
   yerleþtirilecektir.

   Disk biçiminin deðiþmediði sürümlerde, pg_upgrade betiði güncellemenin bir dump/restore 
   gerektirmeden yapýlmasýný saðlayacaktýr. pg_upgrade betiðinin o sürüm için bulunup 
   bulunmadýðýný sürüm notlarý içinde bulabilirsiniz.

     _________________________________________________________________
   
			Ýþletimsel Sorular

                                      
       4.1) Binary cursor ve normal cursor arasindaki fark nedir?
    
   DECLARE yardým sayfasina bakiniz.
   
       4.2) Sorgunun sadece ilk birkaç satýrýný nasýl SELECT edebilirim?
	    
   FETCH yardým sayfasina bakiniz, aya da  SELECT ... LIMIT.... kullanýnýz.
   
   Ýlk birkaç satýrý almak isteseniz bile, tüm sorgu deðerlendirilmek durumunda kalýnabilir. ORDER BY içeren bir 
   sorgu düþünün. Eðer ORDER BY iþe eþleþen bir index varsa, PostgreSQL istenen ilk birkaç satýrý iþleyebilir, ya da
   tüm sorgu istenen satýrlar üretilene kadar iþlenebilir.
   
       4.3) psql'in içinde gördügüm tablolarin ya da diger seylerin listesini nasýl alabilirim?
    
   pgsql/src/bin/psql/describe.c içindeki psql kaynak kodunu okuyabilirsiniz. Bu kod, 
   psql'in \ ile baslayan komutlarýnýn çýktýsýný olusturan SQL komutlarini içerir. Ayný 
   zamanda, psql'i -E seçeneði ile baþlatýp, verdiðiniz komutlarý çalýþtýrmak için yaptýðý 
   sorgularýn çýktýlarýný görebilirsiniz.

       4.4) Bir tablodan bir kolonu nasýl kaldýrabilirim?
    
   Bu özellik (ALTER TABLE DROP COLUMN)  7.3 sürümü ile gelmiþtir. Eski sürümlerde 
   aþaðýdakileri uygulamalýsýnýz: 

    BEGIN;
    LOCK TABLE old_table;
    SELECT ...  -- select all columns but the one you want to remove
    INTO TABLE new_table
    FROM old_table;
    DROP TABLE old_table;
    ALTER TABLE new_table RENAME TO old_table;
    COMMIT;

       4.5) Bir satýr, tablo ve veritabaný icin en fazla büyüklük nedir? 
  
    Sýnýrlar:   
 
    Veritabani icin en fazla büyüklük nedir?			Sýnýrsýz (32 TB'lýk veritabaný bulunmaktadýr)
    Bir tablo icin en fazla büyüklük nedir?			32 TB
    Bir satýr için en fazla büyüklük nedir?			1.6 TB
    Bir alan için en fazla büyüklük nedir?			1 GB
    Tabloda en fazla satýr sayýsý kaçtýr?			Sýnýrsýz
    Bir tabloda olabilecek en fazla kolon sayýsý kaçtýr? 	Kolon tiplerine baðlý olarak  250-1600 
    Bir tabloda olabilecek en fazla index sayýsý kaçtýr?	sýnýrsýz

   Tabii ki bunlar aslinda sýnýrsýz degildir. Burada belirtilen sýnýrlar, fiziksel 
   sýnýrlarýn haricindeki sýnýrlardýr. Boþ disk alaný, hafýza/takas alaný na baðlý 
   sýnýrlamalar vardýr. Baþarým, sýnýr deðerlere yaklastýkça, ya da deðerler cok büyük 
   olduðunda düþebilir.
   
   Bir tablo için büyüklük sýnýrý olan 16 TB, iþletim sisteminin büyük dosya desteði olup
   olmamasýndan baðýmsýzdýr. Büyük tablolar, 1 GB'lik dosyalarda saklandýðý için, dosya 
   sistemi sýnýrlarýnin bir önemi yoktur.
   
   Tablo ve kolon sayýsý büyüklükleri, ön tanýmlý blok büyüklüðü 32k ya çýkarýlarak 
   arttýrýlabilir.
   
      4.6) Tipik bir metin dosyasýndaki veriyi saklamak için ne kadar disk alaný gereklidir?
    
   Bir PostgreSQL veritabaný, veriyi "flat" metin dosyasýnda saklamak için gereken 
   alanýn 5 kat fazla disk alanýna gereksinim duyabilir.

   Her satýrýnda bir tamsayý ve metin (text) içeren, 100.000 satýrlýk bir dosya düþünün. 
   Her satýrýn ortalama 20 byte olduðunu farzedelim. Metin dosyasý 2.8 MB olacaktýr. Bu veriyi
   tutan PostgreSQL veritabaný yaklaþýk 6.4 MB yer kaplayacaktýr.

     36 byte: Her bir satýr baslýgý (yaklasik)
   + 24 byte: Bir tamsayý (int) alani ve bir metin (text) alaný 
   +  4 byte: Sayfada tuple a pointer
   ----------------------------------------
    64 byte -> kayýt basýna

   PostgreSQL'de data page büyüklüðü 8192 byte (8k)dir, dolayýsýyla:

   8192 byte -> page basýna
   -------------------------  =  Her bir veritabani page i baþýna 128 satýr (yaklaþýk)
     Satýr basýna 64 byte

   100000 veri satýrý
   --------------------  =  782 veritabaný sayfasý
       128 satýr

    782 veritabaný sayfasý * sayfa baþýna 8192 byte =  6,406,144 bytes (6.4 MB)

   Indexler cok fazla yere gereksinim duymazlar, ama indexlenmis veriyi tutacaklarýndan
   büyük olabilirler.
   
   NULL deðerler bitmapler içinde tutulur; dolayýsýyla çok az yer kaplarlar.

       4.7) Veritabanýnda hangi tablo ya da indexlerin tanýmlandýgýný nasýl görebilirim?
    
    psql, bu tür bilgileri göstermek için, \ ile baþlayan bir çok komut sunmaktadýr. 
    \? komutu ile bu komutlarý görebilirsiniz. Ayrýca, bunlarý açýklayan ve pg_ ile baþlayan 
    çok sayýda sistem tablosu bulunmaktadýr. Ayný zamanda, psql -l ile tüm veritabanlarýný 
    listeyelebirsiniz.
   
   Ayrýca, pgsql/src/tutorial/syscat.source kodunu inceleyebilirsiniz. Bu dosya, veritabaný 
   sistem dosyalarindan bilgiyi almak için gereksinim duyulan  bir çok SELECTleri gösterir.

    4.8) Sorgularým cok yavaþ, ya da indexlerimi kullanmýyorlar. Neden? 
Indexler her sorgu tarafýndan otomatik olarak kullanýlmazlar. Indexler eðer bir tablonun büyüklüðü minimum bir 
büyüklükten fazla ise ve sorgu tablodaki satýrlarýn sadece küçük bir yüzdesini seçiyorsa kullanýlýr. Bunun nedeni, 
index eriþiminin neden olduðu raslansal disk eriþimi nin diskin ya da tablonun sýralý okunmasýndan daha yavas 
olabilmesidir.

Bir index'in kullanýlýp kullanýlmayacaðýný belirlemek için, PostgreSQL tablo hakkýndaki istatistiklere gereksinmesi 
vardýr. Bu istatistikler, VACUUM ANALYZE kullanýlarak toplanýrlar. Optimizer, istatistikleri kullanarak, tabloda kaç 
satýr olduðunu ve bilir ve indexin kullanýlýp kullanýlmayacaðýna daha iyi karar verir. Istatistikler, ayný zamanda en 
uygun join sýrasýný ve yöntemini belirlemekte çok önemlidir. Ýstatistik toplanmasý, tablo içerikleri deðiþtikçe 
periyodik olarak yapýlmalýdýr.

Indexler normalde ORDER BY sorgularý ya da join iþlemlerini gerçekleþtirmek için kullanýlmazlar. Açýk bir sýralamayý 
takip eden sýralý bir arama (sequential scan), büyük bir tabloda index aramasý yapmaktan genelde daha hýzlýdýr.
Ancak, ORDER BY ile birleþmiþ LIMIT genellikle bir index kullanacaktýr; çünkü tablonun sadece belirli bir miktarý 
döndürülecektir. Aslýnda, MAX() ve MIN() fonksiyonlarýnýn index kullanmamalarýndan dolayý, bu gibi deðerleri ORDER BY 
ve LIMIT kullanarak da almak olasýdýr:

    SELECT col
    FROM tab
    ORDER BY col [ DESC ]
    LIMIT 1;

Eðer optimizer'ýn sýralý arama yapmasýnýn yanlýþ olduðuna inanýyorsanýz, SET enable_seqscan TO 'off' kullanýn ve 
index kullanan aramalarýn hala daha hýzlý olup olmadýðýný görün.

LIKE ya da ~ gibi operatörler kullanýyorsanýz, index'ler sadece aþaðýdaki koþullarda kullanýlabilir:

    * Arama dizininin baþý, dizinin baþý ile baðlanmalýdýr. Yani,
          o LIKE sorgularý % ile baþlamamalýdýr.
          o Düzenli ifade sorgularý ^ iþe baþlamamalýdýr.
    * Arama metni bir karakter sýnýfý ile baþlayamaz. Örnek: [a-e]
    * ILIKE ve ~* gibi büyük/küçük harfe duyarsýz aramalar index'lerden yararlanmazlar. Onun yerine, bölüm 4.12'de 
anlatýlan fonksiyonel index'leri kullanabilirsiniz.
    * initdb sýrasýnda öntanýmlý C locale'i kullanýlmalýdýr.

 4.9) query-optimizer in sorgularýmý nasýl deðerlendirdiðini, iþleme soktuðunu nasýl görebilirim?
    
   EXPLAIN yardým sayfasýna bakýnýz.	
   
       4.10) R-tree index nedir?
R-tree index, uzaysal (spatial) verileri indexlemek için kullanýlýr. Bir hash index, dizi aramalarýnda (range search) 
kullanýlamaz. B-tree index dizi aramalarýnda sadece tek boyutlu çalýþmaktadýr. R-tree, çok boyutlu veriyi destekler. 
Örneðin, eðer bir R-tree index point veri tipi üzerinde inþa edililebilirse, sistem "select all points within a 
bounding rectangle" gibi sorgulara daha verimli yanýtlar verecektir.

Orijinal R-tree tasarýmýný açýklayan belge:

Guttman, A. "R-trees: A Dynamic Index Structure for Spatial Searching." Proceedings of the 1984 ACM SIGMOD Int'l Conf 
on Mgmt of Data, 45-57.

Bu belgeyi, Stonebraker'ýn "Readings in Database Systems" kitabýnda bulabilirsiniz.

Gömülü R-tree indexleri poligon ve boxlarý kullanabilir. Teorik olarak, R-tree indexlerin özelliklerini 
geniþletmek bir miktar çaba gerektirir ve bunun nasýl yapýlacaðýna dair bir belgemiz henüz bulunmamaktadýr.

       4.11) Genetic Query Optimizer nedir?
  
   GEQO modülü, Genetic Algorith(GA) kullanýlarak tablolar birleþtirildiðinde sorgu optimizasyonunu hýzlandýrýr. 

    4.12) Düzenli ifade (Regular Expression) aramalarýný ve büyük/küçük harfe duyarsýz aramalarý nasýl yapabilirim?
	Bu büyük(küçük harfe duyarlý aramalar için indeksi nasýl kullanabilirim?
    
   ~ operatörü düzenli ifade eþleþmesi ve ~*  büyük/küçük harfe duyarsýz düzenli ifade eþleþmesi yapar.
   Büyük/küçük harfe duyarlý olan LIKE'in  büyük/küçük harfe duyarsýz olan biçini ILIKE'týr ve PostgreSQL
   7.1 sürümü ile birlikte gelmiþtir.
     
   Büyük-küçük harfe duyarsýz eþitlik karþýlaþtýrmalarý aþaðýdaki gibi ifade edilir:

    SELECT *
    FROM tab
    WHERE lower(col) = 'abc'

   Bu standart bir indeks yaratmayacaktýr. Ancak eðer fonksiyonel bir indeks yaratýrsanýz; o kullanýlacaktýr:

    CREATE INDEX tabindex on tab (lower(col));

    4.13)  Bir sorguda, bir alanin "NULL" oldugunu nasýl ortaya çýkarabilirim?
    
   Kolonu, IS NULL ve IS NOT NULL ile test edebilirsiniz.
   
       4.14) Çesitli karakter tipleri arasýndaki farklar nelerdir?
    
Veri Tipi	Ýç Adý              Not
--------------------------------------------------
VARCHAR(n)      varchar         boyut en büyük uzunluðu verir; sadece verilen kadar veri tutulur.
CHAR(n)         bpchar          belirtilen uzunlupa kadar sonuna  boþluk eklenir.
TEXT            text            uzunlukta herhangi bir üst sýnýr yoktur. 
BYTEA           bytea           variable-length byte array (null-byte safe)
"char"          char            bir karakter 

Ýç adlarý (internal name) sistem kataloglarýný ve bazý hata meajlarýný incelerken göreceksiniz.
  
   Ýlk dört veri tipi "varlena" tipidir (yani, diskteki ilk 4 bayt uzunluktur; devamý da veridir.) Dolayýsýyla,
   Böylece, kullanýlan gerçek alan, belirtilen alandan biraz daha büyüktür. Ancak, bu veri tipleri, sýkýþtýrýlmaya tabi 
   tutulabilir; dolayýsýyla disk alaný beklenilenden kücük olabilir. VARCHAR(n) büyüklüðü artabilen ama en büyük 
   uzunluðu sýnýrlý oan verileri saklamak için en uygun yöntemdir. TEXT, 1 GB büyüklüðe kadar olan verileri tutmak için 
   kullanýlýr.

   CHAR(n), ayný uzunluktaki dizilerin saklanmasý için kullanýmýr. CHAR(n) belirtilen uzunluða kadar boþluk ile 
   doldurur; ancak VARCHAR(n) sadece verilen karakterleri saklar.BYTEA binary veri saklamak içindir; ayrýca "NULL" bayt 
   içeren deðerleri de saklar. Burada anlatýlan üç veri tipi de benzer baþarým karakteristiklere sahiptir.
   
       4.15.1) nasýl serial/otomatik artan(auto-incrementing) bir alan yaratabilirim?
    
     PostgreSQL'de SERIAL veri tipi vardýr. Bu veri tipi bir sequence ve kolon üzerinde bir indeks yaratýr.

    Örnek, aþaðýdaki sorgu:

    CREATE TABLE person (
        id   SERIAL,
        name TEXT
    );

    buna çevrilir:

    CREATE SEQUENCE person_id_seq;
    CREATE TABLE person (
        id   ýNT4 NOT NULL DEFAULT nextval('person_id_seq'),
        name TEXT
    );
    CREATE UNIQUE ýNDEX person_id_key ON person ( id );

  Sequenceler hakkýnda daha fazla bilgi için create_sequence yardým sayfasýna bakabilirsiniz. Her satýrýn OID alanýný 
  tekil bir sayý olarak alabilirsiniz. Ancak, veritabanýnýzýn dump'ýný alýp yeniden yüklerseniz, OID deðerlerini
  koruyabilmek için pg_dump'ýn -o parametresini ya da "COPY WITH OIDS" seçeneðini kullanmanýz gerekecektir.
   
   4.15.2) SERIAL giriþinin degerini nasýl alabilirim?

  Bir yaklaþým, sequence nesnesindeki SERIAL deðerini, veriyi girmeden önce nextval() ile alýp, aldýðýnýz deðeri 
kendinizin girmesidir. 4.15.1'deki örnek tabloyu kullanarak bir örnek verelim:

    new_id = execute("SELECT nextval('person_id_seq')");
    execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");

  Diðer sorgular için new_id'de yeni deðerin saklanmasý gerekir. Otomatik olarak yaratýlan SEQUENE nesnesinin adý,
  <tablo adý>_<serial kolonu adý>_seq þeklinde olacaktýr (< > iþaretleri olmadan).

 Alternatif olarak, atanmýþ SERIAL deðerini, deðer girildikten sonra currval() fonksiyonu ile alabilirsiniz:

    execute("INSERT INTO person (name) VALUES ('Blaise Pascal')");
    new_id = execute("SELECT currval('person_id_seq')");

  Son olarak, ön tanýmlý deðeri bulmak için INSERT ifadesinden dönen OID deðerini kullanabilirsiniz; ancak bu
  en az taþýnabilir çözüm olacaktýr. Perl'de, Edmund Mergl'in DBD:Pg mödülü ile birlikte DBI kullanarak, OID deðeri
  $sth->execute() çalýþtýrýldýktan sonra $sth->(pg_OID_status) ile alýnabilir.

       4.15.3) currval() ve  nextval() diger kullanicilara sorun yaratmaz mý?
    
   Hayýr. curval(), tüm kullanýcýlar degil, backend tarafýndan atanan geçerli  
   degeri döndürür.
   
      4.15.4) Neden sequence sayýlarýn transaction iþleminin iptalinden sonra yeniden kullanýlýyor? Neden sequence/SERIAL 
		kolonumdaki sayýlarda atlamalar oluyor?

   Uyumluluðu arttýrmak için, sequence deðerleri çalýþan transactionlara gerektiði þekilde aktarýlýr ve transaction 
   bitene kadar o deðer kilitlenmez. Bu, iptal edilen transaction iþlemleri nedeniyle boþluklara neden olur. 

    4.16) OID nedir? TID nedir?

OIDler, tekil satýr numaralarýna PostgreSQL'in yanýtýdýr. PostgreSQL'de yaratýlan her sayý, tekil bir OID alýr. 
initdb iþlemi sýrasýnda yaratýlan tüm OID'ler 16384'ten küçüktür (backend/access/transam.h). Kullanýcýlar tarafýndan 
yaratýlan tüm OID'ler bu sayýya eþit ya da bu sayýdan büyüktür. Varsayýlan durumda, tüm bu OIDler sadece bir tablo ya 
da veritabanýnda deðil, tüm PostgreSQL kurulumunda tekildir.

PostgreSQL OIDleri, tablolar arasýnda satýrlarý iliþkilendirmek için kendi iç tablolarýnda kullanýr. Bu OIDler 
belirli kullanýcý satýrlarýný belirtmek için kullanabilir ve join iþlemlerinde kullanýlýr. OID deðerlerini saklamak 
için OID kolon tipini kullanmanýz önerinir. Daha hýzlý bir eriþim için, OID alanýnda bir index yaratabilirsiniz.

OID'ler yeni satýrlara, tüm veritabanlarý tarafýnda kullanýlan ortak bir alandan atanýrlar. Eðer OID'i baþka bir 
deðere eþitlemek isterseniz ya da tablonun bir kopyasýný orijinal OIDler ile çýkarmak isterseniz, bu mümkündür:

        CREATE TABLE new_table(old_OID OID, mycol int);
        SELECT old_OID, mycol ýNTO new FROM old;
        COPY new TO '/tmp/pgtable';
        DELETE FROM new;
        COPY new WITH OIDS FROM '/tmp/pgtable';

OIDler 4-bit tamsayý olarak saklanýrlar ve 4 milyarda overflow olacaktýr. Kimse bu sayýya ulaþtýðýna dair bir bilgi 
iletmedi ve bu sýnýrý kimse bu sýnýra ulaþmadan kaldýracaðýz.

TIDler, belirli fiziksel satýrlar block ve offset deðerleri ile belirtmekte kullanýlýr. TIDler, satýrlar deðiþtiðinde 
ya da yeniden yüklendiðinde deðiþirler. Index girdileri tarafýndan fiziksel satýrlarý göstermek için kullanýlýrlar.
   
       4.17) PostgreSQL'de kullanýlan bazý terimlerin anlamlarý nelerdir?
    
   Kaynak kodun bir kýsmý ve eski belgeler, daha geniþ kullaným alaný olan terimleri
   kullanýrlar. Bunlarýn bazýlarý:

     * table, relation, class
     * row, record, tuple
     * column, field, attribute
     * retrieve, select
     * replace, update
     * append, insert
     * OID, serial value
     * portal, cursor
     * range variable, table name, table alias

  Genel veritabaný terimleri,

    http://hea-www.harvard.edu/MST/simul/software/docs/pkgs/pgsql/glossary/glossary.html
   adresinde bulunabilir.
   
       4.18) Neden  "ERROR: Memory exhausted in AllocSetAlloc()"? hatasýný alýyorum?
    
   Sisteminizde sanal belleðinizi tüketmis olabilirsiniz, ya da çekirdeðiniz
   belli kaynaklar icin düþük bir sýnýra sahip olabilir. Postmaster'i baþlatmadan önce 
   aþaðýdakileri deneyebilirsiniz:

    ulimit -d 262144
    limit datasize 256m

   Kabuðunuza baðlý olarak, bunlardan sadece biri olumlu sonuç verecektir, ama
   bu iþlem veri segment sýnýrýnýzý arttýracak, ve belki de sorgunuzun tamamlanmasýný
   saglayacaktýr. Bu komut, varolan sürece (current process) ve komut çalýstýrýldýktan
   sonraki tüm alt islemlere uygulanýr. Eðer SQL istemcinizle, backendin çok fazla veri 
   döndürmesi nedeniyle bir sorun yaþýyorsanýz, bunu istemciyi baþlatmadan önce deneyiniz.
   
       4.19) Hangi PostgreSQL sürümünü çalýstýrdýgýmý nasýl görebilirim?
    
   psql arabiriminde, SELECT version(); yazýnýz.
   
   4.20) Neden large-object islemlerim, "invalid large obj descriptor"? hatasýný veriyor?

   Large object iþlemlerinizin uçlarýna, yani  lo_open ... lo_close komutlarýnýn çevresine, 
    BEGIN WORK ve COMMIT koymanýz gerekmektedir.

   Eger ODBC gibi bir istemci arabirimi kullanýyorsanýz, auto-commit'i kapatmanýz gerekebilir.
   
   4.21) Þu andaki zamaný öntanýmlý deðer olarak kabul eden kolonu nasýl yaratabilirim?
    
   Alttakini kullanabilirsiniz:

   CURRENT_TIMESTAMP:
	CREATE TABLE test (x int, modtime timestamp DEFAULT CURRENT_TIMESTAMP );

   4.22) Neden IN kullanan subquerylerim çok yavas?

7.4 sürümünden önce, subqueryler. Eðer subquery sadece birkaç satýr ve outer query bol sayýda satýr döndürüyorsa, IN 
en hýzlýsýdýr. Sorgularý hýzlandýrmak için IN yerine EXISTS kullanýn:

    SELECT *
    FROM tab
    WHERE col IN (SELECT subcol FROM subtab);

sorgusunu, aþaðýdaki ile deðiþtirin:

    SELECT *
    FROM tab
    WHERE EXISTS (SELECT subcol FROM subtab WHERE subcol = col);

 Bunun hýzlý olabilmesi için, subcol'un indekslenmiþ bir kolon olmasý gerekmektedir.
 
	7.4 sürümü ve sonrasýnda, IN aslýnda normal sorgularla ayný karmaþýk join tekniklerini kullanýr ve EXISTS'e tercih 
	edilir.
   
       4.23) Outer join islemini nasýl yapabilirim?
    
   PostgreSQL outer join iþlemlerini SQL standartlarýný kullanarak gerçekleþtirmektedir.
   Aþaðýda 2 örnek bulunmaktadýr:

    SELECT *
    FROM t1 LEFT OUTER JOýN t2 ON (t1.col = t2.col);

   ya da 

    SELECT *
    FROM t1 LEFT OUTER JOýN t2 USýNG (col);

   Bu özdeþ sorgular t1.col ' i  t2.col'ye join ederler ve ayný zamanda t1'deki unjoined satýrlarý 
   (t2'de eþlenmenis olanlarla) döndürürler. RIGHT JOýN t2'nin unjoined satýrlarýný ekleyecektir.
   Bir FULL join, eþleþmiþ bütün satýrlarý ve t1 ile t2'den tüm baðlanmamýþ (unjoined) satýrlarý alýr.
   OUTER sözcüðü seçimseldir ve LEFT, RIGHT ve FULL join iþlemlerinde olduðu kabul edilir. Sýradan 
   join iþlemleri INNER join olarak adlandýrýlýr.

   Önceki sürümlerde, OUTER JOINler UNION ve NOT IN kullanýlarak simüle edilebiliyordu. Örneðin, tab1 
   ve tab2'yi birleþtirirken, aþaðýdaki sorgu iki tablonun dýþtan baðlanmasýný saðlar:

    SELECT tab1.col1, tab2.col2
    FROM tab1, tab2
    WHERE tab1.col1 = tab2.col1
    UNION ALL
    SELECT tab1.col1, NULL
    FROM tab1
    WHERE tab1.col1 NOT ýN (SELECT tab2.col1 FROM tab2)
    ORDER BY col1

       4.24) Ayný anda birden fazla veritabanýnda nasýl iþlem yapabilirim?

   Mevcut veritabanýnýz dýsýndaki baska bir veritabanýnýzý sorgulamanýzýn bir yolu bulunmamaktadýr.
   bunun nedeni, PostgreSQL'in veritabanýna özel sistem kataloglarý yüklemesidir. Bu nedenle, 
   cross-database bir sorgunun nasýl davranacagýný kestirmek zordur.
   
   contrib/dblink fonksiyon çaðrýlarýný kullanarak cross-database sorgulara izin vermektedir. Tabii ki, 
   bir istemci deðiþik veritabanlarýna ayný anda eriþim saðlayabilir ve bilgiyi bu sekilde
   birleþtirebilir.

   4.25) Bir fonksiyondan nasýl çoklu satýr ya da kolon döndürebilirim?

   7.3 sürümünde, bir fonksiyondan kolaylýkla çoklu satýr ya da sütun döndürebilirsiniz.

	http://techdocs.postgresql.org/guides/SetReturningFunctions .

   4.26) Neden PL/pgSQL fonksiyonlarý içinden güvenli bir þekilde tablo yaratma/kaldýrma iþlemlerini yapamýyoruz?

   PL/pgSQL fonksiyon içerikleri cacheler. Bunun istenmeyen bir tarafý, eðer bir PL/pgSQL fonksiyonu geçici bir
   tabloya eriþiyorsa ve bu tablo ileride kaldýrýlýp yeniden oluþturulduktan sonra fonksiyon yeniden çaðrýlýrsa,
   fonksiyon çalýþmayacaktýr; çünkü cachelenmiþ fonksiyon hala eski geçici tabloyu gösteriyor olacaktýr. Çözüm,
   geçici tablo eriþimleri için PL/pgSQL'de EXECUTE kullanmaktýr. Bu, sorgunun her seferinde yeniden iþlenmesini
   saðlayacaktýr.

   4.27) Hangi replikasyon seçenekleri bulunmaktadýr?

   Çeþitli master/slave replikasyon seçenekleri bulunmaktadýr. Bunlar master veritabanýnýn veritabaný deðiþikliklerini 
   yaparken, slave sunucunun sadece veritabanýnda okuma yapmasýna izin verir. 
   http://gborg.PostgreSQL.org/genpage?replication_research sayfasýnýn altýnda bunlarýn listesini bulabilirsiniz.
   http://gborg.PostgreSQL.org/project/pgreplication/projdisplay.php adresinde, çoklu-master replikasyon çözümü 
   üzerinde çalýþýlýyor.

   4.28) Hangi þifreleme seçenekleri bulunmaktadýr?

    * contrib/pgcrypto SQL sorgularýnda kullanýlabilmesi için þifreleme fonksiyonlarý içermektedir.
    * Ýstemciden sunucuya iletiþimi þifrelemek için, sunucuda ssl seçeneði postgresql.conf içinde açýk olmalýdýr.
      Ayrýca,pg_hba.conf dosyasý içinde host ya da hostssl kaydý mutlaka olmalýdýr ve istemci sslmode 
      kapatýlmamalýdýr. (Ayný zamanda,PostgreSQL'in doðal SSL baðlantýlarý dýþýnda ssh ya da ssl gibi 3.parti 
      þifrelenmiþ veri iletimi de mümkündür.)
    * Veritabaný kullanýcý adý ve þifreleri 7.3 sürümü ile birlikte otomatik olarak þifrelenirler. Önceki 
      sürümlerde, postgresql.conf içindeki PASSWORD_ENCRYPTION seçeneðini aktif hale getirmeniz gerekmektedir.
    * Sunucunun kendisini þifreli dosya sistemi üzerinde çalýþtýrabilirsiniz.

     _________________________________________________________________
   
    		PostgreSQL Özelliklerini Geniþletmek

    5.1)  Kullanýcý-tanýmlý bir fonksiyon yazdým. psql'de çalýþtýrdýðým zaman neden core dump ediyor?
    
   Sorunun nedeni birden fazla sey olabilir. Kullanici-tanimli fonksiyonunuzu stand-alone bir programda
   calistirmayi deneyiniz.
   
    5.2) PostgreSQL'e nasýl yeni veri tipleri/fonksiyonlar ekleyebilirim?
    
   Çalýþmalarýnýzý pgsql-hackers e-posta listesine gönderiniz. Kodunuz incelendikten sonra
   /contrib dizinine konacaktýr.
   
    5.3) Bir tuple döndürmek icin bir C fonksiyonunu nasýl yazarým?
    
     PostgreSQL 7.3 sürümü ile birlikte, C, PL/pgSQL ve SQL kullanýlarak tablo-döndüren 
     fonksiyonlar tamamen desteklenmektedir. Ayrýntýlý bilgi için "Programmer's Guide" a 
     bakabilirsiniz. Bir örneði contrib/tablefunc içinde bulabilirsiniz.

    5.4) Bir kaynak dosyasýnda deðiþiklik yaptým. Yeniden derlememe raðmen deðiþiklik 
     geçerli olmuyor. Neden?
    
   Makefile'lar include dosyalarý için tam bir baðýmlýlýk içermezler. 
   Öncelikle make clean, ardýndan da baska bir make iþlemi yapmanýz gerekir.
   GCC kullanýyorsaniz, configure betiðinin --enable-depend seçeneðini, derleyicinin
   baðýmlýlýklarý otomatik olarak hesaplamasý için kullanabilirsiniz. 

