PostgreSQL(ポストグレス・キュー・エル)についてよくある質問とその解答(FAQ)

原文最終更新日: Tue Sep 9 18:42:51 EDT 2003

現在の維持管理者: Bruce Momjian (pgman@candle.pha.pa.us)
Maintainer of Japanese Translation: Jun Kuwamura (juk at PostgreSQL.jp)

この文書の最新版は http://www.PostgreSQL.org/docs/faqs/FAQ.html で見ることがで
きます。

プラットホームに特有の質問については: http://www.PostgreSQL.org/docs/index.html
に回答があります。

(以下、訳者による注釈を [訳注： と ] とで囲んで記します。)
[訳注：
        日本語版製作についてのメモは最後尾へ移動しました。

        日本語版のこの文書は 本家 "Docs"  の "Frequently Asked Questions" の
        ところに "Japanese FAQ" という見出であります。また、以下のサイトにも
        あります。
                http://www.PostgreSQL.jp/subcommittee/jpugdoc/
                http://www.rccm.co.jp/~juk/pgsql/
                http://www.linux.or.jp/JF/

        この和訳についてお気づきの点は(juk at PostgreSQL.jp)までメールでお寄せ下さい。

                                                2003年09月20日    桑村 潤
]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

                                 一般的な質問                                  
                                                                               
1.1) PostgreSQLとは何ですか？何と読みますか？
1.2) PostgreSQLの著作権はどうなってますか？
1.3) PostgreSQLの動作するUnixプラットホームは？
1.4) Unix以外の移植版で使えるものは？
1.5) PostgreSQLはどこから入手できますか？
1.6) サポートはどこで受けられますか？
1.7) 最新版はどれですか
1.8) どのような文書がありますか？
1.9) 既知のバグや未だ無い機能はどうやって見つけますか？
1.10) SQLはどうすれば学べますか？
1.11) PostgreSQLは西暦2000年問題(Y2K)に対応していますか？
1.12) 開発チームにはどのように参加しますか？
1.13) バグレポートはどのように発信しますか？
1.14) 他のDBMSのと比べてPostgreSQLはどうなのですか？
1.15) PostgreSQLを資金面で援助するにはどうすればよいですか？

                         ユーザー・クライアントの質問                          
                                                                               
2.1) PostgreSQL の ODBC ドライバーはありますか？
2.2) PostgreSQL を Web ページと連携させるにはどんなツールがありますか？
2.3) PostgreSQL にグラフィカル・ユーザインターフェイスはありますか？
2.4) どのような言語で PostgreSQL と通信できすか？

                                 管理上の質問                                  
                                                                               
3.1) どのようにすれば /usr/local/pgsql 以外の場所にインストールできますか？
3.2) postmaster を走らせると、 Bad System Call とかコア・ダンプしたとのメッセー
ジが出ます。なぜですか？
3.3) postmaster を走らせようとすると、 IpcMemoryCreate エラーが出ます。なぜです
か？
3.4) postmasterを走らせようとすると、 IpcSemaphoreCreate エラーが出ます。なぜで
すか？
3.5) 他のホストからの接続はどのように制御しますか？
3.6) より良い性能を得るためには、データベース・エンジンをどのように調整すれば良
いですか？
3.7) どのようなデバグ機能が使えますか？
3.8) 接続しようとするときに 'Sorry, too many clients' が出るのはなぜですか？
3.9) pgsql_tmp ディレクトリの中には何がありますか？
3.10) PostgreSQLのメジャーリリースをアップデートするのにダンプとリストアをしな
くてはならないのはなぜですか？

                                 操作上の質問                                  
                                                                               
4.1) バイナリ・カーソルと通常カーソルとの違いは何ですか？
4.2) 最初の数ロウのみを select するにはどうしますか？ランダムな行？
4.3) テーブルやその他の情報のリストを psql で見るにはどうしますか？
4.4) テーブルからカラムの削除、あるいは、データ型を変更するにはどうしますか？
4.5) ロウ、テーブル、データベースの最大サイズは？
4.6) 一般的なテキストファイルからデータを保存するには、データベースのディスク容
量はどのくらい必要ですか？
4.7) 定義されたテーブル、インデックス、データベース、および、ユーザをどのように
して見つけ出しますか？
4.8) 問い合わせが遅いうえ、インデックスを使っている様子がありません。なぜですか
？
4.9) 問い合わせオブティマイザがどのように問い合わせを評価するかを見るにはどうし
ますか？
4.10) R-tree インデックスとは何ですか？
4.11) 遺伝的問い合わせ最適化とは何ですか？
4.12) 正規表現での検索や大文字と小文字とを区別しない正規表現検索はどのように実
現しますか？大文字と小文字とを区別しない検索のためのインデックスはどのように使
いますか？
4.13) 問い合わせの中で、フィールドが NULL であることを検出するにはどうしますか
？
4.14) 色々な文字型のそれぞれの違いは何ですか？
4.15.1) 通番(serial)／自動増分フィールドはどのようにつくりますか？
4.15.2) SERIALデータ型に挿入される値は、どうすれば得られますか？
4.15.3) 他のユーザとの競合状態を避けるためには、currval() と nextval() は使わな
いほうがよいのでしょうか？
4.15.4) トランザクションが中断したときにもういちどシーケンス番号が使われないの
はなぜですか？シーケンス／SERIALカラムに空きがあるのはなぜですか？
4.16) OID とは何ですか？ TID とは何ですか？
4.17) PostgreSQL で使われるいくつかの用語の意味は何ですか？
4.18) エラーメッセージ "ERROR: Memory exhausted in AllocSetAlloc()"が出るのはな
ぜですか？
4.19) どのバージョンの PostgreSQL を走らせているのかを調べるにはどうしますか？
4.20) ラージオブジェクトの操作で、invalid large obj descriptorと出るのはなぜで
すか？
4.21) 現在の時刻がデフォルトとなるようなカラムはどのようにつくりますか？
4.22) なぜ、INを使う副問い合わせがとても遅いのですか？
4.23) 外部結合(outer join)はどのように実現しますか?
4.24) 複数のデータベースを使う問い合わせはどのようにすればできますか？
4.25) 関数で複数のロウまたはカラムを返すにはどうしますか？
4.26) なぜ、PL/PgSQL 関数の中から一時テーブルを確実に create/drop することがで
きないのでしょうか？
4.27) どのようなリプリケーションオプションを利用できますか?
4.28) どのような暗号化オプションを利用できますか?

                        PostgreSQLの拡張についての質問                         
                                                                               
5.1) 自分で書いたユーザ定義関数を psql の中で実行するとコア・ダンプしてしまうの
はなぜですか？
5.2) PostgreSQL 用に書いたちょっと素敵な新しい型や関数を提供してプロジェクトに
貢献したいのですが？
5.3) タプルを返す C言語の関数はどのように書きますか？
5.4) ソース・ファイルを変更しました。再コンパイルしても変化が見られないのはなぜ
ですか？

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

                                 一般的な質問                                  
                                                                               
1.1) PostgreSQL とは何ですか？何と読みますか？

Post-Gres-Q-L.(ポスト - グレス - キュー - エル) と発音します。

PostgreSQL は次世代 DBMS 研究用のプロトタイプであった POSTGRES データベース管理
システムの改良版です。PostgreSQL は POSTGRES の強力なデータ・モデルと豊富なデー
タ・タイプ(型)を保持しながら、POSTGRES で使われた PostQuel 問い合わせ言語を、拡
張した SQL のサブセットに置き換えています。PostgreSQL は無料で完全なソースを利
用できます。

PostgreSQL の開発は、PostgreSQL 開発メーリングリストに参加している開発者達のチ
ームですべて行なわれています。現在の座長は Marc G. Fournier (
scrappy@PostgreSQL.org )です。(下記の1.6節に参加の仕方があります。)現在、このチ
ームが PostgreSQL 開発のすべての面倒をみています。

Postgres95-1.01 の中心的な開発者は Andrew Yu と Jolly Chen でしたが、その他大勢
の人々がこのコードの移植、テスト、デバグ、および、改良に参加しました。
PostgreSQL の派生元コードである POSTGRES はカリフォルニア大学バークレイ校におい
て、 Michael Stonebraker 教授の指揮のもと、多くの学生、卒業生、本職のプログラマ
たちの努力により作られました。

バークレイにおけるこのソフトウェアのもとの名前は Postgres でしたが、SQL の機能
が追加された 1995 年にその名前は Postgres95 に変更され、1996 年の終りにその名前
は PostgreSQL に変更されました。

1.2) PostgreSQL の著作権はどうなってますか？

PostgreSQL は下記の著作権に従います。

    [訳注：
        正文は英語です。参考として、訳文を併記掲載します。
    ]

PostgreSQL Data Base Management System

Portions Copyright (c) 1996-2002, PostgreSQL Global Development Group Portions
Copyright (c) 1994-6 Regents of the University of California

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose, without fee, and without a written agreement is
hereby granted, provided that the above copyright notice and this paragraph and
the following two paragraphs appear in all copies.

IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND
THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE,
SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

        POSTGRESQL データベース管理システム

        部分的著作権 (c) 1996-2002, PostgreSQL国際開発チーム
        部分的著作権 (c) 1994-6 カリフォルニア大学本校


          本ソフトウェアおよびその文書一式は上記の著作権表示と、この文章
        およびこれに続く二つの段落が全ての複製に添付されている限りにおい
        て、使用、複製、修正および配付の許可を、いかなる目的であっも、無
        償でかつ同意書無しに行なえることをここに認めます。
        
          カリフォルニア大学は、いかなる当事者にたいしても、利益の壊失を
        含む、直接的、間接的、特別、偶然あるいは必然的にかかわらず生じた
        損害について、たとえカリフォルニア大学がこれらの損害について訴追
        を受けていたとしても、一切の責任を負いません。
        
          カリフォルニア大学は、商用目的における暗黙の保証と、特定目的で
        の適合性に関してはもとより、これらに限らず、いかなる保証も放棄す
        ることを明言します。以下に用意されたソフトウェアは「そのまま」を
        基本原理とし、カリフォルニア大学はそれを維持、支援、更新、改良あ
        るいは修正する義務を負いません。

    [訳注：
        著作権に関する正文は上記の英語による表記です。日本語訳はあくまで
        参考です。
    ]

上記はBSDライセンスで古きオープンソースのライセンスです。ソースコードがどのよう
に使われようとも制限しません。好ましいことなので、我々もそれを変えるつもりはあ
りません。

1.3) PostgreSQL の動作環境は？

一般的に、最近のUnix互換プラットホームならばPostgreSQLをはしらせられるはずです
。リリースの時点で実際にテストを行なったことの報告がなされたプラットホームにつ
いてはインストール手引書に列挙してあります。

1.4) Unix以外の移植版で使えるものは？

クライアント

MS Windows プラットホーム上で走せるために、libpq C ライブラリ、psql、その他のイ
ンターフェイス、および、クライアントアプリケーションをコンパイルすることは可能
です。この場合、クライアントを MS Windows 上で走らせて、TCP/IP 経由でサポートさ
れている Unix プラットホーム上で走るサーバと通信します。

Win32 libpq ライブラリと psql を作るために、win32.mak が配布に含まれてます。
PostgreSQLは ODBC クライアントとも通信できます。

サーバ

現在、Cygnus Unix/NT 移植ライブラリの Cygwin を使って、PostgreSQL データベース
サーバは Windows NT と Win2k 上で稼働しています。配布に含まれるpgsql/doc/
FAQ_MSWIN、あるいは、 http://www.PostgreSQL.org/docs/faqs/text/FAQ_MSWINにある
MS Windows FAQ をご覧下さい。

MS Win NT/2000/XP ネイティブ版への移植が現在進行中です。もっと詳しいWindows版
PostgreSQLの近況は、http://techdocs.postgresql.org/guides/Windowsと http://
momjian.postgresql.org/main/writings/pgsql/win32.html を見てください。


[訳注：

Win32ネイティーブ版(Win32 Native version)

          Windows-Native サーバー & クライアントパッケージが斉藤さんにより
        維持管理されています。
            http://hp.vector.co.jp/authors/VA023283/PostgreSQL.html
        (Windows-Native Server&Client Package for PostgreSQL by Hiroshi Saito)
            http://hp.vector.co.jp/authors/VA023283/PostgreSQLe.html



]

1.5) PostgreSQL はどこから入手できますか？

PostgreSQL の大元の anonymous ftp サイトは ftp://ftp.PostgreSQL.org/pub/ です。
ミラーサイトについては、我々のメイン Web ページをご覧下さい。

    [訳注:

        以下は日本のミラーサイトです:

       Japan: ftp://mirror.nucba.ac.jp/mirror/PostgreSQL/pub/
       Japan: ftp://ring.ip-kyoto.ad.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.crl.go.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.saitama-u.ac.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.astem.or.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.exp.fujixerox.co.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.jah.ne.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.etl.go.jp.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.asahi-net.or.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.so-net.ne.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.aist.go.jp/pub/misc/db/PostgreSQL/
    ]

1.6) サポートはどこで受けられますか？

主要なメーリング・リストは: pgsql-general@PostgreSQL.orgです。PostgreSQL に関す
ることであれば議論ができます。このリストへの参加のは、電子メールの本文(Subject
行ではありません)に次の２行を書いて、

        subscribe
        end

pgsql-general-request@PostgreSQL.org へ送って下さい。

ダイジェスト版のメーリング・リストもあります。このリストへの参加は "本文"に：

        subscribe
        end

と書いて pgsql-general-digest-request@PostgreSQL.org へ電子メールを送って下さい
。

ダイジェスト版は、メインリストで受信するメッセージが 30k 程度溜る毎にダイジェス
ト版リストのメンバーに送付されます。

バグレポート用のメーリングリストもあります。このリストへの参加は "本文"といっし
ょに： bugs-request@PostgreSQL.org へ電子メールを送って下さい。

開発者の議論のためのメーリングリストも利用できます。このリストへの参加は電子メ
ールの本文に：

        subscribe
        end

と書いて、pgsql-hackers-request@PostgreSQL.orgへ電子メールを送って下さい。

http://www.PostgreSQL.org

EFNet と OpenProjects に #PostgreSQL という IRC チャンネルもあります。 UNIX コ
マンドでirc -c '#PostgreSQL' "$USER" irc.phoenix.net を使っています。

    [訳注:
          1999年7月23日、日本PostgreSQLユーザー会(にほん ぽすとぐれす ゆーざー かい)、略称JPUG
        が設立されました。JPUG は非営利組織で、PostgreSQLを利用する人達の相互協力の場となっています。  
        2003年5月17日の総会を以って、「日本PostgreSQLユーザ会」に名称を改めました。
        正会員の会費は無料ですが、協賛会員の会費と会員の積極的な貢献が会の運営を助けています。
        詳しくは、JPUG のWeb サイト:
                http://www.PostgreSQL.jp/
        をご覧ください。会員登録も可能となっています。
          1990年代中ごろより、ポストグレスの日本語メーリング・リストを石井 達夫さんが主催しています。詳細は、
                http://www.sra.co.jp/people/t-ishii/PostgreSQL/ML/info.html
        をご覧下さい。アーカイブを、いわきりさんのpgsql-jp ML検索システム
                http://datula.mio.org/~iwakiri/pgsql_jp/
        で検索することもできます。
        ]

商用サポート会社のリストはhttp://techdocs.postgresql.org/companies.phpにありま
す。

    [訳注:
         日本では、SRA Inc. オープンシステム事業部 にて商用サポートが行なわれています。
        ミラクル・リナックス株式会社 で "Miracle Linux for PostgreSQL" の販売とサポートが
        開始されました。
    ]

1.7) 最新版はどれですか

PostgreSQL の最新版はバージョン 7.3.4 です。

我々は、6〜8カ月毎にメジャーリリースを行なうことを計画しています。

1.8) どのような文書がありますか？

配付の中に、いくつかのマニュアルとオンライン・マニュアル(マニュアル・ページ)お
よびいくつかの小さなテスト例題が含まれます。/doc ディレクトリをご覧下さい。また
、マニュアルは、http://www.ca.PostgreSQL.org/docs/でオンラインでも閲覧できます
。

    [訳注:
        （株）SRAと日本PostgreSQLユーザ会で翻訳され、
        「PostgreSQL オフィシャルマニュアル」
        として出版されています。
    ]

オンラインで参照できる PostgreSQL の本も2冊あります。http://www.PostgreSQL.org/
docs/awbook.html

    [訳注:
        日本ポストグレスユーザー会の    「PostgreSQL Book翻訳分科会」
        にて翻訳されました。
    ]

および、 http://www.commandprompt.com/ppbook/ です。購入可能な書籍の目録は、
http://techdocs.PostgreSQL.org/techdocs/bookreviews.php にあります。 PostgreSQL
技術情報記事も、http://techdocs.PostgreSQL.org/ にあります。

[訳注: 和訳文書は、日本ポストグレスユーザー会のhttp://www.postgresql.jp/
document/ をごらん下さい。 ]

psql も、型、演算子、関数、集約、その他の情報をお見せする、いくつかの素晴らしい
\d コマンドを持ちます。

我々の Web サイトには、もっと沢山の文書があります。

1.9) 既知のバグや未だ無い機能はどうやって見つけますか？

PostgreSQLは拡張されたSQL-92のサブセットをサポートします。我々のページの TODO
リストに、既知のバグや欠落機能や将来計画についての記述があります。

1.10) SQL はどうすれば学べますか？

http://www.PostgreSQL.org/docs/awbook.html にあるPostgreSQL本で SQL を教えてい
ます。

    [訳注:
        日本ポストグレスユーザー会の    「PostgreSQL Book翻訳分科会」
        にて翻訳され出版されています。
    ]

その他にも PostgreSQL本として、http://www.commandprompt.com/ppbook があります。
素晴らしい手引書は、http://www.intermedia.net/support/sql/sqltut.shtm, http://
ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM, そして、http://
sqlcourse.com にあります。

その他では、 "Teach Yourself SQL in 21 Days, Second Edition" が http://
members.tripod.com/er4ebus/sql/index.htmにあります。

多くのユーザに、 The Practical SQL Handbook, Bowman Judith S. et al.,
Addison-Wesley が好評です。その他に、The Complete Reference SQL, Groff et al.,
McGraw-Hill のようなのもあります。

    [訳注:
         石井達夫氏による日本語の参考文献の紹介ページ
                http://www.SRA.co.jp/people/t-ishii/PostgreSQL/doc-jp/index.html
        があります。
         近藤直文氏の「初心者向のＤＢ設計入門・ＳＱＬ入門参考書紹介」のコーナー
                http://www.shonan.ne.jp/~nkon/ipsql/books_SQL.html
        があります。
         堀田倫英氏の「PostgreSQL日本語マニュアル」
                http://www.net-newbie.com/
        ではオンラインマニュアルの検索ができます。
         丸山不二夫氏のUNIX データベース入門
                http://www.wakhok.ac.jp/DB/DB.html
        もオンラインで読むことができます。
    ]

1.11) PostgreSQLは西暦2000年問題(Y2K)に対応していますか？

対応してます。西暦2000年より後の日付も、紀元前2000年より前の日付も、簡単に扱え
ます。

1.12) 開発チームにはどのように参加しますか？

まず最初(１番目)に、最新のソースをダウンロードし、我々の Web サイトか配布に含ま
れているPostgreSQL Developersの文書を読みます。２番目に、pgsql-hackers と
pgsql-patches メーリング・リストを購読(subscribe)します。３番目に、高品質のパッ
チをpgsql-patchesに発信します。

およそ十人ちょっとの人達が、PostgreSQL CVSアーカイブにコミットする権限を持って
います。そのそれぞれの人達が沢山の高品質なパッチを発信するので、現在コミッター
となっている人達はそれに追い付くのが大変ですが、我々は彼らがコミットしたパッチ
は高品質であると確信しています。

1.13) バグレポートはどのように発信しますか？

http://www.PostgreSQL.org/bugs/bugs.phpPostgreSQL BugTool (バグツール)のページ
を訪れてみて下さい。バグレポートを提出する仕方についての手引と指針があります。

その前に http://PostgreSQL.orgにある最新の FAQ をチェックして下さい。

それと同時に ftp サイト ftp://ftp.PostgreSQL.org/pub/で、もっと新しいバージョン
の PostgreSQL あるいはパッチをさがしてみて下さい。

1.14) 他のDBMSのと比べてPostgreSQLはどうなのですか？

ソフトウェアを計る方法にはいくつかあります。機能と性能と信頼性とサポートと価格
です。

機能(Features)
    PostgreSQLは、トランザクション、副問い合わせ、トリガー、ビュー、外部キー整
    合性参照、および、洗練されたロック機構など、大規模商用DBMSが持つ機能をほと
    んど持っています。さらに PostgreSQLは、ユーザ定義型、継承、ルール、それから
    、ロック競合を縮小するマルチバージョン同時性制御など、商用DBMSも持ち合わせ
    ないような機能をいくつか持ち合わせています。
性能(Performance)
    PostgreSQLは他の商用あるいはオープンソースのデータベースと互角の性能も持ち
    ます。ある面ではより早かったり、ほかの面ではより遅かったりします。MySQLなど
    の特化型データベース・システムにくらべて、PostgreSQLの挿入／更新が遅いのは
    、トランザクションによるオーバーヘッドがあるからです。もちろん、MySQLには上
    記のFeaturesの節に示すような機能はまったくありません。我々は、PostgreSQLに
    柔軟性と機能性を組み込みながらも、絶えず、プロファイラーに掛けたりソースコ
    ードを解析したりして、性能の改善を続けています。PostgreSQL と MySQL とを比
    較している面白い Web ページがhttp://openacs.org/philosophy/
    why-not-mysql.htmlにあります。
    PostgreSQLは、Unixプロセスを起動することによりユーザー接続を操作します。複
    数のバックエンド・プロセスが情報をロックしながらデータ・バッファーを共有し
    ます。マルチCPUでは、簡単に複数のバックエンドをそれぞれのCPUで走らせること
    ができます。
信頼性(Reliability)
    我々は、DBMSの信頼性が高くなくてはその価値が無いことを理解してます。十分テ
    ストして、安定したコードをバグを最小にしてからリリースするように勤めてます
    。それぞれのリリースは少なくとも1カ月以上のベータ・テストを行ない、これまで
    のリリースの履歴が、製品版として安定した堅固なリリースであることを物語って
    います。この分野では、他のデータベースと比べても遜色がないことに自信を持っ
    ています。
サポート(Support)
    我々のメーリングリストは、遭遇するいかなる問題についても解決への手助けをし
    てくれる、開発者やユーザの大きな集まりへの接点を提供しています。我々は問題
    の解決を保証することはできませんが、商用データベースであっても常に解決され
    るわけではありません。開発者や、ユーザ・コミュニティ、マニュアル類、それに
    、ソースコードなどへ直接アクセスできることよって、PostgreSQLのサポートは、
    他のDBMSサポートよりも優れたものとなっています。御要望に答えて、事柄毎の商
    用サポートなどもあります（FAQ1.6節をご覧下さい）。
価格(Price)
    PostgreSQLの利用は、商用でも非商用でも、すべて無料です。上記に示してあるBSD
    スタイルの使用許諾に外れない限り、PostgreSQLのコードを制限無しで商品に組み
    込むことができます。

1.15) PostgreSQLを資金面で援助するにはどうすればよいですか？

PostgreSQLは、我々が始めた 1996年以来、最高クラスの情報基盤を持っています。これ
はすべて、Marc Fournieさんのおかげで、彼はこの基盤を何年にもわたって創造し管理
してきました。

質の良い基盤はオープンソース・プロジェクトにとってはとても大切なもので、前進す
る勢いを失うプロジェクトの分裂を回避します。

もちろん、この基盤は安いものではありません。維持し続けるためには毎月あるいは一
時の経費がかかります。もし、あなたやあなたの会社に、こうした努力のための資金を
助けるために施すことができるようでしたら、https://store.pgsql.com/shopping/から
寄付をお願いします。

また、Webページには PostgreSQL,Inc とありますが、そこの"義援(contributions)"ア
イテムは PostgreSQL プロジェクトをサポートするためだけのためで、決して特定の会
社のための資金のためではありません。もし、手形(check)の方が都合がよければ連絡先
の住所へお送り下さい。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

さらに、もし、PostgreSQLでの成功例をお持ちであれば、ぜひ、われわれの事例サイト 
http://advocacy.postgresql.orgへお送りください。

                         ユーザー・クライアントの質問                          
                                                                               
2.1) PostgreSQL のための ODBC ドライバーはありますか？

PsqlODBC と OpenLink ODBC の二つの ODBC ドライバーが利用可能です。

PsqlODBC は次の場所からダウンロードできます。 http://gborg.postgresql.org/
project/psqlodbc/projdisplay.php

    [訳注:
        最新版は井上博司さんのサイトにあります。
        ●http://w2422.nsk.ne.jp/~inoue/indexj.html
    ]

OpenLink ODBC は http://www.openlinksw.com/から入手できます。標準的な ODBC クラ
イアント・ソフトウェアで使えますので、支援しているすべてのプラットホーム(Win,
Mac, Unix, VMS)から PostgreSQL の ODBC が利用できます。

たぶん彼らは、商用品質のサポートの必要な人々に売っていると思いますが、フリーウ
ェア版はいつでも入手可能のようです。質問は、postgres95@openlink.co.uk へ送って
下さい。

Programmer's Guide の ODBC の章もご覧ください。

2.2) PostgreSQL を Web ページと連携させるにはどんなツールがありますか？

データベースを裏に持つ Web ページについての素晴らしい紹介が、
http://www.webreview.comにあります。

Web への拡張のためには、PHP が卓越したインターフェイスとなっています。http://
www.php.net/にあります。

    [訳注:
          PHPに関する日本語の情報は、2000年4月19日に発足した日本PHPユーザ会のサイト
                http://www.php.gr.jp/
        あるいは、廣川 類さんのサイト
                http://www.geocities.jp/rui_hirokawa/php/
        にかなりまとめられています。
    ]

処理が複雑な場合、多くの人は Perl インターフェイスと CGI.pm か mod_perl を使い
ます。

    [訳注:
        WDB は、Web から DataBase への Perl の Interface です。
        wdb-p95 へのリンクは切れてしまっています。おそらく、Perl DBI 経由で DBD::Pg の利用が可能と思われます。
        現在、WDBI という名前になっているもの
                http://www.egroups.com/list/wdb-users/
        と、WDBの名前のままのもの
                http://www.i-con.dk/wdb/
        とがあります。その経緯はよくわかりません。
    ]

2.3) PostgreSQL にグラフィカル・ユーザインターフェイスはありますか？

もちろん、PostgreSQL へのグラフィカルインターフェイスがいくつかあります。その中
にPgAccess http://www.pgaccess.com も含まれます。 PgAdmin II (http://
www.pgadmin.org Win32-only)もあります。 RHDB Admin (http://sources.redhat.com/
rhdb/ )と Rekall ( http://www.thekompany.com/products/rekall/, proprietary)もあ
ります。 PHPPgAdmin ( http://phppgadmin.sourceforge.net/ ) はPostgreSQLへのWeb
ベースのインターフェイスを提供します。

PgAccess と呼ばれる素晴らしいグラフィカル・ユーザ・インターフェイスがあり、この
配布と共に出荷されます。PgAccess にはレポート・ジェネレータもあります。Web ペー
ジはhttp://www.pgaccess.org/です。

より詳細なリストについては、http://techdocs.postgresql.org/guides/GUITools をご
覧ください。

2.4) どのような言語で PostgreSQL と通信できすか？

人気のあるほとんどの言語はPostgreSQLへのインターフェイスを持っています。あなた
が使うプログラミング言語の拡張モジュールのリストを覗いてみてください。

以下のインターフェイスはPostgreSQLの配布に含まれています。

 ・ C (libpq, libpgeasy)
 ・ 埋め込みC (ecpg)
 ・ Java (jdbc)
 ・ Python (PyGreSQL)
 ・ TCL (libpgtcl)

その他の利用可能なインターフェイスは http://www.PostgreSQL.org/interfaces.html
および、 http://gborg.postgresql.org のDrivers/Interfacesのセクションにあります
。

    [訳注：
        永安悟史さんは Palm 版の libpq を開発されました。
                http://www.snaga.org/libpq/
    ]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

                                 管理上の質問                                  
                                                                               
3.1) どのようにすれば /usr/local/pgsql 以外の場所にインストールできますか？

簡単な方法は、 configure を走らせるときに --prefix オプションを指定することです
。

3.2) postmaster を走らせると、Bad System Call とかコア・ダンプしたとのメッセー
ジが出ます。なぜですか？

さまざまな問題が考えられますが、まず最初にあなたのカーネルに System V IPC の拡
張がインストールされているかを確認して見てください。PostgreSQL はカーネルによる
共有メモリーとセマフォのサポートを必要とします。

3.3) postmaster を走らせようとすると、IpcMemoryCreate エラーが出ます。なぜです
か？

カーネルが共有メモリーを持つ設定になっていなかったか、でなければ、カーネルに対
して使える共有メモリーの大きさを大きく設定する必要があります。具体的な大きさは
、使っているアーキテクチャとpostmaster を走らせるときに設定するバッファの数とバ
ックエンドプロセスに依存します。ほとんどのシステムでは、既定値のバッファサイズ
のままで、少なくとも約1MBが必要です。 PostgreSQL Administrator's Gide に共有メ
モリーとセマフォについての情報の詳細がありますのでご覧ください。

3.4) postmasterを走らせようとすると、IpcSemaphoreCreate エラーが出ます。なぜで
すか？

もしエラーメッセージがIpcSemaphoreCreate: semget failed (No space left on
device)であれば、カーネルが十分なセマフォを使えるように構成されていません。
Postgresは潜在的なバックエンドプロセス毎に一つのセマフォを必要とします。とりあ
えずの解決策はpostmasterを起動するときに、バックエンドプロセスの数をより少なく
制限をすることです。既定値の32より小さな数のパラメータを-Nで使います。より恒久
的な解決策は、カーネルのSEMMNS と SEMMNI パラメータを増やすことです。

操作不能のセマフォも過度なデータベースアクセスの間にクラッシュを起こす可能性が
あります。

もし、エラーメッセージがなにか他のものであれば、カーネルの構成でまったくセマフ
ォのサポートをしていないかもしれません。 PostgreSQL Administrator's Gide に共有
メモリーとセマフォについての情報の詳細があります。

3.5) 他のホストからの接続はどのように制御しますか？

既定値では、PostgreSQL は unix ドメインソケットを使うローカルマシンからの接続し
か許しません。postmaster 起動に -i フラッグを加え、$PGDATA/pg_hba.conf ファイル
を適切に直して、ホスト主導型の認証を使わないかぎりは他のマシンからは接続できな
いでしょう。これによりTCP/IPの接続が可能になります。

操作不能なセマフォも過度のデータベースアクセス中にクラッシュを引き起こすことが
あります。

3.6) より良い性能を得るためには、データベース・エンジンをどのように調整すれば良
いですか？

確かにインデックスは問い合わせの速度を増します。EXPLAINコマンドで PostgreSQL が
どのようにあなたの問い合わせを翻訳しているかを見ることができ、そして、どのイン
デックスが使われているかを見ることができます。

もし INSERT を多用している場合は、COPY コマンドを使って大きなバッチ処理でそれを
行なうことを検討して下さい。これは、INSERT を別々に行なうよりもっと高速です。次
に、BEGIN WORK/COMMIT のトランザクション・ブロックの中に無い文は、それら自身が
それぞれのトランザクションに入っていると見なされます。いくつかの文を一つのトラ
ンザクション・ブロックの中で行なうことを考えて下さい。これによりトランザクショ
ンのオーバーヘッドが減ります。また、大きなデータの変更を行なう際はインデックス
を一度外して、作り直すことを考えてみて下さい。

チューニングのオプションがいくつかあります。postmaster を -o -F オプションで起
動することによって、fsync() を無効にすることができます。これによって、各トラン
ザクション毎に fsync() でディスクを更新するのを止めさせます。

postmaster -B オプションを使ってバックエンド・プロセスにより使われる共有メモリ
ー・バッファを大きくすることもできます。もし、このパラメータを高くしすぎると、
カーネルの共有メモリー空間の制限値を越えてしまっうために postmaster が走らなく
なるでしょう。既定値では、それぞれのバッファの大きさは 8K で、バッファ数は 64
です。

バックエンドを -S オプションを使って、それぞれのバックエンド・プロセスが一時的
な並べ替えによって使うメモリーの最大サイズを増やすこともできます。その -S の値
はキロバイト単位で、既定値は 512 (すなわち、512K)です。

また、CLUSTER コマンドを使って、テーブルのデータをインデックスに合わせるために
グループ化することもできます。詳しくは、オンラインマニュアルで CLUSTER を見て下
さい。

3.7) どのようなデバグ機能が使えますか？

PostgreSQL は、デバグのために意味のある、状態情報を報告するいくつかの機能を持ち
ます。

まず、--enable-cassert オプションで configure を走らせます。そうしてコンパイル
することにより、沢山の assert() が、バックエンドの進捗状況を監視し、何か予期せ
ぬことが起きるとプログラムを停止するようになります。

postmaster と postgres の両方でいくつかのデバグ・オプションの利用ができます。ま
ず、次のように postmaster を起動するときはいつでも、標準出力とエラー出力をログ
・ファイルに送るようにしてあることを確かめて下さい。

        cd /usr/local/pgsql
        ./bin/postmaster >server.log 2>&1 &

これにより PostgreSQL の最上部のディレクトリに server.log ファイルが置かれます
。このファイルはサーバーが遭遇した問題やエラーについて有用な情報を含みます。
Postmaster は更に詳細な情報を報告するための -d オプションを持ちます。その -d オ
プションは、デバグ・レベルを指定します。高いデバグ・レベルでは、大きなログファ
イルを生成することに注意しなくてはなりません。

もし、postmasterが走っていなければ、postgresバックエンドをコマンド行から走らせ
ることができ、直接SQL文をタイプすることができます。このやりかたは、デバグ目的の
ときだけお奨めします。セミコロンではなく、改行が問い合わせの終りになることに注
意してください。もし、デバグシンボルを入れてコンパイルしていれば、デバッガを使
って何が起きているかを見ることができます。postmaster からバックエンドを開始した
わけではないので、独立な環境で走っているのではなくロック／バックエンドとの対話
の問題が重複することはありません。

もし、postmasterが走っていれば、あるウィンドウで psqlを開始すると、psql で使わ
れる postgres プロセスのPIDが見つかります。デバッガを使って postgresのPIDにアタ
ッチ(attach)します。デバッガの中からブレーク・ポイントをセットし、psql から問い
合わせを発行します。デバグのためにpostgresを始動する場合は、PGOPTIONS="-W n" を
設定でき、それから、psql を開始します。これにより、n 秒開始を遅らせるはずなので
、デバッガでプロセスにアタッチして、ブレークポイントを設定し、開始から順を追っ
て見てゆくことができます。

PostgreSQL プログラムには、デバグと性能測定にとても役に立つ -sや -Aや -t 等のオ
プションがあります。

何という関数がどのくらい実行時間を食っているかを見るために、プロファイリング（
プロフィール付き）でコンパイルすることも可能です。そのバックエンドのプロフィー
ル・ファイルは pgsql/data/base/dbname ディレクトリに格納されるでしょう。クライ
アントのプロフィールはクライアントの現行ディレクトリに置かれるでしょう。Linux
でまともなプロファイリングを行うには -DLINUX_PROFILE でコンパイルする必要があり
ます。

3.8) 接続しようとするときに 'Sorry, too many clients' が出るのはなぜですか？

postmasterが同時始動できるバックエンドプロセスに対する制限数を増やす必要があり
ます。

既定の最大プロセスは32プロセスです。-Nに適切な値を引数にしてpostmasterを再起動
するか、PostgreSQL.conf を修正することによって、その値を増やすことができます。
。既定の構成では-Nは最大1024まで設定できます。もし、もっと必要であればinclude/
config.hの中のMAXBACKENDSを増加させ、再構築します。もし、望むならconfigureの
--with-maxbackends切替を使って、-Nの既定値を構成時に設定できます。

もし、-N を 32よりも大きくするのであれば、-Bも既定の64より大きい値に増加させな
くてはならないし、-B は少なくとも -N の2倍はなくてはならず、おそらく最高性能を
望むならばそれより大きい値が必要なはずです。バックエンドプロセスをたくさんにす
ると、いろいろなUnixカーネル構成パラメータも増やすことが必要になるかもしれませ
ん。共有メモリー・ブロックの最大値(SHMMAX)、セマフォの最大数(SEMMNSとSEMMNI)、
プロセスの最大数(NPROC)、ユーザ毎の最大プロセス数(MAXUPRC)、開くファイルの最大
数(NFILEとNINODE も確認事項に含まれます。 PostgreSQLに許されるバックエンドのプ
ロセス数が制限されているのは、システムのリソースを使い果してしまうことを避ける
ためです。

3.9) pgsql_tmp ディレクトリの中には何がありますか？

問い合わせ実行モジュールによって生成された一時的なファイルが、このディレクトリ
に含まれます。例えば、もし ORDER BY 句を満たすためにバックエンドの -S パラメー
タで許可した値よりも大きなスペースがソートの際に必要だとすると、溢れたデータを
保持するために一時的なファイルがいくつかここに生成されます。

一時的なファイルは自動的に消し去られるはずですが、もし、ソートの途中でバックエ
ンドがクラッシュしてしまうとそうはなりません。postmasterの停止とリスタートでこ
れらのファイルはディレクトリから消しさられます。

    [訳注：
         SYSLOGD 経由でログを出力するには、まず、configure を --enable-syslog 
        付きで走らせた後、コンパイルとインストールを行ないます。
         次に、syslog.conf に local?.* の 出力先を指定し(環境変数で変更可能)、
        syslogd に HUP シグナルを送って初期化しておきます。そして、
        $PGDATA/pg_options に syslog=2 を加えて、 postmaster を -S 
        オプション付きにてサーバモードで起動します。(バージョン 7.1 からは 
        pg_options は PostgreSQL.conf になっています。)
    ]

3.10) PostgreSQLのメジャーリリースをアップデートするのにダンプとリストアをしな
くてはならないのはなぜですか？

PostgreSQLチームはマイナーリリースでは小さな変更しか行ないませんので、7.2 から
7.2.1 へのアップグレードにはダンプとリストアの必要はありません。しかし、メジャ
ーリリース(たとえば、7.2から7.3へのような)では、システムテーブルやデータファイ
ルの内部フォーマットの変更をしばしば行ないます。これらの変更はたいてい複雑で、
そのため我々はデータファイルのための後方互換性を維持することができません。ダン
プは汎用フォーマットでデータを出力し、それを新しい内部フォーマットに読み込むこ
とができます。

同一リリースではディスク上でのフォーマットに変更はないので、アップグレードには
ダンプ／リストアではなく、pg_upgrade スクリプトを使うことができます。リリースノ
ートには、pg_upgrade が利用可能なリリースかどうか記されています。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

                                 操作上の質問                                  
                                                                               
4.1) バイナリ・カーソルと通常カーソルとの厳密な違いは何ですか？

詳述は、オンラインマニュアルで DECLARE を見て下さい。

4.2) 最初の数ロウのみを SELECTするにはどうしますか？ランダムな行？

オンラインマニュアルでFETCHを見てください。あるいは、SELECT ... LIMIT....を使っ
てみて下さい。

たとえ、欲しいのは最初の数ロウだけでも、すべての問い合わせを評価しなくてはなら
ないかもしれません。ORDER BY を持った問い合わせを使うことを考えてみて下さい。も
し、ORDER BYに合ったインデックスがあるとすると PostgreSQLは要求された最初の数ロ
ウだけで評価できるかもしれませんが、でなれば、PostgreSQL は意図したロウが生成さ
れるまですべてのロウを評価しなければならないかもしれません。

ランダムな行をSELECTするには、次の文を使います：

    SELECT col
    FROM tab
    ORDER BY random()
    LIMIT 1;

4.3) テーブルやその他の情報のリストを psql で見るにはどうしますか？

psqlのソースコードとして書かれた pgsql/src/bin/psql/describe.c ファイルを読むこ
とがその答えです。そこには、psqlのバックスラッシュコマンドによる出力のためのSQL
コマンドが含まれています。 psql に -E オプションをつけて起動すれば、与えたコマ
ンドを実行するための問い合わせが出力されます。

4.4) テーブルからカラムの削除、あるいは、データ型を変更するにはどうしますか？

DROP COLUMN機能が、ALTER TABLE DROP COLUMN としてリリース7.3 に加えられました。
それまでのバージョンでは、その代わりにこうします:

        BEGIN;
        LOCK TABLE old_table;
        SELECT ...  -- 削除したいカラム以外のカラムをすべて選択します。
        INTO TABLE new_table
        FROM old_table;
        DROP TABLE old_table;
        ALTER TABLE new_table RENAME TO old_table;
        COMMIT;

カラムのデータタイプは次の文で変えられます：

    BEGIN;
    ALTER TABLE tab ADD COLUMN new_col new_data_type;
    UPDATE tab SET new_col = CAST(old_col AS new_data_type);
    ALTER TABLE DROP tab COLUMN old_col;
    COMMIT;

これを行なったときは、抹消された行が使っているディスク空間を回収するために
VACUUM FULL tabをしたほうが良いかもしれません。

4.5) ロウ、テーブル、データベースの最大サイズは？

制限は以下のとおりです。

データベースの最大サイズ?       制限無し (4 TB のデータベースも存在します)
テーブルの最大サイズ?           32TB
ロウの最大サイズ?               1.6TB
フィールドの最大サイズ?         1GB
テーブル内での最大ロウ数?       制限無し
テーブル内での最大カラム数?     カラムの型により250-1600
テーブル内での最大インデクス数? 制限無し

もちろん、これらは実際は無制限ではなく、ディスク容量とメモリーやスワップスペー
スの大きさにより制限されます。性能はこれらの値がことのほか大きな時に煽りを受け
ます。

最大テーブルサイズの32TBはオペレーティングシステムによる巨大ファイルのサポート
は必要としません。巨大なテーブルは複数の1GBのファイルに分けて保存されますので、
ファイルシステムの制限は重要ではありません。

デフォルトのブロックサイズを32kにすることで、最大テーブルサイズと最大カラム数と
が４倍させることができます。

4.6) 一般的なテキストファイルからデータを保存するには、データベースのディスク容
量はどのくらい必要です？

普通のテキストファイルを PostgreSQL のデータベースに保存するには、最大で約5倍の
ディスク容量を必要とします。

例題として、各行に整数とテキスト記述を持つ 100,000行のファイルを考えてみましょ
う。テキストの文字列の平均長さを20バイトと仮定すると、フラットファイルの大きさ
は約2.8MB です。このデータを含む PostgreSQL データベースファイルの大きさは次の
ように約6.4MBと見積もることができます：

    36 bytes: 各ロウのヘッダ(概算)
    24 bytes: 整数(int)フィールドとテキスト(text)フィールド
   + 4 bytes: ページ上のタップルへのポインタ
   ----------------------------------------
   64 bytes per row

   PostgreSQL のデータページサイズは 8192バイト(8KB)なので:

   8192 bytes per page
   -------------------   =  128 rows per database page (切り上げ)
     64 bytes per row

   100000 data rows
   --------------------  =  782 database pages
      128 rows per page
 
782 database pages * 8192 bytes per page  =  6,406,144 bytes (6.4 MB)

インデックスは、これほどのオーバヘッドは要求しませんが、インデックス付けされる
データを含む以上、それなりに大きくなります。

NULLはビットマップに保存されていて、それらがわずかにスペースを使います。

4.7) 定義されたテーブル、インデックス、データベース、および、ユーザをどのように
して見つけ出しますか？

psql にはいろいろなバックスラッシュ・コマンドがあり、こうした情報を表示します。
バックスラッシュ・コマンドの種類を見るには \? を使って下さい。

また、pgsql/src/tutorial/syscat.source ファイルを走らせてみて下さい。それは、沢
山の SELECT 文により必要な情報をデータベースのシステム・テーブルから取り出して
例示してくれます。また、pg_ で始まるシステムテーブルにも記述されています。さら
に、psql -l はすべてのデータベースをリスト表示します。

4.8) 問い合わせが遅いうえ、インデックスを使っている様子がありません。なぜですか
？

インデックスは自動的にすべての問い合わせで使われるわけではありません。テーブル
が最小サイズより大きく、問い合わせでそのわずかなパーセンテージのロウを選択する
時だけ、インデックスは使われます。これはインデックススキャンにより起こされるラ
ンダムなディスクアクセスは、テーブルをストレートに読む順次走査よりも遅くなるこ
とがあるからです。

インデックスを使うかを決定するために、PostgreSQL はテーブルについての統計情報を
持たなければなりません。この統計情報は、VACUUM ANALYZEまたは、単に ANALYZE を使
って収集することができます。統計情報を使ってオブティマイザはテーブルの中にある
ロウ数を知り、インデックスを使うべきかのの決定をより正しくできます。統計情報は
最適な結合順や結合方法を決める上でも貴重なものもあります。統計情報の収集は、テ
ーブルの内容がかわると毎に繰返しなされるべきです。

インデックスは、通常 ORDER BY や結合を行なうためには使われません。順次スキャン
に続く明示的ソートは、巨大なテーブルのインデックススキャンよりも普通は高速です
。

しかし、ORDER BYと組み合わされたLIMIT は、テーブルの小さな部分を返すためにたび
たびインデックスを使うでしょう。実際、MAX() や MIN() がインデックスを使わないと
しても、このような値を ORDER BY と LIMIT を使ってインデックスを使って取り出すこ
とが可能です:

    SELECT col
    FROM tab
    ORDER BY col [ DESC ]
    LIMIT 1;

もし、オプティマイザが間違ってシーケンシャルスキャンを選択したことに疑いがなけ
れば、SET enable_seqscan TO 'off'を使ってインデクススキャンでまちがいなく速くな
っているかをテストをしてみてください。

LIKE あるいは ~ のようなワイルドカード演算子は特別な環境でしか使えません：

 ・ 検索文字列が文字列の最初にききます。たとえば：
     □ LIKE パターンが%で始まらない
     □ ~ (正規表現) パターンは^で始まらなければならない
 ・ 検索文字列を文字クラスから始めることはできません。たとえば、[a-e]。
 ・ ILIKE や ~* のような大文字と小文字を区別しない検索は使えません。そのかわり
    、このFAQの4.12節で説明する関数のインデックスが使えます。
 ・ initdb においては、デフォルトでCロケールが使われなくてはなりません。

[訳注：強制的にインデックスを使うには SET enable_seqscan = off を実行します。 ]

4.9) 問い合わせオブティマイザがどのように問い合わせを評価するのかを見るにはどう
しますか？

オンラインマニュアルで EXPLAIN を見て下さい。

4.10) R-tree インデックスとは何ですか？

R-tree インデックスは空間的なデータにインデックスを付けるために使われます。ハッ
シュインデックスでは範囲の検索ができません。また、B-tree インデックスでは、１次
元でしか範囲の検索ができません。R-tree インデックスであれば多次元のデータを扱え
ます。たとえば、もし R-tree インデックスを point 型の属性に付けることができると
するとシステムは、「長方形に囲まれた点をすべて選択する」というような問い合わせ
に、より効率良く答えられます。

R-Tree の設計の原典となる権威ある論文は:

Guttman, A. "R-Trees: A Dynamic Index Structure for Spatial Searching."
Proceedings of the 1984 ACM SIGMOD Int'l Conf on Mgmt of Data, 45-57.

この論文は、Stonebraker 教授の "Readings in Database Systems" でも取り上げられ
ています。

    [訳注：
          奈良先端大の石川佳治さんよりR-Tree関係の文献を紹介して頂きました。
        日本語 Postgres ML のアーカイブから "Subject: [postgres95 801] spatial data structures" 
                http://www.sra.co.jp/people/t-ishii/PostgreSQL/mhonarc/pgsql-jp/1996Oct/msg00007.html
        をご覧下さい。
    ]

組込みの R-Tree でポリゴンやボックスを操作できます。理論的にはR-Tree はもっと高
い次元を操作するようにも拡張できます。実質的には、R-Tree の拡張にはちょっとした
作業が必要でして、現在、我々はそれをどのようにするかについての文書を持っていま
せん。

    [訳注：
          インターウィズの片岡さんが多次元幾何オブジェクトへの拡張作業中です。詳しくは、
        http://www.interwiz.koganei.tokyo.jp/software/geometric/index.html
        をご覧ください。
    ]

4.11) 遺伝的問い合わせ最適化とは何ですか？

GEQO モジュールは、沢山のテーブルを結合するときに、遺伝的アルゴリズム(GA)で問合
わせを高速化します。これにより、しらみつぶしに探索を行なわなくても、大きな結合
(join queries)を扱うことができるようになります。

4.12) 正規表現での検索や大文字と小文字とを区別しない正規表現検索はどのように実
現しますか？大文字と小文字とを区別しない検索のためのインデックスはどのように使
いますか？

~演算子は正規表現照合を行ない、~* は大文字と小文字を区別しない
(case-insensitive)正規表現照合を行います。大文字と小文字を区別しない LIKE 演算
子を ILIKE といいます。

大文字と小文字を区別しない等値比較次のように表現できる：

    SELECT *
    FROM tab
    WHERE lower(col) = 'abc';

標準インデックスでは使われず、しかしながら、もし関数インデックスを作ったならそ
れが使われるでしょう。

   CREATE INDEX tabindex ON tab (lower(col));
   

        WHERE lower(textfield) LIKE lower(pattern)

4.13) 問い合わせの中で、フィールドが NULL であることを検出するにはどうしますか
？

カラムを IS NULL と IS NOT NULL とで試してみます。

4.14) 様々な文字型のそれぞれの違いは何ですか？

Type            Internal Name   Notes
--------------------------------------------------
CHAR(n)         bpchar          指定された固定長となるように空白が詰められる
"char"          char            １文字
VARCHAR(n)      varchar         最大長のサイズを指定する、詰め物無し
TEXT            text            長さに上限の無いテキスト
BYTEA           bytea           可変長のバイト配列(null-byte safe)

内部名にお目にかかるのは、システム・カタログを調べるときや、エラーメッセージを
受け取るときです。

上記の型のうち最初の４つの型は "varlena" 型です(すなわち、ディスクの最初の４バ
イトがデータ長で、それの後に実際のデータが続きます)。このように実際の空間は宣言
された大きさよりも少し大きくなります。しかし、これらのデータ型はTOASTにより圧縮
されたり複数ロウに渡って保存されたりして、ディスク上の空間は思ったより小さくな
ります。

VARCHAR(n) は可変長の文字列を保存するのに最適ですが、保存できる文字列の長さに制
限があります。TEXT は長さに制限の無い文字列の保存ためのもので、最大で 1ギガバイ
トです。 CHAR(n)は、VARCHAR(n)が与えられた文字だけを保存するのに対し、ブランク
を詰め込んでいつも同じ長さで文字列を保存するのに最適です。BYTEAは、部分的にNULL
のバイトを含むバイナリデータを保存するためのものです。これらのタイプは同じくら
いの性能特性ををもちます。

4.15.1) 通番(serial)／自動増分フィールドはどのようにつくりますか？

PostgreSQL は SERIAL データ型をサポートします。カラム上に通番とインデックスを自
動作成します。たとえば、

        CREATE TABLE person ( 
                id   SERIAL, 
                name TEXT 
        );

は自動的に次のように翻訳されます:

        CREATE SEQUENCE person_id_seq;
        CREATE TABLE person ( 
                id   INT4 NOT NULL DEFAULT nextval('person_id_seq'),
                name TEXT 
        );
        CREATE UNIQUE INDEX person_id_key ON person ( id );

    [訳注：
        CREATE UNIQUE INDEX person_id_key ON person ( id );
        は、 7.3 からは自動的には行なわれなくなりました。
    ]

通番についてのもっと詳しい情報は、オンラインマニュアルで create_sequence をご覧
下さい。

また、各ロウのOIDフィールドを一意値として使うこともできます。しかしながら、もし
もデータベースをダンプしてりロードする必要がある場合は、OIDを温存するために
pg_dump で -oオプションを使うか、または、COPY WITH OIDSオプションを使う必要があ
ります。 Bruce Momjian の(http://www.PostgreSQL.org/docs/aw_pgsql_book)の
Numbering Rowsの章にありあます。

4.15.2) SERIALデータ型に挿入される値は、どうすれば得られますか？

ひとつの方法は、nextval() 関数を使ってその値を挿入する前(before)に SEQUENCE オ
ブジェクトから次の SERIAL 値を取り出し、それから実際に挿入をすることです。
4.15.1 のテーブルの例を使うとすると、疑似言語ではこのようになります。

        new_id = execute("SELECT nextval('person_id_seq')");
        execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");

そうして、new_id に保存した新しい値を他の問い合わせに(たとえば、person テーブル
に対する外部キー(foreign key)のように)使うとよいでしょう。自動的に作られた
SEQUENCEオブジェクトの名前は、<table>_<serialcolumn>_seq のようになり、このうち
、table と serialcolumn はそれぞれテーブルの名前とSERIALカラムの名前です。

あるいは、与えられたSERIAL値を、それが既定値として挿入された後で(after)、
currval() 関数を使って取り出すこともできます。たとえば、

        execute("INSERT INTO person (name) VALUES ('Blaise Pascal')");
        new_id = execute("SELECT currval('person_id_seq')");

最後に、INSERT文から返るOIDを使って、既定値をみつけることもできますが、しかし、
oidの値は40億に達するともとに戻ってしまい、最も移植性の低いやり方となるでしょう
。PerlのDBIで Edmund Mergl の作った DBD::Pg モジュールを使えば、$sth->execute()
の後に $sth->{pg_oid_status} を経由してその OID 値を使えるようにすることはでき
ます。

4.15.3) 他のユーザとの競合状態を避けるためには、currval() と nextval() は使わな
いほうがよいのでしょうか？

それはありません。currval() は、すべてのユーザではありませんが、あなたのバック
エンドに与えられた現在の値を返します。

4.15.4) トランザクションが中断したときにもういちどシーケンス番号が使われないの
はなぜですか？シーケンス／SERIALカラムに空きがあるのはなぜですか？

同時性を改善するために、実行中のトランザクションに、必要でトランザクションが終
了するまでロックされないシーケンス値を与えています。このためトランザクションが
中断されると番号割り当てにギャップを生じます。

4.16) OID とは何ですか？ TID とは何ですか？

OID とは一意のロウID に対する PostgreSQL の答えです。PostgreSQL の中でつくられ
るすべてのロウは一意の OID を得ます。initdb で発生される OID はすべて 16384
(include/access/transam.h から)より小さな値です。initdb 後のすべての OID (ユー
ザ作成)はそれ以上の値になります。既定では、これらすべての OIDは一つのデーブルや
データベース内に留まらず、PostgreSQL インストレーション全体の中で一意です。

PostgreSQL はテーブル間のロウを結びつけるために、そのシステムテーブル内に OID
を使います。この OID は特定のユーザのロウを識別するためや結合の中で使われること
ができます。OID の値を保存するためには OID 型をカラムに使うことを奨めます。より
速くアクセスするために OID フィールドにインデックスを作ることができます。 OID
は、全てのデータベースで使われる中央領域から、全ての新しいロウに割り当てられま
す。OID を他の何かに変えたい、あるいは元の OID もテーブルと一緒にコピーしたいの
なら、できなくはありません。

        CREATE TABLE new (old_oid oid, mycol int);
        SELECT old_oid, mycol INTO new FROM old;
        COPY new TO '/tmp/pgtable';
        DELETE FROM new;
        COPY new WITH OIDS FROM '/tmp/pgtable';


OID は、4バイトの整数として保存されているので、40億を越えると溢れてしまうでしょ
う。誰もこれが起きたと報告してくる人はいませんでしたが、そうなる前にこの制限を
取り除くことを計画しています。

TID は特定の物理ロウをそのブロックとオフセット値で識別するために使われます。TID
はロウが修正されたり再ロードされると変わります。それらの TID は、物理ロウを指す
ためにインデックス記載で使われます。

4.17) PostgreSQL で使われるいくつかの用語の意味は何ですか？

いくつかのソースコードや古い文書の中には、それぞの専門分野の中でもっと一般的に
使われる専門用語が使われています。

 ・ テーブル(table)、関係(relation)、クラス(class)
 ・ ロウ(row)、レコード(record)、タップル(tuple)
 ・ カラム(column)、フィールド(field)、属性(attribute)
 ・ 取得(retrieve)、選択(select)
 ・ 置換(replace)、更新(update)
 ・ 追加(append)、挿入(insert)
 ・ OID, 連番(serial value)
 ・ ポータル(portal), カーソル(cursor)
 ・ 領域変数(range variable)、テーブル名(table name)、テーブル別名(table alias)

一般的なデータベース用語のリストは：http://hea-www.harvard.edu/MST/simul/
software/docs/pkgs/pgsql/glossary/glossary.html で見つけられます。

4.18) エラーメッセージ "ERROR: Memory exhausted in AllocSetAlloc()"が出るのはな
ぜですか？

おそらく、システムの仮想メモリーを全て使い果たしてしまっている可能性があるか、
カーネルがあるリソースについてもつ制限値が低すぎる可能性があります。 postmaster
を始動する前にこれを試してみて下さい：

        ulimit -d 262144
        limit datasize 256m

シェルによって、どちらかひとつが成功するでしょうが、これはプロセスのデータセグ
メント制限をより高く設定し、たぶん問い合わせが完結するようになるでしょう。この
コマンドは現行のプロセスと、このコマンドを走らせた後に作られる全てのサブプロセ
スについて適用されます。バックエンドがとても多くのデータを返すためにSQL クライ
アントで問題が続いているのであれば、クライアントを開始する前にこれを試してみて
ください。

4.19) どのバージョンの PostgreSQL を走らせているかを調べるにはどうしますか？

psql から SELECT version(); をタイプします。

4.20) ラージ・オブジェクトの操作でinvalid large obj descriptor を受け取りました
。なぜでしょうか？

ラージ・オブジェクト操作をするときは、前後にBEGIN WORKとCOMMITを付ける必要があ
ります。すなわち、lo_open ... lo_closeをはさみ込みます。

現在は、PostgreSQLのトランザクションのコミット時にラージ・オブジェクト・ハンド
ルを閉じることにより、lo_openコマンドが完了した直後に強制的にルールを実行します
。このため、最初にハンドルに対して何かをしようとすると、invalid large obj
descriptor(ラージ・オブジェクトの記述子が不正)となります。それで、もし、トラン
ザクションを使うのを忘れると、（少なくともほとんどの時間）働いていたコードがエ
ラーメッセージを出すのです。

もし、ODBCのようなクライアントインターフェイスをお使いなら、auto-commit offを設
定する必要があるかもしれません。

4.21) 現在の時刻がデフォルトとなるようなカラムはどのようにつくりますか？

CURRENT_TIMESTAMPを使います:

        CREATE TABLE test (x int, modtime timestamp DEFAULT >CURRENT_TIMESTAMP );

4.22) なぜ、INを使う副問い合わせがとても遅いのですか？

現在、外部問い合わせの各ロウについて副問い合わせの結果を順番にスキャンすること
により、副問い合わせを外部問い合わせに結合しています。もし、副問い合わせが数行
しか返さず、外部問い合わせが沢山の行を返すなら、当面はINをEXISTSで置き換えるこ
とです：

        SELECT *
        FROM tab
        WHERE col1 IN (SELECT subcol FROM subtab)

を、置き換えて：

        SELECT *
        FROM tab
        WHERE EXISTS (SELECT subcol FROM subtab WHERE subcol = col)

とします。これが手っ取り早いですが、subcolは索引付きカラムであるべきです。ここ
で示した問題は7.4で修正されます。

4.23) 外部結合(outer join)はどのように実現しますか?

PostgreSQL は SQL 標準構文を使う外部結合(アウタージョイン)をサポートします。こ
こに 2つの例題があります。

        SELECT *
        FROM t1 LEFT OUTER JOIN t2 ON (t1.col = t2.col);

あるいは

        SELECT *
        FROM t1 LEFT OUTER JOIN t2 USING (col);

これらの象徴的な問い合わせでは t1.col を t2.col と結合して、t1 の結合されなかっ
たロウ(t2 と一致しなかったロウ)も返しています。RIGHT 結合は t2 の結合されなかっ
たロウを加えるでしょう。FULL 結合は、一致したロウに t1 と t2 からは結合されなか
ったロウを返すでしょう。OUTER という言葉はオプションで LEFT, RIGHT, または FULL
などの結合を仮定されています。以前のリリースでは外部結合(outer join)をUNION と
NOT IN を使ってシミュレートできます。たとえば、tab1 と tab2 を結合するときは、
次の問い合わせで二つのテーブルを外部結合します。

        SELECT tab1.col1, tab2.col2
        FROM tab1, tab2
        WHERE tab1.col1 = tab2.col1
        UNION ALL
        SELECT tab1.col1, NULL
        FROM tab1
        WHERE tab1.col1 NOT IN (SELECT tab2.col1 FROM tab2)
        ORDER BY col1

4.24) 複数のデータベースを使う問い合わせはどのようにすればできますか？

現行のデータベース以外への問い合わせ方法はありません。というのもPostgreSQLがデ
ータベース仕様のシステムカタログを読み込むためで、そこには、たとえそのふりをす
るだけにしろ、データベースを越えて問い合わせをするすべがありません。

contrib/dblink はデータベース間(cross-database)の問い合わせを関数呼出しにより許
します。もちろん、クライアントは同時に接続を別のデータベースへも張らなくてはな
らず、結果をクライアント側でマージしなくてはなりません。

4.25) 関数で複数のロウまたはカラムを返すにはどうしますか？

7.3では関数から、複数行のや複数カラムを簡単に返せます。 http://
techdocs.postgresql.org/guides/SetReturningFunctions。

4.26)なぜ、PL/PgSQL 関数の中から一時テーブルを確実に create/drop することができ
ないのでしょうか？

PL/PgSQL は関数の内容をキャッシュし、その不幸な副作用のため、もし PL/PgSQL 関数
が一時テーブルにアクセスすると、そのテーブルはあとでドロップされ再作成されます
が、関数が再び呼び出されると、キャッシュされているその関数の内容はまだ古い一時
テーブルを依然として指しているからです。解決策は、 PL/PgSQL の中で EXECUTE を一
時テーブルアクセスのために使うことです。これで、毎回クエリーのパースし直しを起
こすでしょう。

4.27) どのようなリプリケーションオプションを利用できますか?

マスター／スレーブのリプリケーションオプションがいくつか利用可能です。これらの
オプションではマスターのみがデータベースを変更でき、スレーブはデータベースを読
むだけです。 http://gborg.PostgreSQL.org/genpage?replication_research の最後に
それらを一覧にしてあります。マルチ-マスターのリプリケーションによるソリューショ
ンは http://gborg.PostgreSQL.org/project/pgreplication/projdisplay.php にて作業
が進められています。

[訳注 JPUG 分散トランザクション開発分科会では、永安悟史さんを中心に２相コミット
の実装を行なっています。 http://www.postgresql.jp/subcommittee/dt/index.html
http://www.snaga.org/jpug-dt/ 三谷篤さんによる双方向リプリケーションPGReplicate
http://www.csra.co.jp/~mitani/jpug/pgreplicate/ ]

4.28) どのような暗号化オプションを利用できますか?

 ・ contrib/pgcryptoにはSQL問い合わせの中で使うための沢山の暗号化を含みます。
 ・ クライアントとサーバとの間の伝送を暗号化するには、サーバではpostgresql.conf
    のsslオプションをtrue に設定し、pg_hba.confには適用するhostあるいはhostssl
    の行がなくてはなりません。そして、クライアントではsslmodeをdisableにしては
    なりません。 (PostgreSQL純正のSSL接続のかわりに、stunnel や ssh サードパー
    ティ製の暗号化転送を使うことも可能であることも記しておきます。)
 ・ バージョン7.3 ではデータベースユーザのパスワードは保存される時に自動的に暗
    号化されます。それより前のバージョンではpostgresql.conf中で
    PASSWORD_ENCRYPTIONを有効にする必要があります。
 ・ サーバーを走らせるのに暗号化ファイルシステムを使うこともできます。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

                        PostgreSQLの拡張についての質問                         
                                                                               
5.1) 自分で書いたユーザ定義関数を psql の中で実行するとコア・ダンプしてしまうの
はなぜですか？

問題は色々と考えられますが、まず最初に、作成したユーザ定義関数を単独のテストプ
ログラムにして試してみて下さい。

5.2) PostgreSQL 用に書いたちょっと素敵な新しい型や関数を提供してプロジェクトに
貢献したいのですが？

皆さんの行なった拡張を、pgsql-hackers メーリング・リストに送ってください。そし
て、ゆくゆくはそうした拡張が contrib/ サブディレクトリの中に入ることになるでし
ょう。

5.3) タプルを返す C言語の関数はどのように書きますか？

バージョン7.3以降のPostgreSQLでは、テーブルを返す関数を C, PL/PgSQL、そして SQL
にて完全にサポートします。詳しくはプログラマガイドの情報を見てください。Cで定義
された表を返す関数の例題がcontrib/tablefuncの中にあります。

5.4) ソース・ファイルを変更しました。再コンパイルしても変化が見られないのはなぜ
ですか？

いくつかの Makefile がインクルード・ファイルに対して適切な依存関係を持っていま
せん。make clean をしてからもう一度 make を行なわなくてはなりません。もし、GCC
をお使いであれば configure の --enable-depend オプションを使って、コンパイラに
依存関係を自動的に調べさせることもできます。
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

[訳注：
  日本語版の製作については以下の通りです。

  最終更新日:   2003年09月20日
  翻訳者:       桑村 潤 (Jun Kuwamura <juk at PostgreSQL.jp>)

  このFAQの和訳の作成にあたり協力をしてくださった方々(敬称は略させていただきます):

                田仲 稔(Minoru TANAKA <Tanaka.Minoru at keiken.co.jp>)
                石井 達夫(Tatsuo ISHII <t-ishii at sra.co.jp>)
                齊藤 知人(Tomohito SAITOH <tomos at elelab.nsc.co.jp>)
                馬場  肇(Hajime BABA <baba at kusastro.kyoto-u.ac.jp>)
                岡本 一幸(Kazuyuki OKAMOTO <kokamoto at itg.hitachi.co.jp>)
                小菅 昭一(Shoichi Kosuge <s-kosuge at str.hitachi.co.jp>)
                山下 義之(Yoshiyuki YAMASHITA <dica at eurus.dti.ne.jp>)
                境 真太郎(Sintaro SAKAI <s_sakai at mxn.mesh.ne.jp>)
                生越 昌己(Masami OGOSHI <ogochan at zetabits.com>)
                石川 俊行(Toshiyuki ISHIKAWA <tosiyuki at gol.com>)
                本田 茂広(Shigehiro HONDA <fwif0083 at mb.infoweb.ne.jp>)
                せせ じゅん(Jun SESE <sesejun at linet.gr.jp>)
                神谷 英孝(Hidetaka KAMIYA <hkamiya at catvmics.ne.jp>)
                菅原 敦(Atsushi SUGAWARA <asugawar at f3.dion.ne.jp>)
                稲葉 香理(Kaori Inaba <i-kaori at sra.co.jp>)

  をはじめ、ポストグレスに関する話題豊富な日本語ポストグレス・メーリングリスト、
和訳のきっかけを作ってくれた JF(Linux Japanese FAQ Mailing List)プロジェクト、その他、
直接あるいは間接的にかかわっているすべてのオープンソースコミュニティーの皆さんに感謝します。

  日本語版のこの文書は、以下からもたどれます。
        http://www.rccm.co.jp/~juk/pgsql/(FAQ和訳 PostgreSQL についてよくある質問)
        http://www.PostgreSQL.jp/subcommittee/jpugdoc/JPUG文書・書籍関連分科会
        http://www.linux.or.jp/JF/Linux JFプロジェクト

  なお、この和訳に関するご意見は(juk at PostgreSQL.jp)までお寄せ下さい。
]

