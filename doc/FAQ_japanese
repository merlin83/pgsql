PostgreSQL(ポストグレス・キュー・エル)についてよくある質問とその解答(FAQ)

原文最終更新日: Sun Jan 9 14:44:04 EST 2005

現在の維持管理者: Bruce Momjian (pgman@candle.pha.pa.us)
Maintainer of Japanese Translation: Jun Kuwamura (juk at PostgreSQL.jp)

この文書の最新版は "http://www.postgresql.org/files/documentation/faqs/
FAQ.html"> http://www.postgresql.org/files/documentation/faqs/FAQ.html

で見ることができます。

プラットホームに特有の質問については: "http://www.postgresql.org/docs/faq/">
http://www.postgresql.org/docs/faq/


に回答があります。

(以下、訳者による注釈を [訳注： と ] とで囲んで記します。)
[訳注：
        日本語版製作についてのメモは最後尾へ移動しました。

        日本語版のこの文書は 本家 "Docs"  の "Frequently Asked Questions" の
        ところに "Japanese FAQ" という見出であります。また、以下のサイトにも
        あります。
                http://www.PostgreSQL.jp/wg/jpugdoc/
                http://www.rccm.co.jp/~juk/pgsql/
                http://www.linux.or.jp/JF/

        この和訳についてお気づきの点は(juk at PostgreSQL.jp)までメールでお寄せ下さい。

                                                2005年01月12日    桑村 潤
]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

                                 一般的な質問                                  
                                                                               
1.1) PostgreSQLとは何ですか？何と読みますか？
1.2) PostgreSQLの著作権はどうなってますか？
1.3) PostgreSQLの動作するUnixプラットホームは？
1.4) Unix以外の移植版で使えるものは？
1.5) PostgreSQLはどこから入手できますか？
1.6) サポートはどこで受けられますか？
1.7) 最新版はどれですか
1.8) どのような文書がありますか？
1.9) 既知のバグや未だ無い機能はどうやって見つけますか？
1.10) SQLはどうすれば学べますか？
1.11) PostgreSQLは西暦2000年問題(Y2K)に対応していますか？
1.12) 開発チームにはどのように参加しますか？
1.13) バグレポートはどのように発信しますか？
1.14) 他のDBMSと比べてPostgreSQLはどうなのですか？
1.15) PostgreSQLを資金面で援助するにはどうすればよいですか？

                         ユーザー・クライアントの質問                          
                                                                               
2.1) PostgreSQL の ODBC ドライバーはありますか？
2.2) PostgreSQL を Web ページと連携させるにはどんなツールがありますか？
2.3) PostgreSQL にグラフィカル・ユーザインターフェイスはありますか？
2.4) どのような言語で PostgreSQL と通信できすか？

                                 管理上の質問                                  
                                                                               
3.1) どのようにすれば /usr/local/pgsql 以外の場所にインストールできますか？
3.2) postmaster を走らせると、 Bad System Call とかコア・ダンプしたとのメッセー
ジが出ます。なぜですか？
3.3) postmaster を走らせようとすると、 IpcMemoryCreate エラーが出ます。なぜです
か？
3.4) postmasterを走らせようとすると、 IpcSemaphoreCreate エラーが出ます。なぜで
すか？
3.5) 他のホストからの接続はどのように制御しますか？
3.6) より良い性能を得るためには、データベース・エンジンをどのように調整すれば良
いですか？
3.7) どのようなデバグ機能が使えますか？
3.8) 接続しようとするときに 'Sorry, too many clients' が出るのはなぜですか？
3.9) pgsql_tmp ディレクトリの中には何がありますか？
3.10) PostgreSQLのメジャーリリースをアップデートするのにダンプとリストアをしな
くてはならないのはなぜですか？
3.11) ハードウェアにはどんなコンピュータを使えばよいですか？

                                 操作上の質問                                  
                                                                               
4.1) バイナリ・カーソルと通常カーソルとの違いは何ですか？
4.2) 最初の数ロウのみを select するにはどうしますか？ランダムなロウ？
4.3) テーブルやその他の情報のリストを psql で見るにはどうしますか？
4.4) テーブルからカラムの削除、あるいは、データ型を変更するにはどうしますか？
4.5) ロウ、テーブル、データベースの最大サイズは？
4.6) 一般的なテキストファイルからデータを保存するには、データベースのディスク容
量はどのくらい必要ですか？
4.7) 定義されたテーブル、インデックス、データベース、および、ユーザをどのように
して見つけ出しますか？
4.8) 問い合わせが遅いうえ、インデックスを使っている様子がありません。なぜですか
？
4.9) 問い合わせオブティマイザがどのように問い合わせを評価するかを見るにはどうし
ますか？
4.10) R-tree インデックスとは何ですか？
4.11) 遺伝的問い合わせ最適化とは何ですか？
4.12) 正規表現での検索や大文字と小文字とを区別しない正規表現検索はどのように実
現しますか？大文字と小文字とを区別しない検索のためのインデックスはどのように使
いますか？
4.13) 問い合わせの中で、フィールドが NULL であることを検出するにはどうしますか
？
4.14) 色々な文字型のそれぞれの違いは何ですか？
4.15.1) 通番(serial)／自動増分フィールドはどのようにつくりますか？
4.15.2) SERIALデータ型に挿入される値は、どうすれば得られますか？
4.15.3) currval() は他のユーザとの競合状態に陥ることはないですか？
4.15.4) トランザクションが中断したときにもういちどシーケンス番号が使われないの
はなぜですか？シーケンス／SERIALカラムに空きがあるのはなぜですか？
4.16) OID とは何ですか？ TID とは何ですか？
4.17) PostgreSQL で使われるいくつかの用語の意味は何ですか？
4.18) エラーメッセージ "ERROR: Memory exhausted in AllocSetAlloc()"が出るのはな
ぜですか？
4.19) どのバージョンの PostgreSQL を走らせているのかを調べるにはどうしますか？
4.20) ラージオブジェクトの操作で、invalid large obj descriptorと出るのはなぜで
すか？
4.21) 現在の時刻がデフォルトとなるようなカラムはどのようにつくりますか？
4.22) なぜ、INを使う副問い合わせがとても遅いのですか？
4.23) 外部結合(outer join)はどのように実現しますか?
4.24) 複数のデータベースを使う問い合わせはどのようにすればできますか？
4.25) 関数で複数のロウまたはカラムを返すにはどうしますか？
4.26) なぜ、PL/PgSQL 関数の中から一時テーブルを確実に create/drop することがで
きないのでしょうか？
4.27) どのような暗号化オプションを利用できますか?

                        PostgreSQLの拡張についての質問                         
                                                                               
5.1) 自分で書いたユーザ定義関数を psql の中で実行するとコア・ダンプしてしまうの
はなぜですか？
5.2) PostgreSQL 用に書いたちょっと素敵な新しい型や関数を提供してプロジェクトに
貢献したいのですが？
5.3) タプルを返す C言語の関数はどのように書きますか？
5.4) ソース・ファイルを変更しました。再コンパイルしても変化が見られないのはなぜ
ですか？

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

                                 一般的な質問                                  
                                                                               
1.1) PostgreSQL とは何ですか？何と読みますか？

PostgreSQLはPost-Gres-Q-L(ポスト - グレス - キュー - エル) と発音します。

PostgreSQL は次世代 DBMS 研究用のプロトタイプであった POSTGRES データベース管理
システムの改良版です（このため、今でもときどき "Postgres" と呼ばれることがあり
ます）。PostgreSQL は POSTGRES の強力なデータ・モデルと豊富なデータ・タイプ(型)
を保持しながら、POSTGRES で使われた PostQuel 問い合わせ言語を、拡張した SQL の
サブセットに置き換えています。PostgreSQL は無料で完全なソースを利用できます。

PostgreSQL の開発は、PostgreSQL 開発メーリングリストに参加している開発者達のチ
ームですべて行なわれています。現在の座長は Marc G. Fournier (
scrappy@PostgreSQL.org )です。(下記の1.6節に参加の仕方があります。)現在、このチ
ームが PostgreSQL 開発のすべての面倒をみています。このチームはコミュニティプロ
ジェクトであり、いかなる企業によっても制御を受けません。参加したければ、 http:/
/www.postgresql.org/files/documentation/faqs/FAQ_DEV.html にある開発者向けのFAQ
を見てください。

Postgres95-1.01 の中心的な開発者は Andrew Yu と Jolly Chen でしたが、その他大勢
の人々がこのコードの移植、テスト、デバグ、および、改良に参加しました。
PostgreSQL の派生元コードである Postgres はカリフォルニア大学バークレイ校におい
て、 Michael Stonebraker 教授の指揮のもと、多くの学生、卒業生、本職のプログラマ
たちの努力により作られました。

バークレイにおけるこのソフトウェアのもとの名前は Postgres でしたが、SQL の機能
が追加された 1995 年にその名前は Postgres95 に変更され、1996 年の終りにその名前
は PostgreSQL に変更されました。

1.2) PostgreSQL の著作権はどうなってますか？

PostgreSQL は下記の著作権に従います。

    [訳注：
        正文は英語です。参考として、訳文を併記掲載します。
    ]

PostgreSQL Data Base Management System

Portions Copyright (c) 1996-2005, PostgreSQL Global Development Group Portions
Copyright (c) 1994-6 Regents of the University of California

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose, without fee, and without a written agreement is
hereby granted, provided that the above copyright notice and this paragraph and
the following two paragraphs appear in all copies.

IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.

THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND
THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE,
SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

        POSTGRESQL データベース管理システム

        部分的著作権 (c) 1996-2004, PostgreSQL国際開発チーム
        部分的著作権 (c) 1994-6 カリフォルニア大学本校


          本ソフトウェアおよびその文書一式は上記の著作権表示と、この文章
        およびこれに続く二つの段落が全ての複製に添付されている限りにおい
        て、使用、複製、修正および配付の許可を、いかなる目的であっても、
        無償でかつ同意書無しに行なえることをここに認めます。
        
          カリフォルニア大学は、いかなる当事者にたいしても、利益の壊失を
        含む、直接的、間接的、特別、偶然あるいは必然的にかかわらず生じた
        損害について、たとえカリフォルニア大学がこれらの損害について訴追
        を受けていたとしても、一切の責任を負いません。
        
          カリフォルニア大学は、商用目的における暗黙の保証と、特定目的で
        の適合性に関してはもとより、これらに限らず、いかなる保証も放棄す
        ることを明言します。以下に用意されたソフトウェアは「そのまま」を
        基本原理とし、カリフォルニア大学はそれを維持、支援、更新、改良あ
        るいは修正する義務を負いません。

    [訳注：
        著作権に関する正文は上記の英語による表記です。日本語訳はあくまで
        参考です。
    ]

上記はBSDライセンスで古きオープンソースのライセンスです。ソースコードがどのよう
に使われようとも制限しません。好ましいことなので、我々もそれを変えるつもりはあ
りません。

1.3) PostgreSQL の動作環境は？

一般的に、最近のUnix互換プラットホームであればPostgreSQLを稼働させられるはずで
す。リリースの時点で実際にテストを行なったことの報告がなされたプラットホームに
ついてはインストール手引書に列挙してあります。

1.4) Unix以外の移植版で使えるものは？

バージョン8.0になり、PostgreSQL は、Win2000, WinXP, Win2003などの Microsoft
Windows NTベースのオペレーティングシステムでネイティブに走るようになりました。
パッケージになったインストーラが、http://pgfoundry.org/projects/pginstallerから
入手できます。 Windows (Win95, Win98, WinMe)など、MSDOSベースのバージョンでは、
Cygwin を使ってPostgreSQLを走らせることができます。

    [訳注
        pgInstaller の入手はFTPミラーサイトの win32 ディレクトリからも可能です。
            http://www.postgresql.org/mirrors-ftp.html
    ]

次のサイトに Novell Netware 6 への移植もあります。 http://forge.novell.com また
、OS/2 (eComStation) バージョンは、 http://hobbes.nmsu.edu/cgi-bin/h-search?sh=
1&button=Search&key=postgreSQL&stype=all&sort=type&dir=%2Fにあります。


1.5) PostgreSQL はどこから入手できますか？

PostgreSQL の大元の anonymous ftp サイトは ftp://ftp.PostgreSQL.org/pub/ です。
ミラーサイトについては、我々のメイン Web ページをご覧下さい。

    [訳注:

        以下は日本のミラーサイトです:

       Japan: ftp://ftp.jp.postgresql.org/
       Japan: ftp://mirror.nucba.ac.jp/mirror/PostgreSQL/pub/
       Japan: ftp://ring.ip-kyoto.ad.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.crl.go.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.saitama-u.ac.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.astem.or.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.exp.fujixerox.co.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.jah.ne.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.etl.go.jp.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.asahi-net.or.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.so-net.ne.jp/pub/misc/db/PostgreSQL/
       Japan: ftp://ring.aist.go.jp/pub/misc/db/PostgreSQL/
    ]

1.6) サポートはどこで受けられますか？

主要なメーリング・リストは: pgsql-general@PostgreSQL.orgです。PostgreSQL に関す
ることであれば議論ができます。このリストへの参加は、電子メールの本文(Subject 行
ではありません)に次の２行を書いて、

        subscribe
        end

pgsql-general-request@PostgreSQL.org へ送って下さい。

ダイジェスト版のメーリング・リストもあります。このリストへの参加は "本文"に：

        subscribe
        end

と書いて pgsql-general-digest-request@PostgreSQL.org へ電子メールを送って下さい
。

ダイジェスト版は、メインリストで受信するメッセージが 30k 程度溜る毎にダイジェス
ト版リストのメンバーに送付されます。

バグレポート用のメーリングリストもあります。このリストへの参加は "本文" に：

        subscribe
        end

と書いてpgsql-bugs-request@PostgreSQL.org へ電子メールを送って下さい。

開発者の議論のためのメーリングリストも利用できます。このリストへの参加は電子メ
ールの本文に：

        subscribe
        end

と書いて、pgsql-hackers-request@PostgreSQL.orgへ電子メールを送って下さい。

http://www.PostgreSQL.org

メジャーなIRC チャンネルは、Freenode (irc.freenode.net)の #PostgreSQL というチ
ャンネルです。 UNIX コマンドで、 irc -c '#PostgreSQL' "$USER" irc.freenode.net.
を使って参加できます。同じネットワークに、スペイン語のチャンネル(#
postgresql-es)もあり、フランス語のチャンネル(#postgresqlfr)もあります。 EFNetに
もPostgreSQLチャンネルがあります。

    [訳注:
          1999年7月23日、日本ポストグレスユーザー会、略称JPUGが設立されました。
        JPUG は非営利組織で、PostgreSQLを利用する人達の相互協力の場となっています。  
        (2003年5月17日、「日本PostgreSQLユーザ会」に名称を改めました。)
        正会員の会費は無料ですが、協賛会員の会費と会員の積極的な貢献が会の運営を助けています。
        詳しくは、JPUG のWeb サイト:
                http://www.PostgreSQL.jp/
        をご覧ください。会員登録も可能となっています。

        日本語のIRCチャンネル '#PostgreSQL*jp' も存在します。

商用サポート会社のリストはhttp://techdocs.postgresql.org/companies.phpにありま
す。

1.7) 最新版はどれですか

PostgreSQL の最新版はバージョン 7.4.6 です。

我々は、6〜8カ月毎にメジャーリリースを行なうことを計画しています。

1.8) どのような文書がありますか？

配付の中に、いくつかのマニュアルとオンライン・マニュアル(マニュアル・ページ)お
よびいくつかの小さなテスト例題が含まれます。/doc ディレクトリをご覧下さい。また
、マニュアルは、http://www.ca.PostgreSQL.org/docs/でオンラインでも閲覧できます
。

    [訳注:
        （株）SRAと日本PostgreSQLユーザ会で翻訳され、
        「PostgreSQL オフィシャルマニュアル」
        として出版されています。
    ]

オンラインで参照できる PostgreSQL の本も2冊あります。http://www.PostgreSQL.org/
docs/awbook.html

    [訳注:
        日本ポストグレスユーザー会の    「PostgreSQL Book翻訳分科会」
        にて翻訳されました。
    ]

および、 http://www.commandprompt.com/ppbook/ です。購入可能な書籍の目録は、
http://techdocs.PostgreSQL.org/techdocs/bookreviews.php にあります。 PostgreSQL
技術情報記事も、http://techdocs.PostgreSQL.org/ にあります。

[訳注: 和訳文書は、日本ポストグレスユーザー会のhttp://www.postgresql.jp/
document/ をごらん下さい。 ]

コマンドラインのクライアントプログラムpsql も、型、演算子、関数、集約、その他の
情報をお見せする、いくつかの素晴らしい \d コマンドを持ちます。 - \? を使うと利
用可能なコマンドが表示されます。

我々の Web サイトには、もっと沢山の文書があります。

1.9) 既知のバグや未だ無い機能はどうやって見つけますか？

PostgreSQLは拡張されたSQL-92のサブセットをサポートします。我々のページの TODO
リストに、既知のバグや欠落機能や将来計画についての記述があります。

1.10) SQL はどうすれば学べますか？

http://www.PostgreSQL.org/docs/awbook.html にあるPostgreSQL本で SQL を教えてい
ます。

    [訳注:
        日本ポストグレスユーザー会の    「PostgreSQL Book翻訳分科会」
        にて翻訳され出版されています。
    ]

その他にも PostgreSQL本として、http://www.commandprompt.com/ppbook があります。
素晴らしい手引書は、http://www.intermedia.net/support/sql/sqltut.shtm, http://
ourworld.compuserve.com/homepages/graeme_birchall/HTM_COOK.HTM, そして、http://
sqlcourse.com にあります。

その他では、 "Teach Yourself SQL in 21 Days, Second Edition" が http://
members.tripod.com/er4ebus/sql/index.htmにあります。

多くのユーザに、 The Practical SQL Handbook, Bowman Judith S. et al.,
Addison-Wesley が好評です。その他に、The Complete Reference SQL, Groff et al.,
McGraw-Hill のようなのもあります。

    [訳注:
         石井達夫氏による日本語の参考文献の紹介ページ
                http://www.SRA.co.jp/people/t-ishii/PostgreSQL/doc-jp/index.html
        があります。
         近藤直文氏の「初心者向のＤＢ設計入門・ＳＱＬ入門参考書紹介」のコーナー
                http://www.shonan.ne.jp/~nkon/ipsql/books_SQL.html
        があります(やや古い2000年版)。
         堀田倫英氏の「PostgreSQL日本語マニュアル」
                http://www.net-newbie.com/
        ではオンラインマニュアルの検索ができます。
         丸山不二夫氏のUNIX データベース入門
                http://www.wakhok.ac.jp/DB/DB.html
        もオンラインで読むことができます。
    ]

1.11) PostgreSQLは西暦2000年問題(Y2K)に対応していますか？

対応してます。西暦2000年より後の日付も、紀元前2000年より前の日付も、簡単に扱え
ます。

1.12) 開発チームにはどのように参加しますか？

まず最初(１番目)に、最新のソースをダウンロードし、我々の Web サイトか配布に含ま
れているPostgreSQL Developersの文書を読みます。２番目に、pgsql-hackers と
pgsql-patches メーリング・リストを購読(subscribe)します。３番目に、高品質のパッ
チをpgsql-patchesに発信します。

およそ十人ちょっとの人達が、PostgreSQL CVSアーカイブにコミットする権限を持って
います。そのそれぞれの人達が沢山の高品質なパッチを発信するので、現在コミッター
となっている人達はそれに追い付くのが大変ですが、我々は彼らがコミットしたパッチ
は高品質であると確信しています。

1.13) バグレポートはどのように発信しますか？

http://www.postgresql.org/support/submitbug のPostgreSQL バグフォームを訪れて下
さい。バグレポートを提出する仕方についての手引と指針があります。

それと同時に ftp サイト ftp://ftp.PostgreSQL.org/pub/で、もっと新しいバージョン
の PostgreSQL あるいはパッチをさがしてみて下さい。

1.14) 他のDBMSと比べてPostgreSQLはどうなのですか？

ソフトウェアを計る方法にはいくつかあります。機能と性能と信頼性とサポートと価格
です。

機能(Features)
    PostgreSQLは、トランザクション、副問い合わせ、トリガー、ビュー、外部キー整
    合性参照、および、洗練されたロック機構など、大規模商用DBMSが持つ機能をほと
    んど持っています。さらに PostgreSQLは、ユーザ定義型、継承、ルール、それから
    、ロック競合を縮小するマルチバージョン同時性制御など、商用DBMSも持ち合わせ
    ないような機能をいくつか持ち合わせています。
性能(Performance)
    PostgreSQLは他の商用あるいはオープンソースのデータベースと互角の性能も持ち
    ます。ある面ではより早かったり、ほかの面ではより遅かったりします。MySQLなど
    の特化型データベース・システムにくらべて、PostgreSQL は複数ユーザや複雑な問
    い合わせ、また、 read/write 問い合わせのロードがより高速です。MySQLは少ない
    ユーザでの単純な SELECT 問い合わせでは高速です。もちろん、MySQLには上記の
    Featuresの節に示すような機能はほとんどありません。我々は、PostgreSQLに柔軟
    性と機能性を組み込みながらも、絶えず性能の改善を続けています。
信頼性(Reliability)
    我々は、DBMSの信頼性が高くなくてはその価値が無いことを理解してます。十分テ
    ストして、安定したコードをバグを最小にしてからリリースするように努めてます
    。それぞれのリリースは少なくとも1カ月以上のベータ・テストを行ない、これまで
    のリリースの履歴が、製品版として安定した堅固なリリースであることを物語って
    います。この分野では、他のデータベースと比べても遜色がないことに自信を持っ
    ています。
サポート(Support)
    我々のメーリングリストは、遭遇するいかなる問題についても解決への手助けをし
    てくれる、開発者やユーザの大きな集まりへの接点を提供しています。我々は問題
    の解決を保証することはできませんが、商用データベースであっても常に解決され
    るわけではありません。開発者や、ユーザ・コミュニティ、マニュアル類、それに
    、ソースコードなどへ直接アクセスできることによって、PostgreSQLのサポートは
    、他のDBMSサポートよりも優れたものとなっています。御要望に答えて、事柄毎の
    商用サポートなどもあります（FAQ1.6節をご覧下さい）。
価格(Price)
    PostgreSQLの利用は、商用でも非商用でも、すべて無料です。上記に示してあるBSD
    スタイルの使用許諾に外れない限り、PostgreSQLのコードを制限無しで商品に組み
    込むことができます。

1.15) PostgreSQLを資金面で援助するにはどうすればよいですか？

PostgreSQLは、我々が始めた 1996年以来、最高クラスの情報基盤を持っています。これ
はすべて、Marc Fournieさんのおかげで、彼はこの基盤を創り出し、何年にもわたって
管理してきました。

質の良い基盤は、オープンソース・プロジェクトにとってはとても大切なもので、プロ
ジェクトが前進する勢いを失って分裂するのを回避します。

もちろん、この基盤は安いものではありません。維持し続けるためには毎月あるいは一
時的に経費がかかります。もし、あなたやあなたの会社に、こうした努力のための資金
の援助を施すことができるようでしたら、http://store.pgsql.com/shopping/から寄付
をお願いします。

また、Webページには PostgreSQL,Inc とありますが、そこの "貢献(contributions)"と
いう項目は、 PostgreSQL プロジェクトを支援するだけのためで、決して特定の会社の
ための資金ではありません。もし、小切手(check)の方が都合よければ連絡先の住所へお
送り下さい。

さらに、PostgreSQLを使った成功事例をお持ちであれば、ぜひ、われわれの事例紹介リ
スト pgsql-advocacy@postgresql.org へお送りください。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

                         ユーザー・クライアントの質問                          
                                                                               
2.1) PostgreSQL のための ODBC ドライバーはありますか？

PsqlODBC と OpenLink ODBC の二つの ODBC ドライバーが利用可能です。

PsqlODBC は次の場所からダウンロードできます。 http://gborg.postgresql.org/
project/psqlodbc/projdisplay.php

OpenLink ODBC は http://www.openlinksw.com/から入手できます。標準的な ODBC クラ
イアント・ソフトウェアで使えますので、支援しているすべてのプラットホーム(Win,
Mac, Unix, VMS)から PostgreSQL の ODBC が利用できます。

たぶん彼らは、商用品質のサポートの必要な人々に売っていると思いますが、フリーウ
ェア版はいつでも入手可能のようです。質問は、postgres95@openlink.co.uk へ送って
下さい。

Programmer's Guide の ODBC の章もご覧ください。

2.2) PostgreSQL を Web ページと連携させるにはどんなツールがありますか？

データベースを裏に持つ Web ページについての素晴らしい紹介が、
http://www.webreview.comにあります。

Web への拡張のためには、PHP が卓越したインターフェイスとなっています。http://
www.php.net/にあります。

    [訳注:
          PHPに関する日本語の情報は、2000年4月19日に発足した日本PHPユーザ会のサイト
                http://www.php.gr.jp/
        あるいは、廣川 類さんのサイト
                http://www.geocities.jp/rui_hirokawa/php/
        にかなりまとめられています。
    ]

処理が複雑な場合、多くの人は Perl インターフェイスと CGI.pm か mod_perl を使い
ます。

    [訳注:
        WDB は、Web から DataBase への Perl の Interface です。
        wdb-p95 へのリンクは切れてしまっています。おそらく、Perl DBI 経由で DBD::Pg の利用が可能と思われます。
        現在、WDBI という名前になっているもの
                http://www.egroups.com/list/wdb-users/
        と、WDBの名前のままのもの
                http://www.i-con.dk/wdb/
        とがあります。その経緯はよくわかりません。
    ]

2.3) PostgreSQL にグラフィカル・ユーザインターフェイスはありますか？

もちろん、PostgreSQL へのグラフィカルインターフェイスがいくつかあります。その中
にPgAccess http://www.pgaccess.org も含まれます。 PgAdmin III (http://
www.pgadmin.org)もあります。 RHDB Admin (http://sources.redhat.com/rhdb/ )、
TORA (http://www.globecom.net/tora/ (部分的に商用)) および、 Rekall ( http://
www.thekompany.com/products/rekall/, proprietary)もあります。 PhpPgAdmin (
http://phppgadmin.sourceforge.net/ ) はPostgreSQLへのWebベースのインターフェイ
スを提供します。

より詳細なリストについては、http://techdocs.postgresql.org/guides/GUITools をご
覧ください。

2.4) どのような言語で PostgreSQL と通信できすか？

人気のあるほとんどの言語はPostgreSQLへのインターフェイスを持っています。あなた
が使うプログラミング言語の拡張モジュールのリストを覗いてみてください。

以下のインターフェイスはPostgreSQLの配布に含まれています。

 ・ C (libpq)
 ・ 埋め込みC (ecpg)
 ・ Java (jdbc)
 ・ Python (PyGreSQL)
 ・ TCL (libpgtcl)

その他の利用可能なインターフェイスは http://gborg.postgresql.org のDrivers/
Interfacesのセクションにあります。

    [訳注：
        永安悟史さんは Palm 版の libpq を開発されました。
                http://www.snaga.org/libpq/
    ]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

                                 管理上の質問                                  
                                                                               
3.1) どのようにすれば /usr/local/pgsql 以外の場所にインストールできますか？

簡単な方法は、 configure を走らせるときに --prefix オプションを指定することです
。

3.2) postmaster を走らせると、Bad System Call とかコア・ダンプしたとのメッセー
ジが出ます。なぜですか？

さまざまな問題が考えられますが、まず最初にあなたのカーネルに System V IPC の拡
張がインストールされているかを確認して見てください。PostgreSQL はカーネルによる
共有メモリーとセマフォのサポートを必要とします。

3.3) postmaster を走らせようとすると、IpcMemoryCreate エラーが出ます。なぜです
か？

カーネルが共有メモリーを持つ設定になっていなかったか、でなければ、カーネルに対
して使える共有メモリーの大きさを大きく設定する必要があります。具体的な大きさは
、使っているアーキテクチャとpostmaster を走らせるときに設定するバッファの数とバ
ックエンドプロセスに依存します。ほとんどのシステムでは、既定値のバッファサイズ
のままで、少なくとも約1MBが必要です。 PostgreSQL Administrator's Guide/Server
Run-time Environment/Managing Kernel Resources に共有メモリーとセマフォについて
の情報の詳細がありますのでご覧ください。

3.4) postmasterを走らせようとすると、IpcSemaphoreCreate エラーが出ます。なぜで
すか？

もしエラーメッセージがIpcSemaphoreCreate: semget failed (No space left on
device)であれば、カーネルが十分なセマフォを使えるように構成されていません。
Postgresは潜在的なバックエンドプロセス毎に一つのセマフォを必要とします。とりあ
えずの解決策はpostmasterを起動するときに、バックエンドプロセスの数をより少なく
制限をすることです。既定値の32より小さな数のパラメータを-Nで使います。より恒久
的な解決策は、カーネルのSEMMNS と SEMMNI パラメータを増やすことです。

操作不能のセマフォも過度なデータベースアクセスの間にクラッシュを起こす可能性が
あります。

もし、エラーメッセージがなにか他のものであれば、カーネルの構成でまったくセマフ
ォのサポートをしていないかもしれません。 PostgreSQL Administrator's Guide に共
有メモリーとセマフォについての情報の詳細があります。

3.5) 他のホストからの接続はどのように制御しますか？

既定値では、PostgreSQL は Unix ドメインソケット、または、TCP/IP接続のローカルマ
シンからの接続しか許しません。postgresql.conf の中の listen_addresses を修正し
、かつ、$PGDATA/pg_hba.conf ファイルを適切に直して、ホスト主導型認証を有効にし
ないかぎりは、他のマシンからは接続できないでしょう。

3.6) より良い性能を得るためには、データベース・エンジンをどのように調整すれば良
いですか？

確かにインデックスは問い合わせの速度を増します。EXPLAIN ANALYZEコマンドで
PostgreSQL がどのようにあなたの問い合わせを翻訳しているかを見ることができ、そし
て、どのインデックスが使われているかを見ることができます。

もし INSERT を多用している場合は、COPY コマンドを使って大きなバッチ処理でそれを
行なうことを検討して下さい。これは、INSERT を別々に行なうよりもっと高速です。次
に、BEGIN WORK/COMMIT のトランザクション・ブロックの中に無い文は、それら自身が
それぞれのトランザクションに入っていると見なされます。いくつかの文を一つのトラ
ンザクション・ブロックの中で行なうことを考えて下さい。これによりトランザクショ
ンのオーバーヘッドが減ります。また、大きなデータの変更を行なう際はインデックス
を一度外して、作り直すことを考えてみて下さい。

Administration Guide/Server Run-time Environment/Run-time Configurationには、チ
ューニングのオプションがいくつかあります。fsyncオプションでfsync() を無効にする
ことができます。これによって、各トランザクション毎に fsync() でディスクを更新す
るのを止めさせます。

shared_buffersオプションを使ってバックエンド・プロセスにより使われる共有メモリ
ー・バッファを大きくすることもできます。もし、このパラメータを高くしすぎると、
カーネルの共有メモリー空間の制限値を越えてしまうために postmaster が走らなくな
るでしょう。既定値では、それぞれのバッファの大きさは 8K で、バッファ数は 1000
です。

sort_mem (PostgreSQL 8.0からは: work_mem)オプションを使って、それぞれのバックエ
ンド・プロセスが一時的な並べ替えによって使うメモリーの最大サイズを増やすことも
できます。既定値は 1024 (すなわち、1MB)です。

また、CLUSTER コマンドを使って、テーブルのデータをインデックスに合わせるために
グループ化することもできます。詳しくは、オンラインマニュアルで CLUSTER を見て下
さい。

3.7) どのようなデバグ機能が使えますか？

PostgreSQL は、デバグのために意味のある、状態情報を報告するいくつかの機能を持ち
ます。

まず、--enable-cassert オプションで configure を走らせます。そうしてコンパイル
することにより、沢山の assert() が、バックエンドの進捗状況を監視し、何か予期せ
ぬことが起きるとプログラムを停止するようになります。

postmaster と postgres の両方でいくつかのデバグ・オプションの利用ができます。ま
ず、次のように postmaster を起動するときはいつでも、標準出力とエラー出力をログ
・ファイルに送るようにしてあることを確かめて下さい。

        cd /usr/local/pgsql
        ./bin/postmaster >server.log 2>&1 &

これにより PostgreSQL の最上部のディレクトリに server.log ファイルが置かれます
。このファイルはサーバーが遭遇した問題やエラーについて有用な情報を含みます。
Postmaster は更に詳細な情報を報告するための -d オプションを持ちます。その -d オ
プションは、デバグ・レベルを指定します。高いデバグ・レベルでは、大きなログファ
イルを生成することに注意しなくてはなりません。

もし、postmasterが走っていなければ、postgresバックエンドをコマンドラインから走
らせることができ、直接SQL文をタイプすることができます。このやりかたは、デバグ目
的のときだけお奨めします。セミコロンではなく、改行が問い合わせの終りになること
に注意してください。もし、デバグシンボルを入れてコンパイルしていれば、デバッガ
を使って何が起きているかを見ることができます。postmaster からバックエンドを開始
したわけではないので、独立な環境で走っているのではなくロック／バックエンドとの
対話の問題が重複することはありません。

もし、postmasterが走っていれば、あるウィンドウでpsqlを開始すると、

SELECT pg_backend_pid()

を使って、psql で使われる postgres プロセスのPIDが見つかります。デバッガを使っ
てpostgresのPIDにアタッチ(attach)します。デバッガの中からブレーク・ポイントをセ
ットし、psql から問い合わせを発行します。デバグのためにpostgresを始動する場合は
、PGOPTIONS="-W n" を設定でき、それから、psql を開始します。これにより、n 秒開
始を遅らせるはずなので、デバッガでプロセスにアタッチして、ブレークポイントを設
定し、開始から順を追って見てゆくことができます。

いくつかの

log_*

サーバ構成変数は、デバッグと性能測定にとても役に立つプロセスの統計の印刷を可能
にします。

何という関数がどのくらい実行時間を食っているかを見るために、プロファイリング（
プロフィール付き）でコンパイルすることも可能です。そのバックエンドのプロフィー
ル・ファイルは pgsql/data/base/dbname ディレクトリに格納されるでしょう。クライ
アントのプロフィールはクライアントの現行ディレクトリに置かれるでしょう。Linux
でまともなプロファイリングを行うには -DLINUX_PROFILE でコンパイルする必要があり
ます。

3.8) 接続しようとするときに 'Sorry, too many clients' が出るのはなぜですか？

postmasterが同時始動できるバックエンドプロセスに対する制限数を増やす必要があり
ます。

既定の最大プロセスは32プロセスです。-Nに適切な値を引数にしてpostmasterを再起動
するか、PostgreSQL.conf を修正することによって、その値を増やすことができます。

もし、-N を 32よりも大きくするのであれば、-Bも既定の64より大きい値に増加させな
くてはならないし、-B は少なくとも -N の2倍はなくてはならず、おそらく最高性能を
望むならばそれより大きい値が必要なはずです。バックエンドプロセスをたくさんにす
ると、いろいろなUnixカーネル構成パラメータも増やすことが必要になるかもしれませ
ん。共有メモリー・ブロックの最大値(SHMMAX)、セマフォの最大数(SEMMNSとSEMMNI)、
プロセスの最大数(NPROC)、ユーザ毎の最大プロセス数(MAXUPRC)、開くファイルの最大
数(NFILEとNINODE) も確認事項に含まれます。 PostgreSQLに許されるバックエンドのプ
ロセス数が制限されているのは、システムのリソースを使い果してしまうことを避ける
ためです。

3.9) pgsql_tmp ディレクトリの中には何がありますか？

問い合わせ実行モジュールによって生成された一時的なファイルが、このディレクトリ
に含まれます。例えば、もし ORDER BY 句を満たすためにバックエンドの -S パラメー
タで許可した値よりも大きなスペースがソートの際に必要だとすると、溢れたデータを
保持するために一時的なファイルがいくつかここに生成されます。

一時的なファイルは自動的に消し去られるはずですが、もし、ソートの途中でバックエ
ンドがクラッシュしてしまうとそうはなりません。postmasterの停止とリスタートでこ
れらのファイルはディレクトリから消しさられます。

    [訳注：
         SYSLOGD 経由でログを出力するには、まず、configure を --enable-syslog 
        付きで走らせた後、コンパイルとインストールを行ないます。
         次に、syslog.conf に local?.* の 出力先を指定し(環境変数で変更可能)、
        syslogd に HUP シグナルを送って初期化しておきます。そして、
        $PGDATA/pg_options に syslog=2 を加えて、 postmaster を -S 
        オプション付きにてサーバモードで起動します。(バージョン 7.1 からは 
        pg_options は PostgreSQL.conf になっています。)
    ]

3.10) PostgreSQLのメジャーリリースをアップデートするのにダンプとリストアをしな
くてはならないのはなぜですか？

PostgreSQLチームはマイナーリリースでは小さな変更しか行ないませんので、7.2 から
7.2.1 へのアップグレードにはダンプとリストアの必要はありません。しかし、メジャ
ーリリース(たとえば、7.2から7.3へのような)では、システムテーブルやデータファイ
ルの内部フォーマットの変更をしばしば行ないます。これらの変更はたいてい複雑で、
そのため我々はデータファイルのための後方互換性を維持することができません。ダン
プは汎用フォーマットでデータを出力し、それを新しい内部フォーマットに読み込むこ
とができます。

ディスク上でのフォーマットに変更のない同一リリースでは、アップグレードは、ダン
プ／リストアではなく、pg_upgrade スクリプトを使うことができます。リリースノート
には、pg_upgrade が利用可能なリリースかどうか記されています。

3.11) ハードウェアにはどんなコンピュータを使えばよいですか？

PCハードウェアはほとんど互換性がありますので、ほとんどの人は、すべてのPCハード
ウェアが同じ品質だと思い込む傾向があります。しかし、それは間違いです。ECC RAM、
SCSI、および、高品質マザーボードは、安いハードウェアに比べると、より信頼性が高
く、より性能も良いのです。PostgreSQL はほとんどのハードウェアで稼働しますが、信
頼性や性能が重要な場合は、ハードウェアのオプションを研究することが賢明です。メ
ーリングリストでもハードウェアオプションとトレードオフについて議論することがで
きます。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

                                 操作上の質問                                  
                                                                               
4.1) バイナリ・カーソルと通常カーソルとの厳密な違いは何ですか？

詳述は、オンラインマニュアルで DECLARE を見て下さい。

4.2) 最初の数ロウのみを SELECTするにはどうしますか？ランダムなロウ？

オンラインマニュアルでFETCHを見てください。あるいは、SELECT ... LIMIT....を使っ
てみて下さい。

たとえ、欲しいのは最初の数ロウだけでも、すべての問い合わせを評価しなくてはなら
ないかもしれません。ORDER BY を持った問い合わせを使うことを考えてみて下さい。も
し、ORDER BYに合ったインデックスがあるとすると PostgreSQLは要求された最初の数ロ
ウだけで評価できるかもしれませんが、でなれば、PostgreSQL は意図したロウが生成さ
れるまですべてのロウを評価しなければならないかもしれません。

ランダムなロウをSELECTするには、次の文を使います：

    SELECT col
    FROM tab
    ORDER BY random()
    LIMIT 1;

4.3) テーブルやその他の情報のリストを psql で見るにはどうしますか？

psqlの中で、 \dt コマンドを使ってテーブルを見ます。psql の中のコマンドの完全な
リストには \? を使えます。あるいは、psqlのソースコードのpgsql/src/bin/psql/
describe.cファイルを見ることもできて、その中にはpsqlのバックスラッシュコマンド
の出力を生成するSQLコマンドが含まれています。また、psqlを -E オプションと一緒に
開始すると、実行させたコマンドを実行するために使う問い合わせを出力するようにな
ります。PostgreSQLはまた、SQLi対応の INFORMATION SCHEMA インターフェースを用意
していて、データベースについての情報を得るために問い合わせを使うことができます
。

4.4) テーブルからカラムの削除、あるいは、データ型を変更するにはどうしますか？

DROP COLUMN機能が、ALTER TABLE DROP COLUMN としてリリース7.3 に加えられました。
それまでのバージョンでは、その代わりにこうします:

        BEGIN;
        LOCK TABLE old_table;
        SELECT ...  -- 削除したいカラム以外のカラムをすべて選択します。
        INTO TABLE new_table
        FROM old_table;
        DROP TABLE old_table;
        ALTER TABLE new_table RENAME TO old_table;
        COMMIT;

カラムのデータタイプは次の文で変えられます：

    BEGIN;
    ALTER TABLE tab ADD COLUMN new_col new_data_type;
    UPDATE tab SET new_col = CAST(old_col AS new_data_type);
    ALTER TABLE tab DROP COLUMN old_col;
    COMMIT;

これを行なったときは、抹消された行が使っているディスク空間を回収するために
VACUUM FULL tabをしたほうが良いかもしれません。

4.5) ロウ、テーブル、データベースの最大サイズは？

制限は以下のとおりです。

データベースの最大サイズ?       制限無し (32 TB のデータベースも存在します)
テーブルの最大サイズ?           32TB
ロウの最大サイズ?               1.6TB
フィールドの最大サイズ?         1GB
テーブル内での最大ロウ数?       制限無し
テーブル内での最大カラム数?     カラムの型により250-1600
テーブル内での最大インデックス数? 制限無し

もちろん、これらは実際は無制限ではなく、ディスク容量とメモリーやスワップスペー
スの大きさにより制限されます。性能はこれらの値がことのほか大きな時に煽りを受け
ます。

最大テーブルサイズの32TBはオペレーティングシステムによる巨大ファイルのサポート
は必要としません。巨大なテーブルは複数の1GBのファイルに分けて保存されますので、
ファイルシステムの制限は重要ではありません。

デフォルトのブロックサイズを32kにすることで、最大テーブルサイズと最大カラム数と
を４倍にすることができます。

4.6) 一般的なテキストファイルからデータを保存するには、データベースのディスク容
量はどのくらい必要です？

普通のテキストファイルを PostgreSQL のデータベースに保存するには、最大で約5倍の
ディスク容量を必要とします。

例題として、各行に整数とテキスト記述を持つ 100,000行のファイルを考えてみましょ
う。テキストの文字列の平均長さを20バイトと仮定すると、フラットファイルの大きさ
は約2.8MB です。このデータを含む PostgreSQL データベースファイルの大きさは次の
ように約6.4MBと見積もることができます：

    32 bytes: 各ロウのヘッダ(概算)
    24 bytes: 整数(int)フィールドとテキスト(text)フィールド
   + 4 bytes: ページ上のタップルへのポインタ
   ----------------------------------------
   60 bytes per row

   PostgreSQL のデータページサイズは 8192バイト(8KB)なので:

   8192 bytes per page
   -------------------   =  136 rows per database page (切り捨て)
     60 bytes per row

   100000 data rows
   --------------------  =  782 database pages (切り上げ)
      128 rows per page
 
  735 database pages * 8192 bytes per page  =  6,021,120 bytes (6 MB)

インデックスは、これほどのオーバヘッドは要求しませんが、インデックス付けされる
データを含む以上、それなりに大きくなります。

NULLはビットマップとして保存されていて、それらがわずかにスペースを使います。

4.7) 定義されたテーブル、インデックス、データベース、および、ユーザをどのように
して見つけ出しますか？

psql にはいろいろなバックスラッシュ・コマンドがあり、こうした情報を表示します。
バックスラッシュ・コマンドの種類を見るには \? を使って下さい。また、pg_ で始ま
るシステムテーブルにも記述されています。さらに、psql -l はすべてのデータベース
をリスト表示します。

また、pgsql/src/tutorial/syscat.source ファイルを走らせてみて下さい。それは、沢
山の SELECT 文により必要な情報をデータベースのシステム・テーブルから取り出して
例示してくれます。

4.8) 問い合わせが遅いうえ、インデックスを使っている様子がありません。なぜですか
？

インデックスは自動的にすべての問い合わせで使われるわけではありません。テーブル
が最小サイズより大きく、問い合わせでそのわずかなパーセンテージのロウを選択する
時だけ、インデックスは使われます。これはインデックススキャンにより起こされるラ
ンダムなディスクアクセスは、テーブルをストレートに読む順次走査よりも遅くなるこ
とがあるからです。

インデックスを使うかを決定するために、PostgreSQL はテーブルについての統計情報を
持たなければなりません。この統計情報は、VACUUM ANALYZEまたは、単に ANALYZE を使
って収集することができます。統計情報を使ってオブティマイザはテーブルの中にある
ロウ数を知り、インデックスを使うべきかの決定をより正しくできます。統計情報は最
適な結合順や結合方法を決める上でも貴重なものもあります。統計情報の収集は、テー
ブルの内容がかわると毎に繰返しなされるべきです。

インデックスは、通常 ORDER BY や結合を行なうためには使われません。順次スキャン
に続く明示的ソートは、巨大なテーブルのインデックススキャンよりも普通は高速です
。

しかし、ORDER BYと組み合わされたLIMIT は、テーブルの小さな部分を返すためにたび
たびインデックスを使うでしょう。実際、MAX() や MIN() がインデックスを使わないと
しても、このような値を ORDER BY と LIMIT を使ってインデックスを使って取り出すこ
とが可能です:

    SELECT col
    FROM tab
    ORDER BY col [ DESC ]
    LIMIT 1;

もし、オプティマイザが間違ってシーケンシャルスキャンを選択したことに疑いがなけ
れば、SET enable_seqscan TO 'off'を使ってインデックススキャンでまちがいなく速く
なっているかをテストをしてみてください。

LIKE あるいは ~ のようなワイルドカード演算子は特別な環境でしか使えません：

 ・ 検索文字列が文字列の最初にききます。たとえば：
     □ LIKE パターンが%で始まらない
     □ ~ (正規表現) パターンは^で始まらなければならない
 ・ 検索文字列を文字クラスから始めることはできません。たとえば、[a-e]。
 ・ ILIKE や ~* のような大文字と小文字を区別しない検索は使えません。そのかわり
    、このFAQの4.12節で説明する関数のインデックスが使えます。
 ・ initdb においては、デフォルトでCロケールが使われなくてはなりません。その理
    由は、Cロケール以外では次に大きな文字を知ることができないからです。このよう
    な場合、
   
    LIKE
    
    インデクシングにだけ働くような、特別な
   
    text_pattern_ops
    
    インデックスを作成することもできます。

8.0より前のリリースでは、インデックスは、データ型がちょうどインデックスのカラム
の型と一致しなければ、使えないことがしばしばありました。おそらく、int2, int8,
および numeric 等のカラムのインデックスがそうです。

[訳注：強制的にインデックスを使うには SET enable_seqscan = off を実行します。 ]

4.9) 問い合わせオブティマイザがどのように問い合わせを評価するのかを見るにはどう
しますか？

オンラインマニュアルで EXPLAIN を見て下さい。

4.10) R-tree インデックスとは何ですか？

R-tree インデックスは空間的なデータにインデックスを付けるために使われます。ハッ
シュインデックスでは範囲の検索ができません。また、B-tree インデックスでは、１次
元でしか範囲の検索ができません。R-tree インデックスであれば多次元のデータを扱え
ます。たとえば、もし R-tree インデックスを point 型の属性に付けることができると
するとシステムは、「長方形に囲まれた点をすべて選択する」というような問い合わせ
に、より効率良く答えられます。

R-Tree の設計の原典となる権威ある論文は:

Guttman, A. "R-Trees: A Dynamic Index Structure for Spatial Searching."
Proceedings of the 1984 ACM SIGMOD Int'l Conf on Mgmt of Data, 45-57.

この論文は、Stonebraker 教授の "Readings in Database Systems" でも取り上げられ
ています。

    [訳注：
          奈良先端大の石川佳治さんよりR-Tree関係の文献を紹介して頂きました。
        日本語 Postgres ML のアーカイブから "Subject: [postgres95 801] spatial data structures" 
                http://www.sra.co.jp/people/t-ishii/PostgreSQL/mhonarc/pgsql-jp/1996Oct/msg00007.html
        をご覧下さい。
    ]

組込みの R-Tree でポリゴンやボックスを操作できます。理論的にはR-Tree はもっと高
い次元を操作するようにも拡張できます。実質的には、R-Tree の拡張にはちょっとした
作業が必要でして、現在、我々はそれをどのようにするかについての文書を持っていま
せん。

    [訳注：
        R-Tree インデックスはGiSTで開発されています。
        http://www.sai.msu.su/~megera/postgres/gist/
    ]

4.11) 遺伝的問い合わせ最適化とは何ですか？

GEQO モジュールは、沢山のテーブルを結合するときに、遺伝的アルゴリズム(GA)で問合
わせを高速化します。これにより、しらみつぶしに探索を行なわなくても、大きな結合
(join queries)を扱うことができるようになります。

4.12) 正規表現での検索や大文字と小文字とを区別しない正規表現検索はどのように実
現しますか？大文字と小文字とを区別しない検索のためのインデックスはどのように使
いますか？

~演算子は正規表現照合を行ない、~* は大文字と小文字を区別しない
(case-insensitive)正規表現照合を行います。大文字と小文字を区別しない LIKE 演算
子を ILIKE といいます。

大文字と小文字を区別しない等値比較は次のように表現できる：

    SELECT *
    FROM tab
    WHERE lower(col) = 'abc';

標準インデックスでは使われず、しかしながら、もし関数インデックスを作ったならそ
れが使われるでしょう。

   CREATE INDEX tabindex ON tab (lower(col));
   

4.13) 問い合わせの中で、フィールドが NULL であることを検出するにはどうしますか
？

カラムを IS NULL と IS NOT NULL とで試してみます。

4.14) 様々な文字型のそれぞれの違いは何ですか？

Type            Internal Name   Notes
--------------------------------------------------
VARCHAR(n)      varchar         最大長のサイズを指定する、詰め物無し
CHAR(n)         bpchar          指定された固定長となるように空白が詰められる
TEXT            text            長さに上限の無いテキスト
BYTEA           bytea           可変長のバイト配列(null-byte safe)
"char"          char            １文字

内部名にお目にかかるのは、システム・カタログを調べるときや、エラーメッセージを
受け取るときです。

上記の型のうち最初の４つの型は "varlena" 型です(すなわち、ディスクの最初の４バ
イトがデータ長で、それの後に実際のデータが続きます)。このように実際の空間は宣言
された大きさよりも少し大きくなります。しかし、これらのデータ型はTOASTにより圧縮
されたり複数ロウに渡って保存されたりして、ディスク上の空間は思ったより小さくな
ります。

VARCHAR(n) は可変長の文字列を保存するのに最適ですが、保存できる文字列の長さに制
限があります。TEXT は長さに制限の無い文字列の保存のためのもので、最大で 1ギガバ
イトです。 CHAR(n)は、VARCHAR(n)が与えられた文字だけを保存するのに対し、ブラン
クを詰め込んでいつも同じ長さで文字列を保存するのに最適です。BYTEAは、部分的に
NULL のバイトを含むバイナリデータを保存するためのものです。これらのタイプは同じ
くらいの性能特性をもちます。

4.15.1) 通番(serial)／自動増分フィールドはどのようにつくりますか？

PostgreSQL は SERIAL データ型をサポートします。カラム上にシーケンスを自動作成し
ます。たとえば、

        CREATE TABLE person ( 
                id   SERIAL, 
                name TEXT 
        );

は自動的に次のように翻訳されます:

        CREATE SEQUENCE person_id_seq;
        CREATE TABLE person ( 
                id   INT4 NOT NULL DEFAULT nextval('person_id_seq'),
                name TEXT 
        );

    [訳注：
        CREATE UNIQUE INDEX person_id_key ON person ( id );
        は、 7.3 からは自動的には行なわれなくなりました。
    ]

通番についてのもっと詳しい情報は、オンラインマニュアルで create_sequence をご覧
下さい。

また、各ロウのOIDフィールドを一意値として使うこともできます。しかしながら、もし
もデータベースをダンプしてリロードする必要がある場合は、OIDを温存するために
pg_dump で -oオプションを使うか、または、COPY WITH OIDSオプションを使う必要があ
ります。

4.15.2) SERIALデータ型に挿入される値は、どうすれば得られますか？

ひとつの方法は、nextval() 関数を使ってその値を挿入する前(before)に SEQUENCE オ
ブジェクトから次の SERIAL 値を取り出し、それから実際に挿入をすることです。
4.15.1 のテーブルの例を使うとすると、疑似言語ではこのようになります。

        new_id = execute("SELECT nextval('person_id_seq')");
        execute("INSERT INTO person (id, name) VALUES (new_id, 'Blaise Pascal')");

そうして、new_id に保存した新しい値を他の問い合わせに(たとえば、person テーブル
に対する外部キー(foreign key)のように)使うとよいでしょう。自動的に作られた
SEQUENCEオブジェクトの名前は、<table>_<serialcolumn>_seq のようになり、このうち
、table と serialcolumn はそれぞれテーブルの名前とSERIALカラムの名前です。

あるいは、与えられたSERIAL値を、それが既定値として挿入された後で(after)、
currval() 関数を使って取り出すこともできます。たとえば、

        execute("INSERT INTO person (name) VALUES ('Blaise Pascal')");
        new_id = execute("SELECT currval('person_id_seq')");

最後に、INSERT文から返るOIDを使って、既定値をみつけることもできますが、しかし、
oidの値は40億に達するともとに戻ってしまい、最も移植性の低いやり方となるでしょう
。Perl DBI の DBD::Pg モジュールを使えば、$sth->execute() の後に $sth->
{pg_oid_status} を経由してその OID 値を使えるようにすることはできます。

4.15.3) currval() は他のユーザとの競合状態に陥ることはないですか？

それはありません。currval() は、すべてのユーザではありませんが、あなたのバック
エンドに与えられた現在の値を返します。

4.15.4) トランザクションが中断したときにもういちどシーケンス番号が使われないの
はなぜですか？シーケンス／SERIALカラムに空きがあるのはなぜですか？

同時性を改善するために、実行中のトランザクションに、必要でトランザクションが終
了するまでロックされないシーケンス値を与えています。このためトランザクションが
中断されると番号割り当てにギャップを生じます。

4.16) OID とは何ですか？ TID とは何ですか？

OID とは一意のロウID に対する PostgreSQL の答えです。PostgreSQL の中でつくられ
るすべてのロウは一意の OID を得ます。initdb で発生される OID はすべて 16384
(include/access/transam.h から)より小さな値です。initdb 後のすべての OID (ユー
ザ作成)はそれ以上の値になります。既定では、これらすべての OIDは一つのデーブルや
データベース内に留まらず、PostgreSQL インストレーション全体の中で一意です。

PostgreSQL はテーブル間のロウを結びつけるために、そのシステムテーブル内に OID
を使います。この OID は特定のユーザのロウを識別するためや結合の中で使われること
ができます。OID の値を保存するためには OID 型をカラムに使うことを奨めます。より
速くアクセスするために OID フィールドにインデックスを作ることができます。 OID
は、全てのデータベースで使われる中央領域から、全ての新しいロウに割り当てられま
す。OID を他の何かに変えたい、あるいは元の OID もテーブルと一緒にコピーしたいの
なら、できなくはありません。

        CREATE TABLE new_table(mycol int);
        SELECT oid AS old_oid, mycol INTO tmp_table FROM old_table;
        COPY tmp_table TO '/tmp/pgtable';
        COPY new_table WITH OIDS FROM '/tmp/pgtable';
        DROP TABLE tmp_table;

OID は、4バイトの整数として保存されているので、40億を越えると溢れてしまうでしょ
う。誰もこれが起きたと報告してくる人はいませんでしたが、そうなる前にこの制限を
取り除くことを計画しています。

TID は特定の物理ロウをそのブロックとオフセット値で識別するために使われます。TID
はロウが修正されたり再ロードされると変わります。それらの TID は、物理ロウを指す
ためにインデックス記載で使われます。

4.17) PostgreSQL で使われるいくつかの用語の意味は何ですか？

いくつかのソースコードや古い文書の中には、それぞの専門分野の中でもっと一般的に
使われる専門用語が使われています。

 ・ テーブル(table)、関係(relation)、クラス(class)
 ・ ロウ(row)、レコード(record)、タップル(tuple)
 ・ カラム(column)、フィールド(field)、属性(attribute)
 ・ 取得(retrieve)、選択(select)
 ・ 置換(replace)、更新(update)
 ・ 追加(append)、挿入(insert)
 ・ OID, 連番(serial value)
 ・ ポータル(portal), カーソル(cursor)
 ・ 領域変数(range variable)、テーブル名(table name)、テーブル別名(table alias)

一般的なデータベース用語のリストは：http://hea-www.harvard.edu/MST/simul/
software/docs/pkgs/pgsql/glossary/glossary.html で見つけられます。

4.18) エラーメッセージ "ERROR: Memory exhausted in AllocSetAlloc()"が出るのはな
ぜですか？

おそらく、システムの仮想メモリーを全て使い果たしてしまっている可能性があるか、
カーネルがあるリソースについてもつ制限値が低すぎる可能性があります。 postmaster
を始動する前にこれを試してみて下さい：

        ulimit -d 262144
        limit datasize 256m

シェルによって、どちらかひとつが成功するでしょうが、これはプロセスのデータセグ
メント制限をより高く設定し、たぶん問い合わせが完結するようになるでしょう。この
コマンドは現行のプロセスと、このコマンドを走らせた後に作られる全てのサブプロセ
スについて適用されます。バックエンドがとても多くのデータを返すためにSQL クライ
アントで問題が続いているのであれば、クライアントを開始する前にこれを試してみて
ください。

4.19) どのバージョンの PostgreSQL を走らせているかを調べるにはどうしますか？

psql から SELECT version(); をタイプします。

4.20) ラージ・オブジェクトの操作でinvalid large obj descriptor を受け取りました
。なぜでしょうか？

ラージ・オブジェクト操作をするときは、前後にBEGIN WORKとCOMMITを付ける必要があ
ります。すなわち、lo_open ... lo_closeをはさみ込みます。

現在は、PostgreSQLのトランザクションのコミット時にラージ・オブジェクト・ハンド
ルを閉じることにより、lo_openコマンドが完了した直後に強制的にルールを実行します
。このため、最初にハンドルに対して何かをしようとすると、invalid large obj
descriptor(ラージ・オブジェクトの記述子が不正)となります。それで、もし、トラン
ザクションを使うのを忘れると、（少なくともほとんどの時間）働いていたコードがエ
ラーメッセージを出すのです。

もし、ODBCのようなクライアントインターフェイスをお使いなら、auto-commit offを設
定する必要があるかもしれません。

4.21) 現在の時刻がデフォルトとなるようなカラムはどのようにつくりますか？

CURRENT_TIMESTAMPを使います:

        CREATE TABLE test (x int, modtime timestamp DEFAULT CURRENT_TIMESTAMP );

4.22) なぜ、INを使う副問い合わせがとても遅いのですか？

7.4 より前のバージョンでは、副問い合わせは、副問い合わせの結果を外部問い合わせ
の各ロウについて順次走査することによって、外部の問い合わせに結合させられる。副
問い合わせがわずかなロウしか返さず、外部問い合わせが沢山のロウを返す場合は、IN
が最も早いです。他の問い合わせを高速化するには、INをEXISTSに置換します:

        SELECT *
        FROM tab
        WHERE col IN (SELECT subcol FROM subtab)

を、置き換えて：

        SELECT *
        FROM tab
        WHERE EXISTS (SELECT subcol FROM subtab WHERE subcol = col)

とします。これが手っ取り早いですが、subcolは索引付きカラムであるべきです。

バージョン7.4以降では、INは、通常の問い合わせと同様の洗練されたジョインの技術を
実際に使い、EXISTSを使うことを好みます。

4.23) 外部結合(outer join)はどのように実現しますか?

PostgreSQL は SQL 標準構文を使う外部結合(アウタージョイン)をサポートします。こ
こに 2つの例題があります。

        SELECT *
        FROM t1 LEFT OUTER JOIN t2 ON (t1.col = t2.col);

あるいは

        SELECT *
        FROM t1 LEFT OUTER JOIN t2 USING (col);

これらの象徴的な問い合わせでは t1.col を t2.col と結合して、t1 の結合されなかっ
たロウ(t2 と一致しなかったロウ)も返しています。RIGHT 結合は t2 の結合されなかっ
たロウを加えるでしょう。FULL 結合は、一致したロウに t1 と t2 からは結合されなか
ったロウを返すでしょう。OUTER という言葉はオプションで LEFT, RIGHT, または FULL
などの結合を仮定されています。通常、結合はINNER結合と呼ばれます。以前のリリース
では外部結合(outer join)をUNION と NOT IN を使ってシミュレートできます。たとえ
ば、tab1 と tab2 を結合するときは、次の問い合わせで二つのテーブルを外部結合しま
す。

        SELECT tab1.col1, tab2.col2
        FROM tab1, tab2
        WHERE tab1.col1 = tab2.col1
        UNION ALL
        SELECT tab1.col1, NULL
        FROM tab1
        WHERE tab1.col1 NOT IN (SELECT tab2.col1 FROM tab2)
        ORDER BY col1

4.24) 複数のデータベースを使う問い合わせはどのようにすればできますか？

現行のデータベース以外への問い合わせ方法はありません。というのもPostgreSQLがデ
ータベース仕様のシステムカタログを読み込むためで、そこには、たとえそのふりをす
るだけにしろ、データベースを越えて問い合わせをするすべがありません。

contrib/dblink はデータベース間(cross-database)の問い合わせを関数呼出しにより許
します。もちろん、クライアントは同時に接続を別のデータベースへも張らなくてはな
らず、結果をクライアント側でマージしなくてはなりません。

4.25) 関数で複数のロウまたはカラムを返すにはどうしますか？

7.3では関数から、複数のロウや複数カラムを簡単に返せます。 http://
techdocs.postgresql.org/guides/SetReturningFunctions。

4.26)なぜ、PL/PgSQL 関数の中から一時テーブルを確実に create/drop することができ
ないのでしょうか？

PL/PgSQL は関数の内容をキャッシュし、その不幸な副作用のため、もし PL/PgSQL 関数
が一時テーブルにアクセスすると、そのテーブルはあとでドロップされ再作成されます
が、関数が再び呼び出されると、キャッシュされているその関数の内容はまだ古い一時
テーブルを依然として指しているからです。解決策は、 PL/PgSQL の中で EXECUTE を一
時テーブルアクセスのために使うことです。これで、毎回問い合わせをパースし直すこ
とになるでしょう。

4.27) どのような暗号化オプションを利用できますか?

 ・ contrib/pgcryptoにはSQL問い合わせの中で使うための沢山の暗号化を含みます。
 ・ クライアントとサーバとの間の伝送を暗号化するには、サーバではpostgresql.conf
    のsslオプションをtrue に設定し、pg_hba.confには適用するhostあるいはhostssl
    の行がなくてはなりません。そして、クライアントではsslmodeをdisableにしては
    なりません。 (PostgreSQL純正のSSL接続のかわりに、stunnel や ssh サードパー
    ティ製の暗号化転送を使うことも可能であることも記しておきます。)
 ・ バージョン7.3 ではデータベースユーザのパスワードは保存される時に自動的に暗
    号化されます。それより前のバージョンではpostgresql.conf中で
    PASSWORD_ENCRYPTIONを有効にする必要があります。
 ・ サーバーを走らせるのに暗号化ファイルシステムを使うこともできます。

[訳注
   レプリケーション関連の項目がなくなりましたが、訳注のみ残してあります。

    Jan Wieckさんによるカスケード可能なマスター・スレーブ型のレプリケーション Slony-I 
        http://gborg.postgresql.org/project/slony1/projdisplay.php

    石井達夫さんによるコネクションプール サーバ PGPool
        http://www2b.biglobe.ne.jp/~caco/pgpool/

    三谷篤さんによるマルチマスタ方式の同期レプリケーション PGCluster
        http://www.csra.co.jp/~mitani/jpug/pgcluster/index.html

    JPUG 分散トランザクション開発分科会では、永安悟史さんが２相コミット
    の実装を行いました。
        http://www.postgresql.jp/wg/dt/index.html
]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

                        PostgreSQLの拡張についての質問                         
                                                                               
5.1) 自分で書いたユーザ定義関数を psql の中で実行するとコア・ダンプしてしまうの
はなぜですか？

問題は色々と考えられますが、まず最初に、作成したユーザ定義関数を単独のテストプ
ログラムにして試してみて下さい。

5.2) PostgreSQL 用に書いたちょっと素敵な新しい型や関数を提供してプロジェクトに
貢献したいのですが？

皆さんの行なった拡張を、pgsql-hackers メーリング・リストに送ってください。そし
て、ゆくゆくはそうした拡張が contrib/ サブディレクトリの中に入ることになるでし
ょう。

5.3) タプルを返す C言語の関数はどのように書きますか？

バージョン7.3以降のPostgreSQLでは、テーブルを返す関数を C, PL/PgSQL、そして SQL
にて完全にサポートします。詳しくはプログラマガイドの情報を見てください。Cで定義
された表を返す関数の例題がcontrib/tablefuncの中にあります。

5.4) ソース・ファイルを変更しました。再コンパイルしても変化が見られないのはなぜ
ですか？

いくつかの Makefile がインクルード・ファイルに対して適切な依存関係を持っていま
せん。make clean をしてからもう一度 make を行なわなくてはなりません。もし、GCC
をお使いであれば configure の --enable-depend オプションを使って、コンパイラに
依存関係を自動的に調べさせることもできます。

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

[訳注：
  日本語版の製作については以下の通りです。

  最終更新日:   2005年01月12日
  翻訳者:       桑村 潤 (Jun Kuwamura <juk at PostgreSQL.jp>)

  このFAQの和訳の作成にあたり協力をしてくださった方々(敬称は略させていただきます):

                田仲 稔(Minoru TANAKA <Tanaka.Minoru at keiken.co.jp>)
                石井 達夫(Tatsuo ISHII <t-ishii at sra.co.jp>)
                齊藤 知人(Tomohito SAITOH <tomos at elelab.nsc.co.jp>)
                馬場  肇(Hajime BABA <baba at kusastro.kyoto-u.ac.jp>)
                岡本 一幸(Kazuyuki OKAMOTO <kokamoto at itg.hitachi.co.jp>)
                小菅 昭一(Shoichi Kosuge <s-kosuge at str.hitachi.co.jp>)
                山下 義之(Yoshiyuki YAMASHITA <dica at eurus.dti.ne.jp>)
                境 真太郎(Sintaro SAKAI <s_sakai at mxn.mesh.ne.jp>)
                生越 昌己(Masami OGOSHI <ogochan at zetabits.com>)
                石川 俊行(Toshiyuki ISHIKAWA <tosiyuki at gol.com>)
                本田 茂広(Shigehiro HONDA <fwif0083 at mb.infoweb.ne.jp>)
                せせ じゅん(Jun SESE <sesejun at linet.gr.jp>)
                神谷 英孝(Hidetaka KAMIYA <hkamiya at catvmics.ne.jp>)
                菅原 敦(Atsushi SUGAWARA <asugawar at f3.dion.ne.jp>)
                稲葉 香理(Kaori Inaba <i-kaori at sra.co.jp>)
                石井 達夫(Tatsuo Ishii <t-ishii at sra.co.jp>)

  をはじめ、ポストグレスに関する話題豊富な日本語ポストグレス・メーリングリスト、
和訳のきっかけを作ってくれた JF(Linux Japanese FAQ Mailing List)プロジェクト、FreeBSD ドキュメンテーションプロジェクト、
その他、直接あるいは間接的にかかわっているすべてのオープンソースコミュニティーの皆さんに感謝します。

  日本語版のこの文書は、以下からもたどれます。
        http://www.rccm.co.jp/~juk/pgsql/(FAQ和訳 PostgreSQL についてよくある質問)
        http://www.PostgreSQL.jp/wg/jpugdoc/JPUG文書・書籍関連分科会
        http://www.linux.or.jp/JF/Linux JFプロジェクト

  なお、この和訳に関するご意見は(juk at PostgreSQL.jp)までお寄せ下さい。
]

