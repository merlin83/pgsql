#!/bin/sh
#
# pg_upgrade: update a database without needing a full dump/reload cycle.
# CAUTION: Read the manual page before trying to use this!

#set -x

# Set this to "Y" to enable this program
ENABLE="N"

# UPGRADE_VERSION is the expected old database version
UPGRADE_VERSION="7.1"

# Hard-wired from pg_class in 7.1.  I wish there was another way.
# Are these fixed values for that release? XXX
SRC_LARGEOBJECT_OID=16948
SRC_LARGEOBJECT_IDX_OID=17148

# $Header: /home/rubik/work/pgcvs/CVSROOT/pgsql/src/bin/pg_dump/Attic/pg_upgrade,v 1.29 2002-01-11 20:34:14 momjian Exp $
#
# NOTE: we must be sure to update the version-checking code a few dozen lines
# below for each new PostgreSQL release.

trap "rm -f /tmp/$$.*" 0 1 2 3 15

SCHEMA=""
while [ "$#" -gt 1 ]
do
	if [ "X$1" = "X-s" ]
	then	SCHEMA="$2"
		if [ ! -s "$SCHEMA" ]
		then	echo "$SCHEMA does not exist" 1>&2
			exit 1
		fi
		shift 2
	else	echo "Usage:  $0 -s schema_dump old_data_dir" 1>&2
		exit 1
	fi
done

if [ "$#" -ne 1 -o ! "$SCHEMA" ]
then	echo "Usage:  $0 -s schema_dump old_data_dir" 1>&2
	exit 1
fi

OLDDIR="$1"

# check things

if [ ! -d "./data" ]
then	echo "`basename $0` must be run from the directory containing the database directory \`data\' (`dirname $PGDATA`.)" 1>&2
	echo "You must have run initdb to create the template1 database." 1>&2
	exit 1
fi

if [ ! -d "./$OLDDIR" ]
then	echo "You must rename your old data directory to $OLDDIR and run initdb." 1>&2
	exit 1
fi

if [ ! -d "./data/base/1" ]
then	echo "Cannot find database template1 in ./data/base." 1>&2
	echo "Are you running $0 as the postgres superuser?" 1>&2
	exit 1
fi

if [ ! -d "./$OLDDIR/base/1" ]
then	echo "There is no database template1 in ./$OLDDIR/base." 1>&2
	exit 1
fi

if [ ! -r "./data/PG_VERSION" ]
then	echo "Cannot read ./data/PG_VERSION --- something is wrong." 1>&2
	exit 1
fi

if [ ! -r "./$OLDDIR/PG_VERSION" ]
then	echo "Cannot read ./$OLDDIR/PG_VERSION --- something is wrong." 1>&2
	exit 1
fi

# Get the actual versions seen in the data dirs.

DEST_VERSION=`cat ./data/PG_VERSION`
SRC_VERSION=`cat ./$OLDDIR/PG_VERSION`

# Check for version compatibility.
# This code will need to be updated/reviewed for each new PostgreSQL release.

if [ "$DEST_VERSION" != "$UPGRADE_VERSION" -a "$DEST_VERSION" != "$SRC_VERSION" ]
then	echo "`basename $0` is for PostgreSQL version $UPGRADE_VERSION, but ./data/PG_VERSION contains $DEST_VERSION." 1>&2
	echo "Did you run initdb for version $UPGRADE_VERSION?" 1>&2
	exit 1
fi

# Check that input database is of a compatible version (anything with the same
# physical layout of user tables and indexes should be OK).  I did not write
# something like "$SRC_VERSION -ge $UPGRADE_VERSION" because test(1) isn't bright
# enough to compare dotted version strings properly.  Using a case statement
# looks uglier but is more flexible.

if [ "$ENABLE" != "Y" ]
then
	case "$SRC_VERSION" in
#	    7.2) ;;
	    *)	echo "Sorry, `basename $0` cannot upgrade database version $SRC_VERSION to $DEST_VERSION." 1>&2
		echo "The on-disk structure of tables has changed." 1>&2
		echo "You will need to dump and restore using pg_dumpall." 1>&2
		exit 1;;
	esac
fi

# check for proper pg_resetxlog version

pg_resetxlog 2>/dev/null
# file not found status is normally 127, not 1
if [ "$?" -ne 1 ]
then	echo "Unable to find pg_resetxlog in path.
Install it from pgsql/contrib/pg_resetxlog and continue.;  exiting" 1>&2
	exit 1
fi

if ! pg_resetxlog -x 2>&1 | grep -q XID
then	echo "Old version of pg_resetxlog found in path.
Install a newer version from pgsql/contrib/pg_resetxlog.;  exiting" 1>&2
	exit 1
fi

# If the XID is > 2 billion, 7.1 database will have non-frozen XID's in 
# low numbers, and 7.2 will think they are in the future --- bad.

SRC_XID=`pg_resetxlog -n "$OLDDIR" | grep "NextXID" | awk -F'  *' '{print $4}'`
if [ "$SRC_VERSION" = "7.1" -a "$XID" -gt 2000000000 ]
then	echo "XID too high for $0.;  exiting" 1>&2
	exit 1
fi
DST_XID=`pg_resetxlog -n data | grep "NextXID" | awk -F'  *' '{print $4}'`

# compare locales to make sure they match

pg_resetxlog -n "$OLDDIR" | grep "^LC_" > /tmp/$$.0
pg_resetxlog -n data | grep "^LC_" > /tmp/$$.1
if ! diff /tmp/$$.0 /tmp/$$.1 >/dev/null
then	echo "Locales do not match between the two versions.;  exiting" 1>&2
	exit 1
fi


###################################
# Checking done.  Ready to proceed.
###################################


# Execute the schema script to create everything

psql "template1" < "$SCHEMA"
if [ $? -ne 0 ]
then	echo "There were errors in the input script $SCHEMA.
$0 aborted." 1>&2
	exit 1
fi

echo "Input script $SCHEMA complete, fixing row commit statuses..."

# XXX do we still need this?
# Now vacuum each result database because our movement of transaction log
# causes some committed transactions to appear as non-committed

vacuumdb -a
if [ $? -ne 0 ]
then	echo "There were errors during VACUUM.
$0 aborted." 1>&2
	exit 1
fi

# Used for scans looking for a database/table name match
# New oid is looked up
pg_dumpall -s > /tmp/$$.3 2>/dev/null
if [ "$?" -ne 0 ]
then	echo "Unable to dump schema of new database.;  exiting" 1>&2
	exit 1
fi

# Get pg_largeobject oids for movement

DST_LARGEOBJECT_OID=`psql -d template1 -At -c "SELECT oid from pg_class where relname = 'pg_largeobject';"`
DST_LARGEOBJECT_IDX_OID=`psql -d template1 -At -c "SELECT oid from pg_class where relname = 'pg_largeobject_loid_pn_index';"`
if [ "$LARGEOBJECT_OID" -eq 0 -o "$LARGEOBJECT_IDX_OID" -eq 0 ]
then	echo "Unable to find large object oid.;  exiting" 1>&2
	exit 1
fi

if [ "$SRC_VERSION" = "$DST_VERSION" ]
then	# Versions are the same so we can get pg_largeobject oid this way
	SRC_LARGEOBJECT_IDX_OID="$DST_LARGEOBJECT_OID"
	SRC_LARGEOBJECT_IDX_OID="$DST_LARGEOBJECT_IDX_OID"
fi

# we are done with SQL database access
# shutdown forces buffers to disk

pg_ctl -w stop
if [ "$?" -ne 0 ]
then	echo "Unable to stop database server.;  exiting" 1>&2
	exit 1
fi

echo "Commit fixes complete, moving data files..."

# Move table/index/sequence files

cat "$SCHEMA" | while read LINE
do
	if /bin/echo "$LINE" | grep -q '^\\connect [^	]*$'
	then	OLDDB="$DB"
		DB="`/bin/echo \"$LINE\" | cut -d' ' -f2`"
		if [ "$DB" = "-" ]
		then	DB="$OLDDB"
		fi
		if [ "$DB" = "template1" -o "$DB" = "template0" ]
		then	DB=""
		fi
	fi
	if echo "$LINE" | grep -q "^-- TOC Entry ID [0-9]* (OID "
	then	OID="`echo \"$LINE\" | cut -d' ' -f7 | tr -d ')'`"
	fi
	if echo "$LINE" | egrep -q "^-- Name: [^ ]* Type: (TABLE|INDEX|SEQUENCE) "
	then	TABLE="`echo \"$LINE\" | cut -d' ' -f3`"
		# skip system tables
		if [ "`echo \"$TABLE\" | cut -c 1-3`" = "pg_" ]
		then	TABLE=""
		fi
	fi
	if [ "$DB" -a "$OID" -a "$TABLE" ]
	then
		NEWOID=`awk -F' ' '
				BEGIN 	{ newdb=""; newoid="";
					  newtable=""; ret=0;}
				$1 == "\\\\connect" && $2 != "-" {newdb=$2;}
				$0 ~ /^-- TOC Entry ID [0-9]* .OID / \
					{ newoid = substr($7, 1, length($7)-1);}
				{print $0 >> "/tmp/x";
				print $3 >> "/tmp/x";
				print newdb," ", newoid >> "/tmp/x"}
				($0 ~ /^-- Name: [^ ]* Type: TABLE / || \
				 $0 ~ /^-- Name: [^ ]* Type: INDEX / || \
				 $0 ~ /^-- Name: [^ ]* Type: SEQUENCE /) && \
				newdb == "'"$DB"'" && \
				$3 == "'"$TABLE"'" \
					{ ret=newoid; exit}
				END { print ret;}' /tmp/$$.3`
		if [ "$NEWOID" -eq 0 ]
		then	echo "Move of database $DB, OID $OID, table $TABLE failed.
New oid not found;  exiting" 1>&2
			exit 1
		fi

		# We use stars so we don't have to worry about database oids

		# Test to make sure there is exactly one matching file on each place

 		if [ `ls "$OLDDIR"/base/*/"$OID" | wc -l` -eq 0 ]
		then	echo "Move of database $DB, OID $OID, table $TABLE failed.
File not found;  exiting" 1>&2
			exit 1
		fi
  		if [ `ls "$OLDDIR"/base/*/"$OID" | wc -l` -gt 1 ]
		then	echo "Move of database $DB, OID $OID, table $TABLE failed.
Too many found;  exiting" 1>&2
			exit 1
		fi
		if [ `ls data/base/*/"$NEWOID" | wc -l` -eq 0 ]
		then	echo "Move of database $DB, OID $OID, table $TABLE to $NEWOID failed.
File not found;  exiting" 1>&2
			exit 1
		fi
		if [ `ls data/base/*/"$NEWOID" | wc -l` -gt 1 ]
		then	echo "Move of database $DB, OID $OID, table $TABLE to $NEWOID failed.
Too many found;  exiting" 1>&2
			exit 1
		fi

		# Move files

		SRCDB=`basename \`dirname $OLDDIR"/base/*/"$OID"\``
		DSTDB=`basename \'dirname data/base/*/"$NEWOID"\``
		mv -f "$OLDIR"/base/"$SRCDB"/"$OID" data/base/"$DSTDB"/"$NEWOID"
		if [ "$?" -ne 0 ]
		then	echo "Move of database $DB, OID $OID, table $TABLE 
to $NEWOID failed.;  exiting" 1>&2
			exit 1
		fi
		# handle table extents
		ls "$OLDDIR"/base/"$SRCDB"/"$OID".* | while read FILE
		do
			EXT=`basename "$FILE" | sed 's/[^[^\.]*\.\(.*\)$/\1/'`
			mv -f "$FILE" data/base/"$DSTDB"/"$NEWOID"."$EXT"
			if [ "$?" -ne 0 ]
			then	echo "Move of database $DB, OID $OID, table $TABLE 
to $NEWOID failed.;  exiting" 1>&2
				exit 1
			fi
		done

		# handle pg_largeobject
		# We use the unique oid's to tell use where to move the
		# pg_largeobject files.

		if [ -f "$OLDIR"/base/"$SRCDB"/"$SRC_LARGEOBJECT_OID" ]
		then	mv "$OLDIR"/base/"$SRCDB"/"$SRC_LARGEOBJECT_OID" \
				data/base/"$DSTDB"/"$DST_LARGEOBJECT_OID"
			if [ "$?" -ne 0 ]
			then	echo "Move of large object for database $DB
to $NEWOID failed.;  exiting" 1>&2
				exit 1
			fi
	 		# handle table extents
			ls "$OLDDIR"/base/"$SRCDB"/"$SRC_LARGEOBJECT_OID".* | while read FILE
			do
				EXT=`basename "$FILE" | sed 's/[^[^\.]*\.\(.*\)$/\1/'`
				mv -f "$FILE" data/base/"$DSTDB"/"$DST_LARGEOBJECT_OID"."$EXT"
				if [ "$?" -ne 0 ]
				then	echo "Move of large object for database $DB
to $NEWOID failed.;  exiting" 1>&2
					exit 1
				fi
			done
		fi

		# Handle pg_largeobject_loid_pn_index
		if [ -f "$OLDIR"/base/"$SRCDB"/"$SRC_LARGEOBJECT_IDX_OID" ]
		then	mv "$OLDIR"/base/"$SRCDB"/"$SRC_LARGEOBJECT_IDX_OID" \
				data/base/"$DSTDB"/"$DST_LARGEOBJECT_IDX_OID"
			if [ "$?" -ne 0 ]
			then	echo "Move of large object for database $DB
to $NEWOID failed.;  exiting" 1>&2
				exit 1
			fi
	 		# handle table extents
			ls "$OLDDIR"/base/"$SRCDB"/"$SRC_LARGEOBJECT_IDX_OID".* | while read FILE
			do
				EXT=`basename "$FILE" | sed 's/[^[^\.]*\.\(.*\)$/\1/'`
				mv -f "$FILE" data/base/"$DSTDB"/"$DST_LARGEOBJECT_IDX_OID"."$EXT"
				if [ "$?" -ne 0 ]
				then	echo "Move of large object for database $DB
to $NEWOID failed.;  exiting" 1>&2
					exit 1
				fi
			done
		fi
		TABLE=""
	fi
done


# Set this so future backends don't think these tuples are their own
# because it matches their own XID.
# Commit status already updated by vacuum above
# Set to maximum XID just in case SRC wrapped around recently and
# is lower than DST's database
if [ "$SRC_XID" -gt "$DST_XID" ]
then	MAX_XID="$SRC_XID"
else	MAX_XID="$DST_XID"
fi

pg_resetxlog -x "$MAX_XID" data
if [ "$?" -ne 0 ]
then	echo "Unable to set new XID.;  exiting" 1>&2
	exit 1
fi

# Move over old WAL

rm -r data/pg_xlog
mv -f "$OLDDIR"/pg_xlog data

# Set last checkpoint location from old database

CHKPOINT=`pg_resetxlog -n "$OLDDIR" | grep "checkpoint location:" |
	awk -F'  *' '{print $4}'`
if [ "$CHKPOINT" = "" ]
then	echo "Unable to get old checkpoint location.;  exiting" 1>&2
	exit 1
fi

# Set checkpoint location of new database

pg_resetxlog -l `echo "$CHKPOINT" | tr '/' ' '` data
if [ "$?" -ne 0 ]
then	echo "Unable to set new checkpoint location.;  exiting" 1>&2
	exit 1
fi

# Restart server with moved data

pg_ctl -w start
if [ "$?" -ne 0 ]
then	echo "Unable to restart database server.;  exiting" 1>&2
	exit 1
fi

# Set sequence values for 7.1-version sequences, which were int4.

if [ "$SRC_VERSION" = "7.1" ]
then	echo "Set int8 sequence values from 7.1..."

	psql -d template1 -At -c "SELECT datname FROM pg_database" | 
	grep -v '^template0$' | # template1 OK
	while read DB
	do	
		echo "$DB"
		# XXX is concurrency a problem here?
		psql -d "$DB" -At -c "SELECT relname FROM pg_class where relkind = 'S';" |
		grep -v '^pg_' | # no system tables
		while read SEQUENCE
		do
			psql -d "$DB" -At <<SQL_END

-- This table matches the 7.1 sequence schema
CREATE TABLE pg_upgrade_temp_seq_int4 (
	sequence_name name
	last_value    integer
	increment_by  integer
	max_value     integer
	min_value     integer
	cache_value   integer
	log_cnt       integer
	is_cycled     "char"
	is_called     "char"
);

-- Move int8 columns of sequence out of the way
UPDATE pg_attribute
SET attrelid = 1 -- OID of template1, not used anywhere else  XXX correct?
WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = '$SEQUENCE');

-- Replace with int4 sequence columns
UPDATE pg_attribute
SET attrelid = 
	(SELECT oid FROM pg_class WHERE relname = '$SEQUENCE')
WHERE attrelid = 
	(SELECT oid FROM pg_class WHERE relname = 'pg_upgrade_temp_seq_int4');

-- Mark sequence as ordinary table so we can do COPY
UPDATE pg_class
SET relkind = 't'
WHERE relname = '$SEQUENCE';

-- COPY sequence out
COPY "$SEQUENCE" TO '/tmp/$$';

-- Delete int4 row from sequence
-- XXX truncate ok?
TRUNCATE "$SEQUENCE";

-- Prepare int4 sequence table for removal and remove it
UPDATE pg_attribute
SET attrelid = 
	(SELECT oid FROM pg_class WHERE relname = 'pg_upgrade_temp_seq_int4')
WHERE attrelid = 
	(SELECT oid FROM pg_class WHERE relname = '$SEQUENCE');

DROP TABLE pg_upgrade_temp_seq_int4;

-- Restore int8 version of sequence
UPDATE pg_attribute
SET attrelid = (SELECT oid FROM pg_class WHERE relname = '$SEQUENCE')
WHERE attrelid = 1;

-- Load new values
COPY "$SEQUENCE" FROM '/tmp/$$';

-- If previous max was int4, make it int8
UPDATE "$SEQUENCE"
SET max_value = 9223372036854775807
WHERE max_value BETWEEN 2147483646 AND 2147483648; -- OS rounding

-- Restore sequence flag
UPDATE pg_class
SET relkind = 'S'
WHERE relname = '$SEQUENCE';

SQL_END
			if [ $? -ne 0 ]
			then	echo "There were errors during int4 sequence restore.
$0 aborted." 1>&2
				exit 1
			fi
		done
	done
fi

echo "You may remove the $OLDDIR directory with 'rm -r $OLDDIR'."

exit 0
