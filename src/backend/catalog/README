$Header: /home/rubik/work/pgcvs/CVSROOT/pgsql/src/backend/catalog/README,v 1.3 2002-03-19 01:14:41 momjian Exp $

This directory contains .c files that manipulate the system catalogs
as well as .h files that define the structure of the system catalogs.

When the compile-time scripts (such as Gen_fmgrtab.sh and genbki.sh)
execute, they grep the DATA statements out of the .h files and munge
these in order to generate the .bki files.  The .bki files are then
used as input to initdb (which is just a wrapper around postgres
running single-user in bootstrapping mode) in order to generate the
initial (template) system catalog relation files.

-----------------------------------------------------------------

People who are going to hose around with the .h files should be aware
of the following facts:

- It is very important that the DATA statements be properly formatted
(e.g., no broken lines, proper use of white-space and _null_).  The
scripts are line-oriented and break easily.  In addition, the only
documentation on the proper format for them is the code in the
bootstrap/ directory.  Just be careful when adding new DATA
statements.

- Some catalogs require that OIDs be preallocated to tuples because
certain catalogs contain circular references.  For example, pg_type
contains pointers into pg_proc (pg_type.typinput), and pg_proc
contains back-pointers into pg_type (pg_proc.proargtypes).  In these
cases, the references may be explicitly set by use of the "OID ="
clause of the .bki insert statement.  If no such pointers are required
to a given tuple, then the OID may be set to the wildcard value 0
(i.e., the system generates a random OID in the usual way, or leaves it
0 in a catalog that has no OIDs).

If you need to find a valid OID for a set of tuples that refer to each
other, use the unused_oids script.  It generates inclusive ranges of
*unused* OIDs (i.e., the line "45-900" means OIDs 45 through 900 have
not been allocated yet).  All OIDs that are known directly to C code 
should be referenced via #defines in the catalog .h files. So 
unused_oids is sufficient for assigning new OIDs.).  The unused_oids
script simply 'discovers' those which are free.

- BOOTSTRAP tables must be at the start of the Makefile POSTGRES_BKI_SRCS
variable, as these will not be created through standard function means, but
will be written directly to disk.  Thats how pg_class is created without
depending on functions which depend on the existance of pg_class.  The
list of files this currently includes is:
	pg_proc.h pg_type.h pg_attribute.h pg_class.h

Don't forget to add the entry to heap.c to function heap_create() which
sets the OID of the relation when it's a bootstrapped system table.  It's
near the top of the function with the comment beginning in 'Real ugly stuff'


-----------------------------------------------------------------

When munging the .c files, you should be aware of certain conventions:

- The system catalog cache code (and most catalog-munging code in
general) assumes that the fixed-length portions of all system catalog
tuples are in fact present, because it maps C struct declarations onto
them.  Thus, the variable-length fields must all be at the end, and
only the variable-length fields of a catalog tuple are permitted to be
NULL.  For example, if you set pg_type.typdelim to be NULL, a
piece of code will likely perform "typetup->typdelim" (or, worse,
"typetyp->typelem", which follows typdelim).  This will result in
random errors or even segmentation violations.  Hence, do NOT insert
catalog tuples that contain NULL attributes except in their
variable-length portions!

- Modification of the catalogs must be performed with the proper
updating of catalog indexes!  That is, most catalogs have indexes
on them; when you munge them using the executor, the executor will
take care of doing the index updates, but if you make direct access
method calls to insert new or modified tuples into a heap, you must
also make the calls to insert the tuple into ALL of its indexes!  If
not, the new tuple will generally be "invisible" to the system because
most of the accesses to the catalogs in question will be through the
associated indexes.
